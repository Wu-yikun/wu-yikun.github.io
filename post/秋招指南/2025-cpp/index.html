<!DOCTYPE html><html lang="en"><head>
  <meta charset="utf-8">
  <meta name="hexo-theme" content="https://github.com/Wu-yikun/wu-yikun.github.io//tree/1.29.1" theme-name="Stellar" theme-version="1.29.1">
  
  <meta name="generator" content="Hexo 7.3.0">
  <meta http-equiv="x-dns-prefetch-control" content="on">
  
  <meta name="renderer" content="webkit">
  <meta name="force-rendering" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  <meta name="HandheldFriendly" content="True">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="theme-color" media="(prefers-color-scheme: dark)" content="#000">
  <meta name="theme-color" content="#f9fafb">
  
  <title>✍️ 八股文 @ C++ - Coredump</title>

  
    <meta name="description" content="记录面经高频 C++ 题，实时更新中...">
<meta property="og:type" content="article">
<meta property="og:title" content="✍️ 八股文 @ C++">
<meta property="og:url" content="https://wu-yikun.com/post/%E7%A7%8B%E6%8B%9B%E6%8C%87%E5%8D%97/2025-cpp/index.html">
<meta property="og:site_name" content="Coredump">
<meta property="og:description" content="记录面经高频 C++ 题，实时更新中...">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Wu-yikun/OSS/PicGo/202504070536367.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Wu-yikun/OSS/PicGo/202503021850782.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Wu-yikun/OSS/PicGo/202503021812761.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Wu-yikun/OSS/PicGo/202503021849625.jpeg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Wu-yikun/OSS/PicGo/202503070316671.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Wu-yikun/OSS/PicGo/202503070316430.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Wu-yikun/OSS/PicGo/202503070317150.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Wu-yikun/OSS/PicGo/202503070325788.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Wu-yikun/OSS/PicGo/202503260012924.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Wu-yikun/OSS/PicGo/202503260131145.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Wu-yikun/OSS/PicGo/202503260132626.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Wu-yikun/OSS/PicGo/202504281608151.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Wu-yikun/OSS/PicGo/202504281617109.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Wu-yikun/OSS@master/uPic/20250821-Ovbyi3.png">
<meta property="article:published_time" content="2025-08-22T16:00:00.000Z">
<meta property="article:modified_time" content="2025-08-25T20:55:57.172Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="C++">
<meta property="article:tag" content="面经">
<meta property="article:tag" content="八股文">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/Wu-yikun/OSS/PicGo/202504070536367.png">
  
  
  
  <meta name="keywords" content="C++,面经,八股文">

  <!-- feed -->
  

  <link rel="stylesheet" href="/css/main.css?v=1.29.1">

  
    <link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/Wu-yikun/OSS/PicGo/202505140357298.svg">
  

  

  
</head>
<body>

<div class="l_body s:aa content tech" id="start" layout="post"><aside class="l_left"><div class="leftbar-container">


<header class="header"><div class="logo-wrap"><a class="avatar" href="/"><div class="bg" style="opacity:0;background-image:url(https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/avatar/round/rainbow64@3x.webp);"></div><img no-lazy="" class="avatar lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/Wu-yikun/OSS@master/uPic/20250809-XpPHak.JPG"></a><a class="title" href="/about/"><div class="main" ff="title">Coredump</div><div class="sub normal cap">无限进步</div><div class="sub hover cap" style="opacity:0"> 無限進步</div></a></div></header>

<div class="nav-area">
<div class="search-wrapper" id="search-wrapper"><form class="search-form"><a class="search-button" onclick="document.getElementById(&quot;search-input&quot;).focus();"><svg t="1705074644177" viewBox="0 0 1025 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1560" width="200" height="200"><path d="M1008.839137 935.96571L792.364903 719.491476a56.783488 56.783488 0 0 0-80.152866 0 358.53545 358.53545 0 1 1 100.857314-335.166073 362.840335 362.840335 0 0 1-3.689902 170.145468 51.248635 51.248635 0 1 0 99.217358 26.444296 462.057693 462.057693 0 1 0-158.255785 242.303546l185.930047 185.725053a51.248635 51.248635 0 0 0 72.568068 0 51.248635 51.248635 0 0 0 0-72.978056z" p-id="1561"></path><path d="M616.479587 615.969233a50.428657 50.428657 0 0 0-61.498362-5.534852 174.655348 174.655348 0 0 1-177.525271 3.484907 49.403684 49.403684 0 0 0-58.833433 6.76482l-3.074918 2.869923a49.403684 49.403684 0 0 0 8.609771 78.10292 277.767601 277.767601 0 0 0 286.992355-5.739847 49.403684 49.403684 0 0 0 8.404776-76.667958z" p-id="1562"></path></svg></a><input type="text" class="search-input" id="search-input" placeholder="Search"></form><div id="search-result"></div><div class="search-no-result">No Results!</div></div>


<nav class="menu dis-select"></nav>
</div>
<div class="widgets">
    <widget class="widget-wrapper categories-widget"><div class="widget-header categories-header dis-select"><span class="name">分类索引</span></div><div class="widget-body"><div class="category "><svg class="category-icon" xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round">
                <path d="M18 10h-5" opacity=".5"></path>
                <path d="M10 3h6.5c.464 0 .697 0 .892.026a3 3 0 0 1 2.582 2.582c.026.195.026.428.026.892" opacity=".5"></path>
                <path d="M2 6.95c0-.883 0-1.324.07-1.692A4 4 0 0 1 5.257 2.07C5.626 2 6.068 2 6.95 2c.386 0 .58 0 .766.017a4 4 0 0 1 2.18.904c.144.119.28.255.554.529L11 4c.816.816 1.224 1.224 1.712 1.495a4 4 0 0 0 .848.352C14.098 6 14.675 6 15.828 6h.374c2.632 0 3.949 0 4.804.77c.079.07.154.145.224.224c.77.855.77 2.172.77 4.804V14c0 3.771 0 5.657-1.172 6.828C19.657 22 17.771 22 14 22h-4c-3.771 0-5.657 0-6.828-1.172C2 19.657 2 17.771 2 14z"></path>
            </svg><a href="/categories/Golang/">Golang (1)</a></div><div class="category "><svg class="category-icon" xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round">
                <path d="M18 10h-5" opacity=".5"></path>
                <path d="M10 3h6.5c.464 0 .697 0 .892.026a3 3 0 0 1 2.582 2.582c.026.195.026.428.026.892" opacity=".5"></path>
                <path d="M2 6.95c0-.883 0-1.324.07-1.692A4 4 0 0 1 5.257 2.07C5.626 2 6.068 2 6.95 2c.386 0 .58 0 .766.017a4 4 0 0 1 2.18.904c.144.119.28.255.554.529L11 4c.816.816 1.224 1.224 1.712 1.495a4 4 0 0 0 .848.352C14.098 6 14.675 6 15.828 6h.374c2.632 0 3.949 0 4.804.77c.079.07.154.145.224.224c.77.855.77 2.172.77 4.804V14c0 3.771 0 5.657-1.172 6.828C19.657 22 17.771 22 14 22h-4c-3.771 0-5.657 0-6.828-1.172C2 19.657 2 17.771 2 14z"></path>
            </svg><a href="/categories/C/">C++ (8)</a></div><div class="category "><svg class="category-icon" xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round">
                <path d="M18 10h-5" opacity=".5"></path>
                <path d="M10 3h6.5c.464 0 .697 0 .892.026a3 3 0 0 1 2.582 2.582c.026.195.026.428.026.892" opacity=".5"></path>
                <path d="M2 6.95c0-.883 0-1.324.07-1.692A4 4 0 0 1 5.257 2.07C5.626 2 6.068 2 6.95 2c.386 0 .58 0 .766.017a4 4 0 0 1 2.18.904c.144.119.28.255.554.529L11 4c.816.816 1.224 1.224 1.712 1.495a4 4 0 0 0 .848.352C14.098 6 14.675 6 15.828 6h.374c2.632 0 3.949 0 4.804.77c.079.07.154.145.224.224c.77.855.77 2.172.77 4.804V14c0 3.771 0 5.657-1.172 6.828C19.657 22 17.771 22 14 22h-4c-3.771 0-5.657 0-6.828-1.172C2 19.657 2 17.771 2 14z"></path>
            </svg><a href="/categories/%E5%B0%8F%E5%90%B3%E6%97%A5%E5%AF%84/">小吳日寄 (7)</a></div><div class="category "><svg class="category-icon" xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round">
                <path d="M18 10h-5" opacity=".5"></path>
                <path d="M10 3h6.5c.464 0 .697 0 .892.026a3 3 0 0 1 2.582 2.582c.026.195.026.428.026.892" opacity=".5"></path>
                <path d="M2 6.95c0-.883 0-1.324.07-1.692A4 4 0 0 1 5.257 2.07C5.626 2 6.068 2 6.95 2c.386 0 .58 0 .766.017a4 4 0 0 1 2.18.904c.144.119.28.255.554.529L11 4c.816.816 1.224 1.224 1.712 1.495a4 4 0 0 0 .848.352C14.098 6 14.675 6 15.828 6h.374c2.632 0 3.949 0 4.804.77c.079.07.154.145.224.224c.77.855.77 2.172.77 4.804V14c0 3.771 0 5.657-1.172 6.828C19.657 22 17.771 22 14 22h-4c-3.771 0-5.657 0-6.828-1.172C2 19.657 2 17.771 2 14z"></path>
            </svg><a href="/categories/%E5%8D%9A%E5%AE%A2%E5%BC%80%E5%8F%91/">博客开发 (2)</a></div><div class="category "><svg class="category-icon" xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round">
                <path d="M18 10h-5" opacity=".5"></path>
                <path d="M10 3h6.5c.464 0 .697 0 .892.026a3 3 0 0 1 2.582 2.582c.026.195.026.428.026.892" opacity=".5"></path>
                <path d="M2 6.95c0-.883 0-1.324.07-1.692A4 4 0 0 1 5.257 2.07C5.626 2 6.068 2 6.95 2c.386 0 .58 0 .766.017a4 4 0 0 1 2.18.904c.144.119.28.255.554.529L11 4c.816.816 1.224 1.224 1.712 1.495a4 4 0 0 0 .848.352C14.098 6 14.675 6 15.828 6h.374c2.632 0 3.949 0 4.804.77c.079.07.154.145.224.224c.77.855.77 2.172.77 4.804V14c0 3.771 0 5.657-1.172 6.828C19.657 22 17.771 22 14 22h-4c-3.771 0-5.657 0-6.828-1.172C2 19.657 2 17.771 2 14z"></path>
            </svg><a href="/categories/Python/">Python (1)</a></div><div class="category "><svg class="category-icon" xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round">
                <path d="M18 10h-5" opacity=".5"></path>
                <path d="M10 3h6.5c.464 0 .697 0 .892.026a3 3 0 0 1 2.582 2.582c.026.195.026.428.026.892" opacity=".5"></path>
                <path d="M2 6.95c0-.883 0-1.324.07-1.692A4 4 0 0 1 5.257 2.07C5.626 2 6.068 2 6.95 2c.386 0 .58 0 .766.017a4 4 0 0 1 2.18.904c.144.119.28.255.554.529L11 4c.816.816 1.224 1.224 1.712 1.495a4 4 0 0 0 .848.352C14.098 6 14.675 6 15.828 6h.374c2.632 0 3.949 0 4.804.77c.079.07.154.145.224.224c.77.855.77 2.172.77 4.804V14c0 3.771 0 5.657-1.172 6.828C19.657 22 17.771 22 14 22h-4c-3.771 0-5.657 0-6.828-1.172C2 19.657 2 17.771 2 14z"></path>
            </svg><a href="/categories/AI-Infra/">AI-Infra (6)</a></div><div class="category "><svg class="category-icon" xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round">
                <path d="M18 10h-5" opacity=".5"></path>
                <path d="M10 3h6.5c.464 0 .697 0 .892.026a3 3 0 0 1 2.582 2.582c.026.195.026.428.026.892" opacity=".5"></path>
                <path d="M2 6.95c0-.883 0-1.324.07-1.692A4 4 0 0 1 5.257 2.07C5.626 2 6.068 2 6.95 2c.386 0 .58 0 .766.017a4 4 0 0 1 2.18.904c.144.119.28.255.554.529L11 4c.816.816 1.224 1.224 1.712 1.495a4 4 0 0 0 .848.352C14.098 6 14.675 6 15.828 6h.374c2.632 0 3.949 0 4.804.77c.079.07.154.145.224.224c.77.855.77 2.172.77 4.804V14c0 3.771 0 5.657-1.172 6.828C19.657 22 17.771 22 14 22h-4c-3.771 0-5.657 0-6.828-1.172C2 19.657 2 17.771 2 14z"></path>
            </svg><a href="/categories/%E6%91%84%E5%BD%B1%E6%97%A5%E5%BF%97/">摄影日志 (17)</a></div><div class="category "><svg class="category-icon" xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round">
                <path d="M18 10h-5" opacity=".5"></path>
                <path d="M10 3h6.5c.464 0 .697 0 .892.026a3 3 0 0 1 2.582 2.582c.026.195.026.428.026.892" opacity=".5"></path>
                <path d="M2 6.95c0-.883 0-1.324.07-1.692A4 4 0 0 1 5.257 2.07C5.626 2 6.068 2 6.95 2c.386 0 .58 0 .766.017a4 4 0 0 1 2.18.904c.144.119.28.255.554.529L11 4c.816.816 1.224 1.224 1.712 1.495a4 4 0 0 0 .848.352C14.098 6 14.675 6 15.828 6h.374c2.632 0 3.949 0 4.804.77c.079.07.154.145.224.224c.77.855.77 2.172.77 4.804V14c0 3.771 0 5.657-1.172 6.828C19.657 22 17.771 22 14 22h-4c-3.771 0-5.657 0-6.828-1.172C2 19.657 2 17.771 2 14z"></path>
            </svg><a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法 (17)</a></div><div class="category "><svg class="category-icon" xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round">
                <path d="M18 10h-5" opacity=".5"></path>
                <path d="M10 3h6.5c.464 0 .697 0 .892.026a3 3 0 0 1 2.582 2.582c.026.195.026.428.026.892" opacity=".5"></path>
                <path d="M2 6.95c0-.883 0-1.324.07-1.692A4 4 0 0 1 5.257 2.07C5.626 2 6.068 2 6.95 2c.386 0 .58 0 .766.017a4 4 0 0 1 2.18.904c.144.119.28.255.554.529L11 4c.816.816 1.224 1.224 1.712 1.495a4 4 0 0 0 .848.352C14.098 6 14.675 6 15.828 6h.374c2.632 0 3.949 0 4.804.77c.079.07.154.145.224.224c.77.855.77 2.172.77 4.804V14c0 3.771 0 5.657-1.172 6.828C19.657 22 17.771 22 14 22h-4c-3.771 0-5.657 0-6.828-1.172C2 19.657 2 17.771 2 14z"></path>
            </svg><a href="/categories/%E7%A7%8B%E6%8B%9B%E6%8C%87%E5%8D%97/">秋招指南 (19)</a></div><div class="category "><svg class="category-icon" xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round">
                <path d="M18 10h-5" opacity=".5"></path>
                <path d="M10 3h6.5c.464 0 .697 0 .892.026a3 3 0 0 1 2.582 2.582c.026.195.026.428.026.892" opacity=".5"></path>
                <path d="M2 6.95c0-.883 0-1.324.07-1.692A4 4 0 0 1 5.257 2.07C5.626 2 6.068 2 6.95 2c.386 0 .58 0 .766.017a4 4 0 0 1 2.18.904c.144.119.28.255.554.529L11 4c.816.816 1.224 1.224 1.712 1.495a4 4 0 0 0 .848.352C14.098 6 14.675 6 15.828 6h.374c2.632 0 3.949 0 4.804.77c.079.07.154.145.224.224c.77.855.77 2.172.77 4.804V14c0 3.771 0 5.657-1.172 6.828C19.657 22 17.771 22 14 22h-4c-3.771 0-5.657 0-6.828-1.172C2 19.657 2 17.771 2 14z"></path>
            </svg><a href="/categories/%E7%A7%91%E7%A0%94/">科研 (7)</a></div><div class="category "><svg class="category-icon" xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round">
                <path d="M18 10h-5" opacity=".5"></path>
                <path d="M10 3h6.5c.464 0 .697 0 .892.026a3 3 0 0 1 2.582 2.582c.026.195.026.428.026.892" opacity=".5"></path>
                <path d="M2 6.95c0-.883 0-1.324.07-1.692A4 4 0 0 1 5.257 2.07C5.626 2 6.068 2 6.95 2c.386 0 .58 0 .766.017a4 4 0 0 1 2.18.904c.144.119.28.255.554.529L11 4c.816.816 1.224 1.224 1.712 1.495a4 4 0 0 0 .848.352C14.098 6 14.675 6 15.828 6h.374c2.632 0 3.949 0 4.804.77c.079.07.154.145.224.224c.77.855.77 2.172.77 4.804V14c0 3.771 0 5.657-1.172 6.828C19.657 22 17.771 22 14 22h-4c-3.771 0-5.657 0-6.828-1.172C2 19.657 2 17.771 2 14z"></path>
            </svg><a href="/categories/%E7%B3%BB%E7%BB%9F%E4%B8%8E%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/">系统与体系结构 (16)</a></div><div class="category "><svg class="category-icon" xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round">
                <path d="M18 10h-5" opacity=".5"></path>
                <path d="M10 3h6.5c.464 0 .697 0 .892.026a3 3 0 0 1 2.582 2.582c.026.195.026.428.026.892" opacity=".5"></path>
                <path d="M2 6.95c0-.883 0-1.324.07-1.692A4 4 0 0 1 5.257 2.07C5.626 2 6.068 2 6.95 2c.386 0 .58 0 .766.017a4 4 0 0 1 2.18.904c.144.119.28.255.554.529L11 4c.816.816 1.224 1.224 1.712 1.495a4 4 0 0 0 .848.352C14.098 6 14.675 6 15.828 6h.374c2.632 0 3.949 0 4.804.77c.079.07.154.145.224.224c.77.855.77 2.172.77 4.804V14c0 3.771 0 5.657-1.172 6.828C19.657 22 17.771 22 14 22h-4c-3.771 0-5.657 0-6.828-1.172C2 19.657 2 17.771 2 14z"></path>
            </svg><a href="/categories/%E8%97%8F%E4%B9%A6%E9%98%81/">藏书阁 (1)</a></div><div class="category "><svg class="category-icon" xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round">
                <path d="M18 10h-5" opacity=".5"></path>
                <path d="M10 3h6.5c.464 0 .697 0 .892.026a3 3 0 0 1 2.582 2.582c.026.195.026.428.026.892" opacity=".5"></path>
                <path d="M2 6.95c0-.883 0-1.324.07-1.692A4 4 0 0 1 5.257 2.07C5.626 2 6.068 2 6.95 2c.386 0 .58 0 .766.017a4 4 0 0 1 2.18.904c.144.119.28.255.554.529L11 4c.816.816 1.224 1.224 1.712 1.495a4 4 0 0 0 .848.352C14.098 6 14.675 6 15.828 6h.374c2.632 0 3.949 0 4.804.77c.079.07.154.145.224.224c.77.855.77 2.172.77 4.804V14c0 3.771 0 5.657-1.172 6.828C19.657 22 17.771 22 14 22h-4c-3.771 0-5.657 0-6.828-1.172C2 19.657 2 17.771 2 14z"></path>
            </svg><a href="/categories/%E6%9C%AA%E6%9D%A5%E4%B8%96%E7%95%8C%E7%9A%84%E5%B9%B8%E5%AD%98%E8%80%85/">未来世界的幸存者 (5)</a></div><div class="category "><svg class="category-icon" xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round">
                <path d="M18 10h-5" opacity=".5"></path>
                <path d="M10 3h6.5c.464 0 .697 0 .892.026a3 3 0 0 1 2.582 2.582c.026.195.026.428.026.892" opacity=".5"></path>
                <path d="M2 6.95c0-.883 0-1.324.07-1.692A4 4 0 0 1 5.257 2.07C5.626 2 6.068 2 6.95 2c.386 0 .58 0 .766.017a4 4 0 0 1 2.18.904c.144.119.28.255.554.529L11 4c.816.816 1.224 1.224 1.712 1.495a4 4 0 0 0 .848.352C14.098 6 14.675 6 15.828 6h.374c2.632 0 3.949 0 4.804.77c.079.07.154.145.224.224c.77.855.77 2.172.77 4.804V14c0 3.771 0 5.657-1.172 6.828C19.657 22 17.771 22 14 22h-4c-3.771 0-5.657 0-6.828-1.172C2 19.657 2 17.771 2 14z"></path>
            </svg><a href="/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/">开发工具 (8)</a></div><div class="category "><svg class="category-icon" xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round">
                <path d="M18 10h-5" opacity=".5"></path>
                <path d="M10 3h6.5c.464 0 .697 0 .892.026a3 3 0 0 1 2.582 2.582c.026.195.026.428.026.892" opacity=".5"></path>
                <path d="M2 6.95c0-.883 0-1.324.07-1.692A4 4 0 0 1 5.257 2.07C5.626 2 6.068 2 6.95 2c.386 0 .58 0 .766.017a4 4 0 0 1 2.18.904c.144.119.28.255.554.529L11 4c.816.816 1.224 1.224 1.712 1.495a4 4 0 0 0 .848.352C14.098 6 14.675 6 15.828 6h.374c2.632 0 3.949 0 4.804.77c.079.07.154.145.224.224c.77.855.77 2.172.77 4.804V14c0 3.771 0 5.657-1.172 6.828C19.657 22 17.771 22 14 22h-4c-3.771 0-5.657 0-6.828-1.172C2 19.657 2 17.771 2 14z"></path>
            </svg><a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络 (3)</a></div></div></widget>
</div>
<footer class="footer dis-select"><div class="social-wrap"><a class="social" href="https://github.com/Wu-yikun" target="_blank" rel="external nofollow noopener noreferrer"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/Wu-yikun/OSS/PicGo/202505140418811.svg"></a><a class="social" href="https://leetcode.cn/u/wu-yikun/" target="_blank" rel="external nofollow noopener noreferrer"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/Wu-yikun/OSS/PicGo/202505140419535.svg"></a><a class="social" href="https://juejin.cn/user/1654082381026734" target="_blank" rel="external nofollow noopener noreferrer"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/Wu-yikun/OSS/PicGo/202505140419245.svg"></a><a class="social" href="https://www.zhihu.com/people/JayChou" target="_blank" rel="external nofollow noopener noreferrer"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/Wu-yikun/OSS/PicGo/202505140419020.svg"></a><a class="social" href="https://music.163.com/#/user/home?id=1479129382" target="_blank" rel="external nofollow noopener noreferrer"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/Wu-yikun/OSS/PicGo/202505140419025.svg"></a><a class="social" href="https://space.bilibili.com/441384986?spm_id_from=333.1007.0.0" target="_blank" rel="external nofollow noopener noreferrer"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/Wu-yikun/OSS/PicGo/202505140418494.svg"></a></div></footer>
</div></aside><div class="l_main" id="main">





<div class="article banner top"><img class="bg lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/Wu-yikun/OSS@master/uPic/20250823-GIegg2.png">
  <div class="content">
    <div class="top bread-nav footnote"><div class="left"><div class="flex-row" id="breadcrumb"><a class="cap breadcrumb" href="/">Home</a>
<span class="sep"></span><a class="cap breadcrumb" href="/">Post</a><span class="sep"></span><a class="cap breadcrumb-link" href="/categories/%E7%A7%8B%E6%8B%9B%E6%8C%87%E5%8D%97/">秋招指南</a></div><div id="tag"> <span>&nbsp;标签：</span><a class="cap breadcrumb-link" href="/tags/C/">C++</a>&nbsp; <a class="cap breadcrumb-link" href="/tags/%E5%85%AB%E8%82%A1%E6%96%87/">八股文</a>&nbsp; <a class="cap breadcrumb-link" href="/tags/%E9%9D%A2%E7%BB%8F/">面经</a>&nbsp;</div>
<div class="flex-row" id="post-meta"><span class="text created">Posted on: <time datetime="2025-08-22T16:00:00.000Z">2025-08-23</time></span><span class="sep updated"></span><span class="text updated">Updated on: <time datetime="2025-08-25T20:55:57.172Z">2025-08-26</time></span></div></div></div>
    
    <div class="bottom only-title">
      
      <div class="text-area">
        <h1 class="text title"><span>✍️ 八股文 @ C++</span></h1>
        
      </div>
    </div>
    
  </div>
  </div><article class="md-text content"><blockquote>
<p>✍️ C++ 11 新特性大全：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/139515439">https://zhuanlan.zhihu.com/p/139515439</a></p>
<p>🔥 C++ 八股文 PDF：</p>
<ul>
<li><a href="/documents/cpp/C++%E5%85%AB%E8%82%A1%E6%96%87%EF%BC%88GitHub%EF%BC%89.pdf">C++ 八股文｜GitHub</a></li>
<li><a href="/documents/cpp/C++%E5%85%AB%E8%82%A1%E6%96%87%EF%BC%88%E7%89%9B%E5%AE%A2%EF%BC%89.pdf">C++ 八股文｜牛客</a></li>
<li><a href="/documents/cpp/C++%E5%85%AB%E8%82%A1%E6%96%87%EF%BC%88%E9%9A%8F%E6%83%B3%E5%BD%95%EF%BC%89.pdf">C++ 八股文｜代码随想录</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/139515439">C++ 11 新特性大全</a></li>
</ul>
</blockquote>
<h2 id="1-gcc-编译流程"><a href="#1-gcc-编译流程" class="headerlink" title="1. gcc 编译流程"></a>1. gcc 编译流程</h2><blockquote>
<p>参考链接：<a target="_blank" rel="noopener" href="https://developer.aliyun.com/article/1650283">https://developer.aliyun.com/article/1650283</a></p>
</blockquote>
<p>一段高级语言代码经过四个阶段的处理形成可执行的目标二进制代码。</p>
<p>预处理器→编译器→汇编器→链接器：最难理解的是<strong>编译与汇编的区别</strong>。</p>
<p>这里采用《深入理解计算机系统》的说法。</p>
<p><strong>预处理阶段</strong>：预处理阶段主要处理 <code>#include</code> 指令、宏替换、条件编译等，生成 <code>.i</code> 文件。</p>
<ul>
<li>展开头文件：将 <code>#include</code> 指定的文件插入到源代码中</li>
<li>宏替换：替换所有 <code>#define</code> 定义的宏</li>
<li>条件编译：根据预处理指令（如 <code>#ifdef</code>）选择性地编译代码</li>
<li>去除注释：删除源代码中的注释内容</li>
</ul>
<blockquote>
<p>写好的高级语言的程序文本比如 <code>hello.c</code>，预处理器根据 <code>#</code> 开头的命令，修改原始的程序，如<br><code>#include&lt;stdio.h&gt;</code> 将把系统中的头文件插入到程序文本中，通常是以 <code>.i</code> 结尾的文件。</p>
</blockquote>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -E source.c -o source.i</span><br></pre></td></tr></tbody></table></figure>

<p><strong>编译阶段</strong>：编译阶段对源代码进行语法语义检查，生成汇编代码，产生 <code>.s</code> 文件。</p>
<blockquote>
<p>编译器将 <code>hello.i</code> 文件翻译成汇编语言程序 <code>hello.s</code>，不同的高级语言翻译的汇编语言相同。</p>
</blockquote>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -S source.i -o source.s</span><br></pre></td></tr></tbody></table></figure>

<p><strong>汇编阶段</strong>：汇编阶段将汇编代码翻译成机器码（机器可识别的目标代码），生成 <code>.o</code> 目标文件。</p>
<blockquote>
<p>汇编器将汇编代码 <code>hello.s</code> 翻译成机器语言指令。<strong>把这些指令打包成可重定位目标程序</strong>，即 <code>.o</code> 文件。<code>hello.o</code> 是一个二进制文件，<strong>它的字节码是机器语言指令</strong>，不再是字符，前面两个阶段都还有字符。</p>
</blockquote>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -c source.s -o source.o</span><br></pre></td></tr></tbody></table></figure>

<p><strong>链接阶段</strong>： 链接阶段将多个目标文件和库文件链接在一起，生成最终的可执行文件，链接过程还可能会调用外部的动态或静态库。</p>
<blockquote>
<p>比如 <code>hello</code> 程序调用 <code>printf</code> 程序，它是每个 C 编译器都会提供的标准库 C 的函数。这个函数存在于一个名叫 <code>printf.o</code> 的单独编译好的目标文件中，这个文件将以某种方式合并到 <code>hello.o</code> 中。链接器就负责这种合并，得到的是可执行目标文件。</p>
</blockquote>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc source.o -o executable</span><br></pre></td></tr></tbody></table></figure>

<p><strong>关于编译优化</strong>：</p>
<blockquote>
<p>GCC 和 G++ 提供了多种优化选项，开发者可以根据项目需求选择合适的优化级别</p>
</blockquote>
<table>
<thead>
<tr>
<th>优化级别</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>-O0</code></td>
<td>无优化（默认）</td>
</tr>
<tr>
<td><code>-O1</code></td>
<td>基本优化</td>
</tr>
<tr>
<td><code>-O2</code></td>
<td>在不显著增加编译时间的前提下进行进一步优化</td>
</tr>
<tr>
<td><code>-O3</code></td>
<td>启用所有优化选项，可能导致代码体积增加</td>
</tr>
<tr>
<td><code>-Os</code></td>
<td>优化代码体积，适用于存储受限的设备</td>
</tr>
</tbody></table>
<h2 id="2-C-和-C-区别（函数-类-struct-class）"><a href="#2-C-和-C-区别（函数-类-struct-class）" class="headerlink" title="2. C 和 C++ 区别（函数/类/struct/class）"></a>2. C 和 C++ 区别（函数/类/struct/class）</h2><p>首先，C 和 C++ 在基本语句上没有过大的区别。</p>
<p>C++ 有<strong>新增的语法和关键字</strong>：</p>
<ul>
<li>语法的区别有<strong>头文件的不同</strong>和<strong>命名空间的不同</strong>，C++ 允许我们自己定义自己的空间，C 中不可以。</li>
<li>关键字方面比如 C++ 与 C 动态管理内存的方式不同，C++ 中在 <code>malloc</code> 和 <code>free</code> 的基础上增加了 <code>new</code>和 <code>delete</code>，而且 C++ 中在指针的基础上增加了引用的概念，关键字例如 C++中还增加了 <code>auto</code>，<code>explicit</code> 体现显示转换和隐式转换上的概念要求，还有 <code>dynamic_cast</code> 增加类型安全方面的内容。</li>
</ul>
<p>函数方面 C++ 中有<strong>重载</strong>和<strong>虚函数</strong>的概念：</p>
<ul>
<li><strong>C++ 支持函数重载而 C 不支持</strong>，是因为 C++ 函数的名字修饰与 C 不同，C++ 函数名字的修饰会将参数加在后面，例如，<code>int func(int, double)</code> 经过名字修饰之后会变成 <code>_func_int_double</code>，而 C 中则会变成<code>_func</code>，所以 C++ 中会支持不同参数调用不同函数。</li>
<li><strong>C++ 还有虚函数概念，用以实现多态</strong>。</li>
</ul>
<p>类方面，C 的 <code>struct</code> 和 C++ 的<code>类</code>也有很大不同：</p>
<ul>
<li>C++ 中的 struct 不仅可以有成员变量还可以成员函数，而且对于 struct 增加了权限访问的概念，<strong>struct 的默认成员访问权限和默认继承权限都是 <code>public</code></strong>，C++ 中除了 <code>struct</code> 还有 <code>class</code> 表示类，struct 和 class 还有一点不同在于 <strong>class 的默认成员访问权限和默认继承权限都是 <code>private</code></strong>。</li>
</ul>
<p>C++ 中增加了<strong>模板</strong>来重用代码，提供了更加强大的 <strong>STL 标准库</strong>。</p>
<p>最后补充一点就是 <strong>C 是一种结构化的语言，重点在于算法和数据结构</strong>。C 程序的设计首先考虑的是如何通过一个代码，一个过程对输入进行运算处理输出。<strong>而 C++ 首先考虑的是如何构造一个对象模型</strong>，让这个模型能够契合与之对应的问题领域，这样就能通过获取对象的状态信息得到输出。</p>
<blockquote>
<p>C 的 struct 更适合看成是一个数据结构的实现体，而 C++ 的 class 更适合看成是一个对象的实现体。</p>
</blockquote>
<h2 id="3-C-和-Java-区别（语言特性、垃圾回收、应用场景等）"><a href="#3-C-和-Java-区别（语言特性、垃圾回收、应用场景等）" class="headerlink" title="3. C++ 和 Java 区别（语言特性、垃圾回收、应用场景等）"></a>3. C++ 和 Java 区别（语言特性、垃圾回收、应用场景等）</h2><blockquote>
<p>C++ 和 Java 都有染指</p>
</blockquote>
<p><strong>指针</strong>：Java 让程序员没法找到指针来直接访问内存，没有指针的概念，并且有自动内存管理功能，从而有效地防止了 C++ 语言中的指针操作失误的影响。但并非 Java 中没有指针，Java 虚拟机内部中还是使用了指针，保证了 Java 程序的安全性。</p>
<p><strong>多重继承</strong>：C++ 支持多重继承但 Java 不支持，但支持一个类继承多个接口，实现 C++ 中多重继承的功能，又避免了 C++ 的多重继承带来的不便。</p>
<p><strong>数据类型和类</strong>：Java 是完全面向对象的语言，所有的函数和变量必须是类的一部分。除了基本数据类型之外，其余的都作为类对象，对象将数据和方法结合起来，把他们封装在类中，这样每个对象都可以实现自己的特点和行为。Java 中取消了 C++ 中的 <code>struct</code> 和 <code>union</code>。</p>
<p><strong>自动内存管理</strong>：Java 程序中所有对象都是用 <code>new</code> 操作符建立在内存堆栈上，Java 自动进行无用内存回收操作，不需要程序员进行手动删除。而 C++ 中必须由程序员释放内存资源，增加了程序设计者的负担。Java 中当一个对象不再被使用时，无用内存回收器将给他们加上标签，Java 里无用内存回收程序是以线程方式在后台运行，利用空闲时间工作来删除。</p>
<p>Java 不支持操作符重载，操作符重载是 C++ 的突出特性。</p>
<p>Java 不支持预处理功能，C++ 在编译过程中都有一个预编译阶段，Java 没有预处理器，但它提供了 <code>import</code>，与 C++ 预处理器具有类似功能。</p>
<p><strong>类型转换</strong>：C++ 中有数据类型隐含转换的机制，Java 中需要显式强制类型转换。</p>
<p><strong>字符串</strong>：C++ 中字符串是以 NULL 终止符代表字符串的结束，而 Java 的字符串是用类对象（<code>string</code> 和 <code>stringBuffer</code>）来实现的。</p>
<p>Java 中不提供 goto 语句，虽然指定 goto 为关键字，但不支持使用它。</p>
<p>Java 的异常机制用于捕获例外事件，增强系统容错能力。</p>
<h2 id="4-C-中-const-和-static-关键字的作用"><a href="#4-C-中-const-和-static-关键字的作用" class="headerlink" title="4. C++ 中 const 和 static 关键字的作用"></a>4. C++ 中 const 和 static 关键字的作用</h2><p>在 C++ 中，<code>const</code> 关键字用于定义常量，表示一个值在初始化后不可被修改，它可以修饰变量、函数参数、成员变量以及成员函数（表示该函数不会修改类的成员状态）。</p>
<p>而 <code>static</code> 关键字用于控制变量或函数的生命周期与作用域，修饰局部变量时使其在程序整个生命周期内存在且只初始化一次，<strong>修饰全局变量或函数时将其作用域限制在当前文件内</strong>，修饰类的成员时则实现共享（成员变量被所有对象共享，成员函数可不依赖对象直接调用）。</p>
<p>两者分别从不可变性与持久性/共享性两个维度提供不同的语义约束。</p>
<h3 id="static"><a href="#static" class="headerlink" title="static"></a>static</h3><p><code>static</code> 作用：控制变量的存储方式和<strong>可见性</strong>。</p>
<h4 id="1️⃣-局部静态变量"><a href="#1️⃣-局部静态变量" class="headerlink" title="1️⃣ 局部静态变量"></a>1️⃣ 局部静态变量</h4><p>一般情况下，对于<strong>局部变量</strong>在程序中是存放在栈区的，并且局部的生命周期在包含语句块执行结束时便也结束了。但是如果用 static 关键字修饰，该变量会存放在<strong>静态数据区</strong>，作用域仍为局部作用域，但是当局部静态变量离开作用域后，并没有销毁，而是仍然驻留在内存当中，只不过我们不能再对它进行访问，直到该函数再次被调用，并且值不变。</p>
<h4 id="2️⃣-全局静态变量"><a href="#2️⃣-全局静态变量" class="headerlink" title="2️⃣ 全局静态变量"></a>2️⃣ 全局静态变量</h4><blockquote>
<p>即 static 限制了全局变量的作用域（本文件）</p>
</blockquote>
<p>对于一个全局变量，它既可以在本文件中被访问到，也可以在同一个工程其它源文件被访问（添加 <code>extern</code> 进行声明即可）；而使用 <code>static</code> 对全局变量进行修饰改变了其作用域范围，<strong>由原来整个工程可见变成了本文件可见</strong>，同时也是存放在静态数据区，在整个程序运行期间一直存在。</p>
<h4 id="3️⃣-静态函数"><a href="#3️⃣-静态函数" class="headerlink" title="3️⃣ 静态函数"></a>3️⃣ 静态函数</h4><p>函数的定义和声明在<strong>默认</strong>情况下都是 <code>extern</code> 的，但静态函数只是在声明它的文件当中可见（与全局静态变量类似）</p>
<h4 id="4️⃣-类的静态成员-函数"><a href="#4️⃣-类的静态成员-函数" class="headerlink" title="4️⃣ 类的静态成员/函数"></a>4️⃣ 类的静态成员/函数</h4><p>在类中，静态成员可以实现多个对象之间的数据共享，并且使用静态数据成员还不会破坏隐藏的原则，即保证了安全性。因此静态成员/函数是类中所有对象共享的成员/函数，而不是某个对象的成员/函数。</p>
<ul>
<li>在模块内的 static 全局变量可以被模块内所有函数访问，<strong>但不能被模块外其它函数访问</strong>；</li>
<li>在类中的 static 成员变量属于整个类所拥有，对类的所有对象只有一份拷⻉；</li>
<li>在类中的 static 成员函数属于整个类所拥有，<strong>这个函数不接收 this 指针</strong>，因而只能访问类的 static 成员变量；</li>
<li>static 类对象必须要在类外进行初始化，<strong>static 修饰的变量先于对象存在</strong>，所以 static 修饰的变量要在类外初始化；</li>
<li>由于 static 修饰的类成员属于类，不属于对象，因此 static 类成员函数是没有 <code>this</code> 指针，this 指针是指向本对象的指针，正因为没有 this 指针，所以 static 类成员函数不能访问非 static 的类成员，只能访问 static 修饰的类成员；</li>
<li><strong>static 成员函数不能被 <code>virtual</code> 修饰</strong>，static 成员不属于任何对象或实例，所以加上 virtual 没有任何实际意义；静态成员函数没有 this 指针，虚函数的实现是为每一个对象分配一个 vptr 指针，而 vptr 是通过 this 指针调用的，所以不能为 virtual；虚函数的调用关系，this-&gt;vptr-&gt;ctable-&gt;virtual function。</li>
</ul>
<h3 id="const"><a href="#const" class="headerlink" title="const"></a>const</h3><h4 id="1️⃣-const-修饰基本数据类型"><a href="#1️⃣-const-修饰基本数据类型" class="headerlink" title="1️⃣ const 修饰基本数据类型"></a>1️⃣ const 修饰基本数据类型</h4><p>修饰符 const 可以用在类型说明符前，也可以在类型说明符后，结果都是一样的，使用这些常量时，只要不改变这些常量的值即可。</p>
<h4 id="2️⃣-const-修饰指针变量和引用变量"><a href="#2️⃣-const-修饰指针变量和引用变量" class="headerlink" title="2️⃣ const 修饰指针变量和引用变量"></a>2️⃣ const 修饰指针变量和引用变量</h4><blockquote>
<p>引用同理</p>
</blockquote>
<p>如果 const 位于 <code>const T*</code> 左侧，则 const 就是用来修饰指针所指向的变量，即指针指向为常量。</p>
<p>如果 const 位于 <code>T* const</code> 右侧，则 const 就是修饰指针本身，即指针本身是常量。</p>
<h4 id="3️⃣-const-应用到函数中"><a href="#3️⃣-const-应用到函数中" class="headerlink" title="3️⃣ const 应用到函数中"></a>3️⃣ const 应用到函数中</h4><ol>
<li>作为参数的 const 修饰符：调用函数时，用相应的变量初始化 const 常量，则在函数体中，按照 const 所修饰的部分进行常量化，保护了原对象的属性。</li>
<li>作为函数返回值的 const 修饰符：声明了返回值后，它意味着这个返回值是一个常量，不能被修改。</li>
</ol>
<p>注意：参数 const 通常用于参数为指针或引用的情况。</p>
<h4 id="4️⃣-const-在类中的用法"><a href="#4️⃣-const-在类中的用法" class="headerlink" title="4️⃣ const 在类中的用法"></a>4️⃣ const 在类中的用法</h4><ol>
<li>const 成员变量：只在某个对象生命周期内是常量，而对于整个类而言是可以改变的（因为类可以创建多个对象，不同对象其 const 数据成员值可以不同，<strong>所以不能在类的声明中初始化 const 数据成员</strong>，因为类对象在没有创建的时候，编译器不知道 const 数据成员的值是什么，<strong>const 数据成员的初始化只能在类的构造函数初始化列表中进行</strong>）</li>
<li>const 成员函数：<strong>防止成员函数修改对象的内容</strong>，要注意，<strong>const 和 static 对于成员函数来说是不能同时使用的</strong>，因为 static 关键字修饰静态成员函数不含有 this 指针，即不能实例化，const 成员函数又必须具体到某一个函数。</li>
</ol>
<p>补充：</p>
<ul>
<li>const 成员函数如果实在想修改某个变量，可以使用 <code>mutable</code> 进行修饰；</li>
<li>成员变量中如果想建立在整个类中都恒定的常量，应该用类中的<code>枚举常量</code>来实现或者 <code>static const</code>。</li>
</ul>
<h4 id="5️⃣-const-修饰类对象、定义常量函数"><a href="#5️⃣-const-修饰类对象、定义常量函数" class="headerlink" title="5️⃣ const 修饰类对象、定义常量函数"></a>5️⃣ const 修饰类对象、定义常量函数</h4><p><strong>const 常量对象只能调用 const 常量函数</strong>，非 const 成员函数都不能调用。</p>
<p>原因：对象调用成员函数时，在形参列表的最前面加一个形参 this，但这是隐式的。this 指针是默认指向调用函数的当前对象的，所以很自然，this 是一个常量指针 <code>test * const</code>，因为不可以修改 this 指针代表的地址。但当成员函数的参数列表后加了 const 关键字（<code>void print() const;</code>），此成员函数为常量成员函数，此时它的隐式 this 形参为 <code>const test * const</code>，<strong>表示指向常量对象的常量指针</strong>，即不可以通过 this 指针来改变指向对象的值。</p>
<blockquote>
<p>非常量对象可以调用类中的 const 成员函数，也可以调用非 const 成员函数。</p>
</blockquote>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test</span>(<span class="type">int</span> val) : <span class="built_in">value</span>(val) {}</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 常量成员函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> <span class="type">const</span> </span>{</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"Value: "</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 非常量成员函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setValue</span><span class="params">(<span class="type">int</span> val)</span> </span>{</span><br><span class="line">        value = val;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function"><span class="type">const</span> Test <span class="title">obj</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    obj.<span class="built_in">print</span>(); <span class="comment">// OK，调用常量成员函数</span></span><br><span class="line">    <span class="comment">// obj.setValue(20); // 错误，`const`对象不能调用非常量成员函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>⚠️ 注意区别 <code>int print() const;</code> 和 <code>const int print();</code>：</p>
<ul>
<li>前者为常量成员函数，<code>const</code> 位于函数声明的末尾，只能由 const 常量对象来调用该 const 常量函数。</li>
<li>后者为普通成员函数，但是返回值为 <code>const int</code>（注意不能用 const 修饰 void，即 <code>const void print()</code> 会编译错误，所以这里用了 <code>int</code>）</li>
</ul>
<h2 id="5-说一说-C-中四种-cast-转换"><a href="#5-说一说-C-中四种-cast-转换" class="headerlink" title="5. 说一说 C++ 中四种 cast 转换"></a>5. 说一说 C++ 中四种 cast 转换</h2><p>C++ 中四种类型转换是：<code>static_cast</code>、<code>dynamic_cast</code>、<code>const_cast</code>、<code>reinterpret_cast</code></p>
<h3 id="const-cast"><a href="#const-cast" class="headerlink" title="const_cast"></a>const_cast</h3><p>用于将 const 变量转为非 const 变量：常量指针转换为⾮常量指针，并且仍然指向原来的对象；常量引⽤被转换为⾮常量引⽤，并且仍然指向原来的对象。<code>const_cast</code> 去掉类型的 <code>const</code> 或 <code>volatile</code> 属性。</p>
<h3 id="static-cast"><a href="#static-cast" class="headerlink" title="static_cast"></a>static_cast</h3><p>用于各种隐式转换，但是没有运行时类型检查来保证转换的安全性。</p>
<p>比如非 const 转 const，void* 转指针等，static_cast 还可以用于<strong>多态向上转换</strong>（如 Derived 转 Base，即子类转基类）</p>
<ul>
<li>进行向上转换（把派生类指针或引用转换为基类）是安全的</li>
<li>进行向下转换（把基类指针或引用转换为派生类），由于没有运行时类型检查，所以是不安全的</li>
</ul>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Base 是 Derived 的基类/父类</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    Derived* d;</span><br><span class="line">    Base* base = <span class="built_in">static_cast</span>&lt;Base*&gt;(d);    <span class="comment">// 向上类型转换</span></span><br><span class="line">    base-&gt;<span class="built_in">show</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="dynamic-cast"><a href="#dynamic-cast" class="headerlink" title="dynamic_cast"></a>dynamic_cast</h3><p>在进行向下转换时，<code>dynamic_cast</code> 具有类型检查（信息在虚函数中）的功能，比 <code>static_cast</code> 更安全。</p>
<p>只能用于含有虚函数的类，用于类层次间的向上和向下转换（基类转子类），只能转指针或引用，向下转换时：</p>
<ul>
<li>对于指针，转换失败则返回 <code>nullptr</code></li>
<li>对于引用，转换失败则抛异常</li>
</ul>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    Base* base = <span class="keyword">new</span> Derived; <span class="comment">// 不使用 static_cast 也可以隐式向上转换</span></span><br><span class="line">    Derived* derive = <span class="built_in">dynamic_cast</span>&lt;Derived*&gt;(base);    <span class="comment">// 向下类型转换，使用 dynamic_cast</span></span><br><span class="line">    <span class="keyword">if</span> (derive) {</span><br><span class="line">        derive-&gt;<span class="built_in">show</span>();</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"Conversion failed!"</span> &lt;&lt; std::endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> base;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="reinterpret-cast"><a href="#reinterpret-cast" class="headerlink" title="reinterpret_cast"></a>reinterpret_cast</h3><p>几乎什么都可以转，比如将 int 转指针，可能会出问题，尽量少用。</p>
<p>WARNING：reinterpret_cast 本质上依赖于机器，要想安全地使用 reinterpret_cast 必须对涉及的类型和编译器实现转换的过程都非常了解。</p>
<h3 id="为什么不使用-C-的强制转换？"><a href="#为什么不使用-C-的强制转换？" class="headerlink" title="为什么不使用 C 的强制转换？"></a>为什么不使用 C 的强制转换？</h3><p>C 的强制转换表面上看起来功能强大什么都能转，但是转化不够明确，不能进行错误检查，容易出错。</p>
<h3 id="static-cast-与-dynamic-cast-之间的区别？"><a href="#static-cast-与-dynamic-cast-之间的区别？" class="headerlink" title="static_cast 与 dynamic_cast 之间的区别？"></a>static_cast 与 dynamic_cast 之间的区别？</h3><p><code>dynamic_cast</code> 和 <code>static_cast</code> 的主要区别在于类型检查的时间点和安全性：</p>
<ul>
<li><strong>类型检查时间点</strong>：<code>static_cast</code>在编译时进行类型检查，而<code>dynamic_cast</code>在运行时进行类型检查。</li>
<li><strong>安全性</strong>：<code>static_cast</code>不执行运行时类型检查，因此如果在类层次结构中进行不安全的向下转换，可能导致未定义行为。相反，<code>dynamic_cast</code> 会在运行时检查转换的安全性，如果转换不安全，则返回<code>nullptr</code>或抛出异常，提供更高的安全性。</li>
</ul>
<h2 id="6-C-C-的四大内存分区和常量的存储位置"><a href="#6-C-C-的四大内存分区和常量的存储位置" class="headerlink" title="6. C/C++ 的四大内存分区和常量的存储位置"></a>6. C/C++ 的四大内存分区和常量的存储位置</h2><p>四大内存分区：栈、堆、静态存储区（全局变量 + 静态变量 + 常量）和代码区。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/Wu-yikun/OSS/PicGo/202504070536367.png" alt="image-20250407053610463"></p>
<h3 id="1️⃣-栈区"><a href="#1️⃣-栈区" class="headerlink" title="1️⃣ 栈区"></a>1️⃣ 栈区</h3><p>由系统进行内存的管理。主要存放函数的参数以及局部变量。在函数完成执行，系统自动释放栈区内存，不需要用户管理，整个程序的栈区大小可以在编译器中由用户自行设定，VS 中默认的栈区大小为 1M，可以通过 VS 手动更改栈的大小。64 bits 的 Linux 默认栈大小为 10MB，可通过 <code>ulimit -s</code> 临时修改，可通过 <code>ulimit -a</code> 查看。</p>
<h3 id="2️⃣-堆区"><a href="#2️⃣-堆区" class="headerlink" title="2️⃣ 堆区"></a>2️⃣ 堆区</h3><p>由程序员手动申请，手动释放，若不手动释放，程序结束后由系统回收，生命周期是整个程序运行期间。使用 <code>malloc</code> 或者 <code>new</code> 进行堆的申请，<strong>堆的总大小为机器的虚拟内存的大小</strong>。</p>
<p>说明：<code>new</code> 操作符本质上是使用了 <code>malloc</code> 进行内存的申请，<code>new</code> 和 <code>malloc</code> 的区别如下：</p>
<ol>
<li><code>malloc</code> 是 C 语言中的函数，而 <code>new</code> 是 C++ 中的操作符。</li>
<li><code>malloc</code> 申请之后返回的类型是 <code>void*</code>，而 <code>new</code> 返回的指针带有类型。</li>
<li><code>malloc</code> 只负责内存的分配而不会调用类的构造函数，而 <code>new</code> 不仅会分配内存，而且会自动调用类的构造函数。</li>
</ol>
<h4 id="堆和栈的区别"><a href="#堆和栈的区别" class="headerlink" title="堆和栈的区别"></a>堆和栈的区别</h4><p>申请方式不同：</p>
<ul>
<li>栈是系统自动分配</li>
<li>堆是自己申请和释放的</li>
</ul>
<p>申请大小限制不同：</p>
<ul>
<li>栈空间默认 10 MB；栈顶和栈底是之前预设好的，栈是向栈底扩展，大小固定，可以通过 <code>ulimit -a</code> 查看，由 <code>ulimit -s</code> 修改</li>
<li>堆区一般是 1G~4G；堆向高地址扩展，是不连续的内存区域，大小可以灵活调整</li>
</ul>
<p>申请效率不同：</p>
<ul>
<li>栈由系统分配，速度快，不会有碎片</li>
<li>堆由程序员分配，速度慢，且会有碎片</li>
</ul>
<h4 id="栈快还是堆快？"><a href="#栈快还是堆快？" class="headerlink" title="栈快还是堆快？"></a>栈快还是堆快？</h4><p>毫无疑问是栈快一点。</p>
<p>因为操作系统会在底层对栈提供支持，会分配专门的寄存器存放栈的地址，栈的入栈出栈操作也十分简单，并且有专门的指令执行，所以栈的效率比较高也比较快。</p>
<p>而堆的操作是由 C/C++ 函数库提供的，在分配堆内存的时候需要一定的算法寻找合适大小的内存。并且获取堆的内容需要两次访问，第一次访问指针，第二次根据指针保存的地址访问内存，因此堆比较慢。</p>
<h3 id="3️⃣-静态存储区"><a href="#3️⃣-静态存储区" class="headerlink" title="3️⃣ 静态存储区"></a>3️⃣ 静态存储区</h3><blockquote>
<p>静态存储区 = 全局数据区 + 常量区</p>
<p>全局数据区：全局变量 + 静态变量，该区域会被自动初始化</p>
<p>常量区：存放常量，不允许修改</p>
</blockquote>
<p>静态存储区内的变量在程序编译阶段已经分配好内存空间并初始化。这块内存在程序的整个运行期间都存在，它主要存放 <strong>static 静态变量</strong>、<strong>全局变量</strong>和 <strong>const 常量</strong>。</p>
<blockquote>
<p>区分：<code>static</code> 修饰「局部变量」在静态存储区中；<code>const</code> 修饰「局部变量」则是在栈区中。</p>
</blockquote>
<p>注意：</p>
<ol>
<li>这里不区分初始化和未初始化的数据区，是因为静态存储区内的变量若不显示初始化，<strong>则编译器会自动以默认的方式进行初始化，即静态存储区内不存在未初始化的变量</strong>。</li>
<li>静态存储区内的常量分为<strong>常变量</strong>和<strong>字符串常量</strong>，一经初始化，不可修改。静态存储内的常变量是全局变量，与局部常变量不同，<strong>区别在于局部常变量存放于栈</strong>，实际可间接通过指针或者引用进行修改，而全局常变量存放于静态常量区则不可以间接修改。</li>
<li>字符串常量存储在静态存储区的常量区，字符串常量的名称即为它本身，属于常变量。</li>
<li>数据区的具体划分，有利于我们对于变量类型的理解。不同类型的变量存放的区域不同。后面将以实例代码说明这四种数据区中具体对应的变量。</li>
</ol>
<h3 id="4️⃣-代码区"><a href="#4️⃣-代码区" class="headerlink" title="4️⃣ 代码区"></a>4️⃣ 代码区</h3><p>存放程序体的二进制代码，比如我们写的函数都是在代码区。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">0</span>;<span class="comment">//静态全局变量区</span></span><br><span class="line"><span class="type">char</span> *p1; <span class="comment">//编译器默认初始化为NULL</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span> b; <span class="comment">//栈</span></span><br><span class="line">    <span class="type">char</span> s[] = <span class="string">"abc"</span>;<span class="comment">//栈</span></span><br><span class="line">    <span class="type">char</span> *p2 = <span class="string">"123456"</span>;<span class="comment">//123456在字符串常量区，p2在栈上</span></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> c =<span class="number">0</span>; <span class="comment">//c在静态变量区，0为文字常量，在代码区</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> d=<span class="number">0</span>; <span class="comment">//栈</span></span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> d;<span class="comment">//静态常量区</span></span><br><span class="line">    p1 = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="number">10</span>);<span class="comment">//分配得来得10字节在堆区。</span></span><br><span class="line">    <span class="built_in">strcpy</span>(p1, <span class="string">"123456"</span>); <span class="comment">//123456放在字符串常量区，编译器可能会将它与p2所指向的"123456"优化成一个地方</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="7a-C-中-class-的大小由哪些因素决定？"><a href="#7a-C-中-class-的大小由哪些因素决定？" class="headerlink" title="7a. C++ 中 class 的大小由哪些因素决定？"></a>7a. C++ 中 class 的大小由哪些因素决定？</h2><p>在 C++ 中，类的大小由多个因素决定，主要包括：</p>
<ol>
<li><strong>普通成员变量</strong>：类中定义的非静态成员变量会直接影响类的大小。每个成员变量都会占用相应的内存空间。</li>
<li><strong>虚函数</strong>：如果类包含虚函数，编译器会为该类添加一个虚函数表（vtable），并在每个对象中添加一个指向该表的指针（vptr），这会增加每个对象的大小。</li>
<li><strong>继承</strong>：类的继承关系也会影响其大小。<ul>
<li><strong>单一继承</strong>：派生类会继承基类的成员变量和成员函数，但不会直接增加对象的大小。</li>
<li><strong>多重继承</strong>：派生类继承多个基类时，可能会导致对象中包含多个基类的子对象，从而增加对象的大小。</li>
<li><strong>虚拟继承</strong>：为了解决菱形继承问题，编译器可能会在派生类中引入虚拟基类指针，增加对象的大小。</li>
</ul>
</li>
<li><strong>内存对齐</strong>：<strong>编译器通常会对类的成员变量进行内存对齐</strong>，以提高访问效率。这可能导致类的实际大小大于成员变量总和。<ul>
<li>分配内存的顺序是按照声明的顺序。</li>
<li>每个变量相对于起始位置的偏移量必须是该变量类型大小的整数倍，不是整数倍空出内存，直到偏移量是整数倍为止。</li>
<li>最后整个结构体的大小必须是里面变量类型最大值的整数倍。</li>
</ul>
</li>
</ol>
<p>⚠️ 需要注意的是，类的构造函数、析构函数、静态成员变量、静态成员函数和普通成员函数不会直接影响类的大小。</p>
<ul>
<li>构造函数和析构函数：<ul>
<li>构造函数和析构函数是特殊的成员函数，用于对象的初始化和销毁。</li>
<li>它们的存在不会增加类的实例大小，因为它们在对象创建和销毁时被调用，但并不占用对象的内存空间。</li>
</ul>
</li>
<li>静态成员变量：<ul>
<li>静态成员变量属于类本身，而不是类的实例。</li>
<li>它们在类的所有实例之间共享，只有一份存储空间（<strong>静态存储区</strong>）。</li>
</ul>
</li>
<li>静态成员函数：<ul>
<li>静态成员函数也属于类本身，而不是类的实例。</li>
<li>它们在类的所有实例之间共享，只有一份存储空间。</li>
</ul>
</li>
<li>普通成员函数：<ul>
<li>普通成员函数是类的成员，<strong>但普通成员函数的代码通常存储在程序的代码段中</strong>，而不是对象的内存中。</li>
<li>因此，普通成员函数不会影响类的实例大小。</li>
</ul>
</li>
</ul>
<h2 id="7b-7a-类似问题-C-的对象存储空间是怎么安排的？"><a href="#7b-7a-类似问题-C-的对象存储空间是怎么安排的？" class="headerlink" title="7b. [7a 类似问题] C++ 的对象存储空间是怎么安排的？"></a>7b. [7a 类似问题] C++ 的对象存储空间是怎么安排的？</h2><p>C++ 中对象的存储取决于：</p>
<ul>
<li>对象的类型（普通对象、继承对象、虚函数表等）</li>
<li>存储方式（栈、堆、静态存储区）</li>
<li>对齐方式</li>
</ul>
<p>具体来说：</p>
<p>1️⃣ 普通对象</p>
<p>（1）<strong>非静态成员变量</strong></p>
<ul>
<li>普通对象的非静态成员变量按照 <strong>声明顺序</strong> 在内存中存储。</li>
<li>编译器会根据 CPU 架构和优化需求进行 <strong>内存对齐</strong>（alignment），可能会插入填充字节（padding）。</li>
<li>类的大小通常是 <strong>最大成员类型的对齐倍数</strong>。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> {</span><br><span class="line">    <span class="type">char</span> c;   <span class="comment">// 1 字节</span></span><br><span class="line">    <span class="type">int</span> i;    <span class="comment">// 4 字节</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">sizeof</span>(A) &lt;&lt; std::endl;  <span class="comment">// 输出可能是 8（对齐）</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>内存布局（假设 4 字节对齐）：</strong></p>
<figure class="highlight less"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">| <span class="selector-tag">c</span> (<span class="number">1</span>B) | <span class="selector-tag">padding</span> (<span class="number">3</span>B) | <span class="selector-tag">i</span> (<span class="number">4</span>B) |</span><br></pre></td></tr></tbody></table></figure>

<p>（2）<strong>静态成员变量</strong>：不属于对象本身，放在静态存储区，在程序启动时分配。</p>
<p>2️⃣ 继承</p>
<p>（1）非虚继承：没有 <code>virtual</code></p>
<p><strong>派生类对象包括基类的成员变量</strong>，存储顺序是：</p>
<ol>
<li>基类子成员</li>
<li>派生类新增成员</li>
<li>对齐填充</li>
</ol>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Base</span> {</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base {</span><br><span class="line">    <span class="type">char</span> b;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">sizeof</span>(Derived) &lt;&lt; std::endl;  <span class="comment">// 可能是 8（对齐）</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">内存分布：| Base::<span class="built_in">a</span> (<span class="number">4</span>B) | Derived::<span class="built_in">b</span> (<span class="number">1</span>B) | <span class="built_in">padding</span> (<span class="number">3</span>B) |</span><br></pre></td></tr></tbody></table></figure>

<p>（2）虚继承：基类含有 <code>virtual</code> 方法</p>
<ul>
<li>**<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/342271992">虚基类</a>**存储方式不同，编译器会创建虚基类指针 <code>vptr</code> 以及虚基类表 <code>vtable</code> 来管理它</li>
<li>可能会多一个指向虚基类表的<strong>指针</strong>，因此对象的大小会变大</li>
</ul>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Base</span> {</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>{}  <span class="comment">// 引入虚表</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base {</span><br><span class="line">    <span class="type">char</span> b;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">sizeof</span>(Derived) &lt;&lt; std::endl;  <span class="comment">// 可能是 16（虚表指针 + 对齐）</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 假设指针 8 字节</span></span><br><span class="line">| <span class="built_in">vptr</span> (<span class="number">8</span>B) | Base::<span class="built_in">a</span> (<span class="number">4</span>B) | <span class="built_in">padding</span> (<span class="number">3</span>B) | Derived::<span class="built_in">b</span> (<span class="number">1</span>B) |</span><br></pre></td></tr></tbody></table></figure>

<p>3️⃣ 多重继承</p>
<ul>
<li><strong>非虚多重继承</strong>：派生类按继承顺序依次存储多个基类的成员变量。</li>
<li><strong>虚多重继承</strong>：对象中会存储多个虚表指针，可能引入 <strong>虚基类偏移表</strong>。</li>
</ul>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> {</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span> {</span><br><span class="line">    <span class="type">double</span> b;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">C</span> : <span class="keyword">public</span> A, <span class="keyword">public</span> B {</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">sizeof</span>(C) &lt;&lt; std::endl;  <span class="comment">// 可能是 24（对齐 + 多继承）</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">| A::<span class="built_in">a</span> (<span class="number">4</span>B) | <span class="built_in">padding</span> (<span class="number">4</span>B) | B::<span class="built_in">b</span> (<span class="number">8</span>B) | C::<span class="built_in">c</span> (<span class="number">1</span>B) | <span class="built_in">padding</span> (<span class="number">7</span>B) |</span><br></pre></td></tr></tbody></table></figure>

<p>4️⃣ 对象存储方式</p>
<ul>
<li>栈上对象：<strong>普通局部对象</strong>，生命周期受到作用域控制</li>
<li>堆上对象：使用 <code>new</code> 关键词分配的对象存储在堆区，需要手动 <code>delete</code></li>
<li>静态存储区：<code>static</code> 变量存储在静态存储区</li>
</ul>
<p>5️⃣ 虚函数和 vtable 虚表</p>
<ul>
<li>如果类中有 <strong>虚函数</strong>，编译器会为该类生成 <strong>虚表（vtable）</strong>，并在对象中存储 <strong>虚指针（vptr）</strong>，指向该虚表。</li>
<li><strong>虚表存储在静态区</strong>，而 <strong>vptr 存储在对象头部</strong>（通常是对象的第一个成员）。</li>
<li>vptr 使得多态调用能够动态绑定。</li>
</ul>
<p>⚠️ 虚指针存储在对象头部；<strong>虚表存储在静态存储区</strong>。</p>
<h2 id="8-new-delete-和-malloc-free-有什么区别和联系？"><a href="#8-new-delete-和-malloc-free-有什么区别和联系？" class="headerlink" title="8. new/delete 和 malloc/free 有什么区别和联系？"></a>8. new/delete 和 malloc/free 有什么区别和联系？</h2><blockquote>
<p>更多内容（讲得很好）：<a target="_blank" rel="noopener" href="https://jacktang816.github.io/post/cppnewdelete/">C++ 种内存管理之 new/delete</a></p>
</blockquote>
<p><strong>联系</strong>：都可以用来在堆上分配和回收空间，<code>new</code>/<code>delete</code> 是操作符，<code>malloc</code>/<code>free</code> 是库函数。</p>
<p><strong>执行 new 实际上执行两个过程</strong>：</p>
<ol>
<li>调用 <code>malloc</code> 分配未初始化的内存空间</li>
<li>使用对象的构造函数对空间进行初始化，并返回空间的首地址</li>
</ol>
<p><strong>执行 delete 实际上也有两个过程</strong>：</p>
<ol>
<li>使用析构函数对对象进行析构</li>
<li>调用 <code>free</code> 释放指针所指向空间的内存</li>
</ol>
<p><strong>二者区别</strong>：<code>new</code> 得到的是经过初始化的空间，而 <code>malloc</code> 得到的是未初始化的空间，所以 new 是 new 一个类型，而 malloc 则是 malloc 一个字节长度的空间。<code>delete</code> 和 <code>free</code> 同理，delete 不仅释放空间还析构对象，delete 一个类型，free 一个字节长度的空间。</p>
<h3 id="对象的自动删除"><a href="#对象的自动删除" class="headerlink" title="对象的自动删除"></a>对象的自动删除</h3><p>通过之前的分析我们知道，<code>new</code>关键字创建对象并非一步完成，而是通过先分配未初始化内存和调用构造函数初始化两步实现的。那么在这个过程中如果是第一步出错，那么内存分配失败不会调用构造函数，这是没有问题的。但是如果第一步已经完成在堆中已经成功分配了内存之后，在第二步调用构造函数时异常导致创建对象失败（抛出 <code>std::bad_alloc</code>），那么就应该将第一步中申请的内存释放。C++中规定，如果一个对象无法完全构造，那么这个对象就是一个无效对象，也不会调用析构函数。因此为了保证对象的完整性，当通过 new 分配的堆内存对象在构造函数执行过程中出现异常时，就会停止构造函数的执行并且自动调用对应的 <code>delete</code> 运算符来对已经分配好的对内存执行销毁处理，即对象的自动删除技术。</p>
<h3 id="🔥-为什么有了-malloc-free-还需要-new-delete"><a href="#🔥-为什么有了-malloc-free-还需要-new-delete" class="headerlink" title="🔥 为什么有了 malloc/free 还需要 new/delete"></a>🔥 为什么有了 malloc/free 还需要 new/delete</h3><p>因为对于非内部数据类型而言，光用 malloc/free 无法满足动态对象的要求。对象在创建的同时需要自动执行构造函数，对象在消亡以前要自动执行析构函数。由于 malloc/free 是库函数而不是操作符，不在编译器控制权限之内，不能够把执行的构造函数和析构函数的任务强加于 malloc/free，所以在 C++ 中需要一个能完成动态内存分配和初始化工作的运算符 new，以及一个能完成清理和释放内存工作的运算符 delete。而且在对非基本数据类型的对象使用的时候，对象创建的时候还需要执行构造函数，销毁的时候要执行析构函数。而 malloc/free 是库函数，<strong>是已经编译的代码</strong>，所以不能把构造函数和析构函数的功能强加给 malloc/free，所以 new/delete 是必不可少的。</p>
<p><strong>既然 new/delete 的功能完全覆盖了 malloc/free，为什么 C++ 不把 malloc/free 淘汰出局呢</strong>？这是因为 C++ 程序经常要调用 C 函数，而 C 程序只能用 malloc/free 管理动态内存。</p>
<h3 id="🔥-malloc-与-free-的实现原理（brk-、mmap-）"><a href="#🔥-malloc-与-free-的实现原理（brk-、mmap-）" class="headerlink" title="🔥 malloc 与 free 的实现原理（brk()、mmap()）"></a>🔥 malloc 与 free 的实现原理（<code>brk()</code>、<code>mmap()</code>）</h3><p>1、在标准 C 库中，提供了 <code>malloc/free</code> 函数分配释放内存，这两个函数底层是由 <code>brk</code>、<code>mmap</code>、<code>munmap</code> 这些系统调用实现的;</p>
<ul>
<li><code>brk</code> 是将「堆顶」指针向高地址移动，获得新的内存空间；</li>
<li><code>mmap</code> 是在进程的虚拟地址空间中（堆和栈中间，称为文件映射区域的地方）找一块空闲的虚拟内存。</li>
</ul>
<p><strong>这两种方式分配的都是虚拟内存，没有分配物理内存。在第一次访问已分配的虚拟地址空间的时候，发生缺页中断，操作系统负责分配物理内存，然后建立虚拟内存和物理内存之间的映射关系</strong>。</p>
<p>2、malloc 分配阈值</p>
<ul>
<li>malloc 小于 128k 的内存，使用 <code>brk</code> 分配内存，将「堆顶」指针往高地址推；</li>
<li>malloc 大于 128k 的内存，使用 <code>mmap</code> 分配内存，在堆和栈之间找一块空闲内存分配；</li>
</ul>
<p><strong>brk 分配的内存需要等到高地址内存释放以后才能释放，而 mmap 分配的内存可以单独释放</strong>。当最高地址空间的空闲内存超过 128K（可由 <code>M_TRIM_THRESHOLD</code> 选项调节）时，执行内存紧缩操作（<code>trim</code>）。在上一个步骤 free 的时候，发现最高地址空闲内存超过 128K，于是内存紧缩。</p>
<p>3、空闲地址链表：malloc 是从堆里面申请内存，也就是说函数返回的指针是指向堆里面的一块内存。操作系统中有一个记录空闲内存地址的链表。当操作系统收到程序的申请时，就会遍历该链表，然后就寻找第一个空间大于所申请空间的堆结点，然后就将该结点从空闲结点链表中删除，并将该结点的空间分配给程序。</p>
<h3 id="🔥-被-free-回收的内存是立即返回给操作系统吗？"><a href="#🔥-被-free-回收的内存是立即返回给操作系统吗？" class="headerlink" title="🔥 被 free 回收的内存是立即返回给操作系统吗？"></a>🔥 被 free 回收的内存是立即返回给操作系统吗？</h3><blockquote>
<p>更详细的内容：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/0voice/kernel_memory_management/blob/main/%E2%9C%8D%20%E6%96%87%E7%AB%A0/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%20glibc%20malloc%EF%BC%9A%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%99%A8%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86.md#4-chunk">深入理解 glibc malloc: 内存分配器实现原理</a></li>
<li><a target="_blank" rel="noopener" href="https://xiaolincoding.com/os/3_memory/malloc.html#free-%E9%87%8A%E6%94%BE%E5%86%85%E5%AD%98-%E4%BC%9A%E5%BD%92%E8%BF%98%E7%BB%99%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%90%97">xiaolincoding</a></li>
</ul>
</blockquote>
<p>不一定。被 <code>free</code> 的内存<strong>不一定会立刻返回给操作系统</strong>，具体行为取决于操作系统的内存管理机制以及 C 语言运行时库（如 glibc）的实现方式。</p>
<p>对于 「malloc 申请的内存，free 释放内存会归还给操作系统吗？」这个问题，我们可以做个总结：</p>
<ul>
<li>malloc 通过 <code>brk()</code> 方式申请的内存，free 释放内存的时候，并不会把内存归还给操作系统，而是缓存在 malloc 的内存池中，待下次使用；</li>
<li>malloc 通过 <code>mmap()</code> 方式申请的内存，free 释放内存的时候，会把内存归还给操作系统，内存得到真正的释放。</li>
</ul>
<blockquote>
<p>什么场景下 malloc() 会通过 brk() 分配内存？又是什么场景下通过 mmap() 分配内存？</p>
</blockquote>
<p>malloc() 源码里默认定义了一个阈值：</p>
<ul>
<li>如果用户分配的内存小于 128 KB，则通过 brk() 申请内存；</li>
<li>如果用户分配的内存大于 128 KB，则通过 mmap() 申请内存；</li>
</ul>
<p>注意，不同的 glibc 版本定义的阈值也是不同的。</p>
<h4 id="1-内存释放流程"><a href="#1-内存释放流程" class="headerlink" title="1. 内存释放流程"></a>1. 内存释放流程</h4><p>当你在 C/C++ 中使用 <code>free(ptr)</code> 释放一块内存时：</p>
<ul>
<li><strong>内存被标记为“空闲”</strong>，表示这块内存可以被后续的 <code>malloc</code> 或 <code>calloc</code> 重用。</li>
<li>但它<strong>通常不会立即归还给操作系统</strong>，而是由内存分配器（如 glibc 的 <code>ptmalloc</code>）保留在用户进程中，用于后续分配。</li>
</ul>
<h4 id="2-什么时候会真正返回给操作系统？"><a href="#2-什么时候会真正返回给操作系统？" class="headerlink" title="2. 什么时候会真正返回给操作系统？"></a>2. 什么时候会真正返回给操作系统？</h4><ul>
<li>如果释放的是<strong>堆顶的内存块</strong>（即堆的末端），且满足一定条件，glibc 可能会调用 <code>brk</code> 或 <code>mmap</code> 对应的释放机制（如 <code>munmap</code>）来将这部分内存返回给操作系统。</li>
<li>使用 <code>mmap</code> 分配的大块内存（通常大于一定阈值，比如 128KB），在被 <code>free</code> 时通常会直接使用 <code>munmap</code> 归还给操作系统。</li>
</ul>
<h4 id="3-glibc-的行为（以-Linux-为例）"><a href="#3-glibc-的行为（以-Linux-为例）" class="headerlink" title="3. glibc 的行为（以 Linux 为例）"></a>3. glibc 的行为（以 Linux 为例）</h4><p>glibc 的 <code>malloc</code> 有一套复杂的内存池机制，常见策略：</p>
<ul>
<li>小块内存来自内部的 <strong>arena</strong>，<code>free</code> 后不会归还操作系统，而是缓存起来以便重用。</li>
<li>大块内存通过 <code>mmap</code> 分配，<code>free</code> 后可能会立即调用 <code>munmap</code> 释放给系统。</li>
</ul>
<h4 id="4-查看内存是否释放"><a href="#4-查看内存是否释放" class="headerlink" title="4. 查看内存是否释放"></a>4. 查看内存是否释放</h4><p>可以使用工具如：</p>
<ul>
<li><code>top</code> 或 <code>htop</code> 查看内存使用趋势</li>
<li><code>valgrind</code> 检查内存泄漏</li>
<li><code>pmap</code> 查看进程的内存映射情况</li>
<li><code>mallinfo()</code>（旧）或 <code>malloc_info()</code>（新）来观察 glibc 的内存使用状况</li>
</ul>
<h3 id="🔥-malloc、realloc、calloc-的区别？"><a href="#🔥-malloc、realloc、calloc-的区别？" class="headerlink" title="🔥 malloc、realloc、calloc 的区别？"></a>🔥 malloc、realloc、calloc 的区别？</h3><p>1️⃣ <code>malloc</code> 函数</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span>* <span class="title">malloc</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> num_size)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> *p = <span class="built_in">malloc</span>(<span class="number">20</span>*<span class="built_in">sizeof</span>(<span class="type">int</span>)); <span class="comment">// 申请 20 个 int 类型的空间；</span></span><br></pre></td></tr></tbody></table></figure>

<p>2️⃣ <code>calloc</code> 函数：省去了人为空间计算；malloc 申请的空间的值是随机初始化的，calloc 申请的空间的值是初始化为 0 的；</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span>* <span class="title">calloc</span><span class="params">(<span class="type">size_t</span> n,<span class="type">size_t</span> size)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> *p = <span class="built_in">calloc</span>(<span class="number">20</span>, <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br></pre></td></tr></tbody></table></figure>

<p>3️⃣ <code>realloc</code> 函数：给动态分配的空间分配额外的空间，用于扩充容量。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">realloc</span><span class="params">(<span class="type">void</span> *p, <span class="type">size_t</span> new_size)</span></span>;</span><br></pre></td></tr></tbody></table></figure>

<h2 id="9-异常-错误处理有几种方法，为什么有些场合要禁用？"><a href="#9-异常-错误处理有几种方法，为什么有些场合要禁用？" class="headerlink" title="9. 异常/错误处理有几种方法，为什么有些场合要禁用？"></a>9. 异常/错误处理有几种方法，为什么有些场合要禁用？</h2><p>C++ 提供了多种错误处理机制，主要包括：</p>
<ul>
<li>返回码：函数通过返回值指示成功或失败，调用者需要检查返回值以确定操作结果。</li>
<li>错误码：使用全局或静态变量存储错误码，调用者需要在每个步骤后检查错误码。</li>
<li>异常处理：使用 <code>try</code>、<code>catch</code> 和 <code>throw</code> 关键字捕获和处理异常，提供结构化的错误处理方式。</li>
</ul>
<p>在某些场合，可能需要禁用异常处理，原因包括：</p>
<ul>
<li>性能要求高的场合：异常处理可能引入性能开销，影响程序的执行效率。</li>
<li>嵌入式系统：资源有限，可能不支持异常处理。</li>
<li>编译器不支持：某些编译器可能不支持异常处理。</li>
</ul>
<p>禁用异常处理可以通过编译器选项实现，例如在 Sun Studio 中使用 <code>-features=no%except</code> 来禁用异常处理。 </p>
<h2 id="10-C-相关的问题，什么是野指针，有哪些野指针？"><a href="#10-C-相关的问题，什么是野指针，有哪些野指针？" class="headerlink" title="10. C 相关的问题，什么是野指针，有哪些野指针？"></a>10. C 相关的问题，什么是野指针，有哪些野指针？</h2><p>野指针是指向「<strong>未初始化</strong>」或「<strong>已释放内存</strong>」的指针，使用野指针会导致未定义行为，常见野指针：</p>
<ul>
<li>未初始化的指针：指针声明后未被初始化，默认值不确定，可能指向任意内存地址</li>
<li>悬垂指针：指向已释放内存的指针，释放内存后未将指针置为 NULL，导致指针仍指向已回收的内存地址</li>
<li>空指针：指针被初始化为 NULL，但在后续使用前未被赋予有效地址，导致解引用时发生错误</li>
</ul>
<p>为避免野指针，应该在声明指针时进行初始化，并在释放内存后将指针置为 NULL。</p>
<p>在更多结构化的解决方案中，一种流行的避免悬垂指针的技术是使用<strong>智能指针</strong>，一个智能指针通常使用引用技术来收回对象。还有些技术包括 tombstones 方法和 locks-and-keys 方法。另一个方法是使用 Boehm 垃圾收集器，一种保守的垃圾收集器，取代 C 和 C++ 中的标准内存分配函数。此法通过禁止内存释放函数来完全消除悬垂指针引发的错误，通过收集垃圾来回收对象。</p>
<h2 id="11-你平常怎么调试代码，你能想到多少方法？"><a href="#11-你平常怎么调试代码，你能想到多少方法？" class="headerlink" title="11. 你平常怎么调试代码，你能想到多少方法？"></a>11. 你平常怎么调试代码，你能想到多少方法？</h2><p>调试代码是开发过程中非常重要的一部分，尤其是当出现问题时。调试的方式有很多种，下面是我能想到的常见调试方法：</p>
<h3 id="使用调试器-Debugger"><a href="#使用调试器-Debugger" class="headerlink" title="使用调试器 (Debugger)"></a>使用调试器 (Debugger)</h3><p>调试器是一种强大的工具，可以让你在程序运行时暂停执行，检查变量的值、调用堆栈等信息，逐行执行代码来找出错误。常见的调试器包括：</p>
<ul>
<li><strong>GDB (GNU Debugger)</strong>：适用于 C/C++ 等语言，通过命令行进行调试。</li>
<li><strong>Visual Studio Debugger</strong>：适用于 Windows 上的 C++ 和 .NET 程序。</li>
<li><strong>LLDB</strong>：用于 macOS 或 Linux 的调试器。</li>
<li><strong>Xcode Debugger</strong>：适用于 macOS 和 iOS 应用的调试器。</li>
</ul>
<p>使用调试器，你可以：</p>
<ul>
<li><strong>设置断点</strong>：暂停程序执行，以检查变量状态和函数调用。</li>
<li><strong>逐步执行代码</strong>：逐行执行，查看每一行代码的效果。</li>
<li><strong>检查栈信息和变量的值</strong>：实时查看变量的值、函数调用栈、内存内容等。</li>
</ul>
<p>例如，使用 GDB 调试 C++ 代码时，可以使用以下命令：</p>
<ul>
<li><code>gdb ./your_program</code> 启动调试器。</li>
<li><code>break main</code> 在 <code>main()</code> 函数处设置断点。</li>
<li><code>run</code> 启动程序执行。</li>
<li><code>step</code> 或 <code>next</code> 逐步执行代码。</li>
</ul>
<h3 id="插入日志输出-Logging"><a href="#插入日志输出-Logging" class="headerlink" title="插入日志输出 (Logging)"></a>插入日志输出 (Logging)</h3><p>在代码中添加日志输出是调试程序的常见方法。你可以在代码中插入 <code>printf</code>、<code>std::cout</code> 或日志库（如 <code>log4cpp</code>, <code>spdlog</code>, <code>glog</code> 等）来输出变量值、函数执行状态和程序流程。</p>
<p>常见做法包括：</p>
<ul>
<li>输出函数进入与退出的日志。</li>
<li>打印变量值、数据结构的内容。</li>
<li>打印程序的状态和执行的分支。</li>
</ul>
<p>例如：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::cout &lt;&lt; <span class="string">"Value of x: "</span> &lt;&lt; x &lt;&lt; std::endl;</span><br></pre></td></tr></tbody></table></figure>

<p>优点：</p>
<ul>
<li>非常直接和简单。</li>
<li>可以在生产环境中使用（例如在开发版和发布版中配置不同的日志级别）。</li>
</ul>
<p>缺点：</p>
<ul>
<li>可能会遗漏某些地方，导致调试信息不够全面。</li>
<li>需要在最终代码中删除或关闭冗余的日志输出。</li>
</ul>
<h3 id="单元测试-Unit-Testing"><a href="#单元测试-Unit-Testing" class="headerlink" title="单元测试 (Unit Testing)"></a>单元测试 (Unit Testing)</h3><p>单元测试是一种自动化的方式，可以帮助你验证代码的正确性。使用框架如 Google Test（C++）、JUnit（Java）、pytest（Python）等，可以编写测试用例，自动运行测试，并在代码发生变化时及时捕捉错误。</p>
<p>单元测试的优点：</p>
<ul>
<li>确保代码的每个模块都按预期工作。</li>
<li>能够提前发现潜在问题，特别是在修改代码时。</li>
</ul>
<p>缺点：</p>
<ul>
<li>测试用例需要编写和维护，可能需要额外的时间。</li>
<li>需要有较好的测试覆盖率，才能检测到更多的错误。</li>
</ul>
<h3 id="静态分析工具-Static-Analysis"><a href="#静态分析工具-Static-Analysis" class="headerlink" title="静态分析工具 (Static Analysis)"></a>静态分析工具 (Static Analysis)</h3><p>静态分析工具可以在代码运行之前，扫描代码并检查潜在的错误、内存泄漏、资源管理问题等。例如：</p>
<ul>
<li><strong>Clang Static Analyzer</strong></li>
<li><strong>CppCheck</strong></li>
<li><strong>SonarQube</strong></li>
<li><strong>Coverity</strong></li>
</ul>
<p>静态分析工具能够检测到：</p>
<ul>
<li>未初始化的变量。</li>
<li>内存泄漏。</li>
<li>潜在的并发问题。</li>
<li>错误的代码模式等。</li>
</ul>
<h3 id="代码审查-Code-Review"><a href="#代码审查-Code-Review" class="headerlink" title="代码审查 (Code Review)"></a>代码审查 (Code Review)</h3><p>代码审查是与团队成员或同事一起查看和讨论代码的过程。其他开发者可以帮助你发现代码中的潜在问题或逻辑错误。</p>
<p>代码审查的优点：</p>
<ul>
<li>多人的视角能够发现更多问题。</li>
<li>通过讨论，能够提升代码质量和团队合作。</li>
</ul>
<h3 id="集成测试-Integration-Testing"><a href="#集成测试-Integration-Testing" class="headerlink" title="集成测试 (Integration Testing)"></a>集成测试 (Integration Testing)</h3><p>集成测试是测试多个组件（或模块）一起工作时的行为。在多个模块组合工作时，问题可能不是单独模块内部，而是它们之间的交互。集成测试帮助你检查模块之间的接口和数据流。</p>
<p>集成测试通常用来发现：</p>
<ul>
<li>模块之间的兼容性问题。</li>
<li>数据格式错误。</li>
<li>不正确的模块交互等。</li>
</ul>
<h3 id="内存泄漏检测工具"><a href="#内存泄漏检测工具" class="headerlink" title="内存泄漏检测工具"></a>内存泄漏检测工具</h3><p>如果你的程序存在内存泄漏问题，可以使用专门的工具来检测内存的分配和释放：</p>
<ul>
<li>🔥 <strong>Valgrind</strong>：广泛用于检测内存泄漏、内存错误等问题，适用于 C/C++ 程序。</li>
<li><strong>AddressSanitizer</strong>：现代编译器（如 Clang、GCC）提供的工具，可以检测内存相关的错误，包括越界访问、内存泄漏等。</li>
</ul>
<p>这些工具帮助你找出内存泄漏和错误的内存访问问题，并给出详细的报告。</p>
<h3 id="运行时分析工具"><a href="#运行时分析工具" class="headerlink" title="运行时分析工具"></a>运行时分析工具</h3><p>运行时分析工具通过收集程序运行时的信息来进行调试和优化。例如：</p>
<ul>
<li><strong>gprof</strong>：用于性能分析，查看程序中哪些函数占用了最多的时间。</li>
<li><strong>perf</strong>：Linux 下的性能分析工具，帮助查看程序在系统层面的性能瓶颈。</li>
<li><strong>VisualVM</strong>：Java 应用程序的性能分析工具，能够分析内存、CPU 和线程使用情况。</li>
</ul>
<h3 id="条件断点和日志断点"><a href="#条件断点和日志断点" class="headerlink" title="条件断点和日志断点"></a>条件断点和日志断点</h3><p>在调试过程中，有时你希望仅在满足特定条件时暂停程序。这时可以使用<strong>条件断点</strong>或<strong>日志断点</strong>：</p>
<ul>
<li><strong>条件断点</strong>：只有当某个条件成立时，调试器才会停止程序执行。</li>
<li><strong>日志断点</strong>：调试器在不停止程序执行的情况下，记录断点信息。</li>
</ul>
<h3 id="回滚与分支-Git-Bisect"><a href="#回滚与分支-Git-Bisect" class="headerlink" title="回滚与分支 (Git Bisect)"></a>回滚与分支 (Git Bisect)</h3><p>如果你无法确定错误是在哪次提交中引入的，使用 Git 提供的 <code>git bisect</code> 命令来回滚到历史提交并逐步测试，可以帮助定位问题的来源。</p>
<p>通过二分查找算法，<code>git bisect</code> 可以帮助你快速定位到错误引入的那一行代码。</p>
<h3 id="故障注入-Fault-Injection"><a href="#故障注入-Fault-Injection" class="headerlink" title="故障注入 (Fault Injection)"></a>故障注入 (Fault Injection)</h3><p>故障注入是故意在程序中引入故障，以测试程序在面对错误时的反应。例如，可以通过随机生成异常、模拟网络延迟或中断等方式，检查系统的健壮性和错误处理能力。</p>
<h3 id="动态分析与跟踪-Dynamic-Analysis"><a href="#动态分析与跟踪-Dynamic-Analysis" class="headerlink" title="动态分析与跟踪 (Dynamic Analysis)"></a>动态分析与跟踪 (Dynamic Analysis)</h3><p>使用跟踪工具（如 <code>strace</code>, <code>ltrace</code>, <code>dtrace</code> 等）来实时观察程序执行过程中的系统调用和函数调用。这种方式帮助你了解程序在运行时的行为，找出性能瓶颈或其他问题。</p>
<h2 id="12-什么是-C-多态？"><a href="#12-什么是-C-多态？" class="headerlink" title="12. 什么是 C++ 多态？"></a>12. 什么是 C++ 多态？</h2><p>C++ 多态即使用基类指针或引用来调用子类的重写方法，从而使得同一接口表现不同的行为。</p>
<p>多态优势：</p>
<ul>
<li>代码复用：通过基类指针或引用，可以操作不同类型的派生类对象，实现代码复用</li>
<li>扩展性：新增派生类时，不需要修改依赖于基类的代码，只需要确保新类正确重写了虚函数</li>
<li>解耦：多态允许程序更加模块化，降低类之间的耦合度</li>
</ul>
<blockquote>
<p>🔥 面试一定要回答「静态多态」+「动态多态」</p>
</blockquote>
<p>多态一般就是指<strong>继承 + 虚函数实现的多态</strong>，对于重载来说，实际原理是编译器为函数生成符号表时的不同规则，重载只是一种语言特性，与多态无关，与面向对象无关，所以如果非要说重载算是多态的一种，那 C++ 中多态可以分为「静态多态」和「动态多态」两种：</p>
<ul>
<li>静态多态：在编译时期就决定了调用哪个函数，根据参数列表来决定，主要通过<strong>函数重载</strong>和<strong>模板</strong>实现</li>
<li>动态多态：通过子类重写父类的虚函数来实现，是运行期间决定调用的函数</li>
</ul>
<p><strong>动态多态的实现与虚函数表（V-Table），虚函数指针（V-Ptr）相关</strong>：</p>
<ul>
<li>虚函数表（V-Table）：C++ 运行时使用虚函数表来实现多态，每个包含虚函数的类都有一个虚函数表，表中存储了指向类中所有虚函数的指针。</li>
<li>虚函数指针（V-Ptr）：对象中包含一个指向该类虚函数表的指针。</li>
</ul>
<p><strong>扩展</strong>：子类是否要重写父类的虚函数？子类继承父类时，父类的纯虚函数必须重写，否则子类也是一个虚类不可实例化。定义纯虚函数是为了实现一个接口，起到一个规范的作用，规范继承这个类的程序员必须实现这个函数。</p>
<h2 id="13-什么是虚函数与虚函数指针，C-虚函数的实现原理？"><a href="#13-什么是虚函数与虚函数指针，C-虚函数的实现原理？" class="headerlink" title="13. 什么是虚函数与虚函数指针，C++ 虚函数的实现原理？"></a>13. 什么是虚函数与虚函数指针，C++ 虚函数的实现原理？</h2><p>首先说一下 C++ 中多态的表象：在基类的函数前加上 <code>virtual</code> 关键字，在派生类中重写该函数，运行时将会根据对象的实际类型来调用相应的函数：</p>
<ul>
<li>如果对象类型是派生类，就调用派生类的函数</li>
<li>如果是基类，就调用基类的函数</li>
</ul>
<h3 id="虚函数-vtable-与虚函数指针-vptr"><a href="#虚函数-vtable-与虚函数指针-vptr" class="headerlink" title="虚函数 vtable 与虚函数指针 vptr"></a>虚函数 <code>vtable</code> 与虚函数指针 <code>vptr</code></h3><p>实际上，当一个类中包含虚函数 <code>virtual</code> 时，编译器就会为该类生成一个虚函数表 <code>vtable</code>，保存该类中虚函数的地址。同样，派生类继承基类，派生类中自然一定有虚函数，所以编译器也会为派生类生成自己的虚函数表 <code>vtable</code>。当我们定义一个派生类对象时，编译器检测到该类型有虚函数，就会为这个派生类对象生成一个虚函数指针 <code>vptr</code>，指向该类型的虚函数表 <code>vtable</code>，<strong>虚函数指针 <code>vptr</code> 的初始化是在构造函数中完成的</strong>。后续如果有一个基类类型的指针指向派生类，那么当调用虚函数时，就会根据所指真正对象的虚函数表指针 <code>vptr</code> 去寻找虚函数的地址，也就可以调用派生类的虚函数表中虚函数以此实现多态。</p>
<p><strong>补充</strong>：如果基类中没有定义成 <code>virtual</code>（只有继承），那么在这种情况调用的则是 <code>Base</code> 中的 <code>func()</code>。<strong>因为如果基类和派生类中都没有虚函数 <code>virtual</code> 的定义，那么编译器就会认为不用留给动态多态的机会</strong>，就事先进行函数地址的绑定（早绑定 —— 静态绑定），具体过程：</p>
<ul>
<li>定义了派生类对象，首先构造基类的空间，然后构造派生类的自身内容，形成一个派生类对象</li>
<li>进行类型转换时，直接截取基类的部分内存，编译器认为类型就是基类，那么函数符号表（不同于虚函数表）绑定的函数地址也就是基类中的函数地址，执行的就是基类函数</li>
</ul>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 🌟只有 virtual 存在，编译器才会认为存在「多态」</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// virtual 不存在则只调用 ~Base()</span></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Base</span>() { <span class="comment">// 虚析构函数</span></span><br><span class="line">        <span class="comment">// 释放 Base 的资源</span></span><br><span class="line">        cout &lt;&lt; <span class="string">"释放 Base 的资源"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// virtual 不存在则只调用 Base func()</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"Base_func()"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// override 可加可不加，有助于编译器检查</span></span><br><span class="line">    ~<span class="built_in">Derived</span>() <span class="keyword">override</span> {</span><br><span class="line">        <span class="comment">// 释放 Derived 的资源</span></span><br><span class="line">        cout &lt;&lt; <span class="string">"释放 Derived 的资源"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// override 可加可不加，有助于编译器检查</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> <span class="keyword">override</span> </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"Derived_func()"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    Base* ptr = <span class="keyword">new</span> Derived;</span><br><span class="line">    ptr-&gt;<span class="built_in">func</span>();</span><br><span class="line">    <span class="keyword">delete</span> ptr;  <span class="comment">// 调用时，先执行 Derived::~Derived()，再执行 Base::~Base()</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Derived_func()</span><br><span class="line">释放 Derived 的资源</span><br><span class="line">释放 Base 的资源</span><br></pre></td></tr></tbody></table></figure>

<h3 id="C-虚函数的内存分布-实现原理"><a href="#C-虚函数的内存分布-实现原理" class="headerlink" title="C++ 虚函数的内存分布 &amp; 实现原理"></a>C++ 虚函数的内存分布 &amp; 实现原理</h3><blockquote>
<p>以上简要介绍了「虚函数」相关内容（简要介绍了原理），接下来详细阐述实现原理</p>
<p>更多信息：<a target="_blank" rel="noopener" href="https://jacktang816.github.io/post/virtualfunction/">C++ 虚函数的实现基本原理</a></p>
</blockquote>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> {</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">v_a</span><span class="params">()</span></span>{}</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">A</span>(){}</span><br><span class="line">    <span class="type">int64_t</span> _m_a;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    A* a = <span class="keyword">new</span> <span class="built_in">A</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>如以上代码所示，在 C++ 中定义一个对象 A，那么在内存中的分布大概是如下图这个样子。</p>
<ul>
<li>首先在主函数的栈帧上有一个 A 类型的指针指向堆里面分配好的对象 A 实例。</li>
<li>对象 A 实例的<strong>头部</strong>是一个 <code>vtable</code> 指针，紧接着是 <strong>A 对象按照声明顺序排列的成员变量</strong>（当我们创建一个对象时，便可以通过实例对象的地址，得到该实例的虚函数表，从而获取其函数指针）</li>
<li><code>vptr</code> 指针指向的是代码段中的 A 类型的<strong>虚函数表中的第一个虚函数起始地址</strong>。</li>
<li>虚函数表 <code>vtable</code> 的结构其实是有一个头部的，叫做 <code>vtable_prefix</code> ，紧接着是按照声明顺序排列的虚函数。</li>
<li>注意到这里有两个虚析构函数，因为对象有两种构造方式，<strong>栈构造</strong>和<strong>堆构造</strong>，所以对应的，对象会有两种析构方式，其中堆上对象的析构和栈上对象的析构不同之处在于，栈内存的析构不需要执行 <code>delete</code> 函数，会自动被回收。</li>
<li><code>typeinfo</code> 存储着 A 的类基础信息，包括父类与类名称，C++关键字 <code>typeid</code> 返回的就是这个对象。</li>
<li><code>typeinfo</code> 也是一个类，对于没有父类的 A 来说，当前 tinfo 是 <code>class_type_info</code> 类型的，从虚函数指针指向的 vtable 起始位置可以看出。</li>
</ul>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/Wu-yikun/OSS/PicGo/202503021850782.png" alt="img"></p>
<hr>
<p>1️⃣ <code>Example-1</code>｜如果是多继承情况下，编译器如下处理虚函数表｜<strong>虚函数的实现原理</strong></p>
<ul>
<li>拷贝基类的虚函数表，多继承则拷贝每个虚函数基类的虚函数表</li>
<li>多继承会存在一个基类虚函数表和派生类自身虚函数表合并共用，该基类称为派生类的主基类</li>
<li>派生类重写基类虚函数，则替换重写后的虚函数地址</li>
<li>如果有自身虚函数，则追加自身虚函数到自身的虚函数表</li>
</ul>
<blockquote>
<p>其中 D 对象 <code>vptr1</code> 指向的虚函数表合并了「某个基类虚函数表」和「派生类自身虚函数表」，<code>vptr2</code> 则指向另一个基类的虚函数表</p>
</blockquote>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/Wu-yikun/OSS/PicGo/202503021812761.png" alt="image-20250302181234528"></p>
<p>2️⃣ <code>Example-2</code></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>{</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">uint64_t</span> a;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">A_a</span><span class="params">()</span></span>{std::cout &lt;&lt; __func__;}</span><br><span class="line">};</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>{</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">uint64_t</span> c;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">C_a</span><span class="params">()</span></span>{std::cout &lt;&lt; __func__;}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> : <span class="keyword">public</span> A,<span class="keyword">public</span> C{</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">uint64_t</span> d;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">D_a</span><span class="params">()</span></span>{std::cout &lt;&lt; __func__;}</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>class D 的虚函数表</p>
</blockquote>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/Wu-yikun/OSS/PicGo/202503021849625.jpeg"></p>
<h2 id="14-析构函数可以是虚函数吗？什么情况下析构函数必须是虚函数？"><a href="#14-析构函数可以是虚函数吗？什么情况下析构函数必须是虚函数？" class="headerlink" title="14. 析构函数可以是虚函数吗？什么情况下析构函数必须是虚函数？"></a>14. 析构函数可以是虚函数吗？什么情况下析构函数必须是虚函数？</h2><blockquote>
<p>🪞镜像问题：</p>
<ul>
<li><strong>为什么需要虚析构？虚析构实现原理？</strong></li>
<li><strong>析构函数一般写成虚函数的原因？</strong></li>
</ul>
</blockquote>
<p>析构函数可以是虚函数。将析构函数声明为 <code>virtual</code> 虚函数，确保在删除基类指针指向的派生类对象时，能够正确调用派生类的析构函数，<strong>避免内存泄漏</strong>。</p>
<p>举例来说，一个基类的指针指向一个派生类的对象，在使用完毕准备销毁时，如果基类的析构函数没有定义成 <code>virtual</code> 虚函数，那么编译器根据指针类型就会认为当前对象类型是基类，仅调用基类的析构函数（该对象的析构函数的函数地址早就被绑定为基类的析构函数——静态绑定 / 早绑定），派生类的自身内容将无法被析构，造成内存泄漏。如果基类的析构函数定义为虚函数，那么编译器就可以根据实际对象，执行派生类的析构函数，再执行基类的析构函数，成功释放内存。</p>
<blockquote>
<p>注释助于理解</p>
</blockquote>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 🌟只有 virtual 存在，编译器才会认为存在「多态」</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// virtual 不存在则只调用 ~Base()</span></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Base</span>() { <span class="comment">// 虚析构函数</span></span><br><span class="line">        <span class="comment">// 释放 Base 的资源</span></span><br><span class="line">        cout &lt;&lt; <span class="string">"释放 Base 的资源"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// virtual 不存在则只调用 Base func()</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"Base_func()"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">Derived</span>() {</span><br><span class="line">        <span class="comment">// 释放 Derived 的资源</span></span><br><span class="line">        cout &lt;&lt; <span class="string">"释放 Derived 的资源"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"Derived_func()"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    Base* ptr = <span class="keyword">new</span> Derived;</span><br><span class="line">    ptr-&gt;<span class="built_in">func</span>();</span><br><span class="line">    <span class="keyword">delete</span> ptr;  <span class="comment">// 调用时，先执行 Derived::~Derived()，再执行 Base::~Base()</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Derived_func()        <span class="comment">// func() 没定义 virtual 则输出 Base_func()</span></span><br><span class="line">释放 Derived 的资源     <span class="comment">// ~Base() 没定义 virtual 则不输出</span></span><br><span class="line">释放 Base 的资源</span><br></pre></td></tr></tbody></table></figure>

<p>⚠️ <strong>C++ 默认的析构函数不是虚函数，是因为虚函数需要额外的虚函数表和虚表指针，占用额外的内存</strong>。</p>
<p><strong>当类被设计为「基类」，并且可能被继承时，析构函数应当声明为虚函数</strong>。如果类不会被继承，则析构函数可以不声明为虚函数。然而，为了代码的健壮性和可维护性，<strong>通常建议将基类的析构函数声明为虚函数</strong>，即使该类当前不会被继承。</p>
<h2 id="15-构造函数为什么一般不定义为虚函数"><a href="#15-构造函数为什么一般不定义为虚函数" class="headerlink" title="15. 构造函数为什么一般不定义为虚函数"></a>15. 构造函数为什么一般不定义为虚函数</h2><p>1️⃣ 虚函数调用只需要知道“部分信息”，即只需要知道函数接口，而不需要知道对象的具体类型。但是创建对象时，是需要知道对象的完整信息，特别是需要知道创建对象的确切类型，因此构造函数不应该被定义为虚函数。</p>
<p>2️⃣ 从编译器实现虚函数进行多态的方式来看，虚函数调用时通过实例化之后对象的虚函数表指针 <code>vptr</code> 来找到虚函数地址进行调用的，如果说构造函数是虚的，那么虚函数表指针则不存在（<strong>因为虚函数指针 <code>vptr</code> 的初始化是在构造函数中完成的</strong>），无法找到对应的虚函数表 <code>vtable</code> 来调用虚函数，<strong>那么这个调用实际上也是违反了先实例化后调用的准则</strong>。</p>
<h2 id="16-构造函数的执行顺序？析构函数的执行顺序？"><a href="#16-构造函数的执行顺序？析构函数的执行顺序？" class="headerlink" title="16. 构造函数的执行顺序？析构函数的执行顺序？"></a>16. 构造函数的执行顺序？析构函数的执行顺序？</h2><h3 id="1️⃣-构造函数顺序"><a href="#1️⃣-构造函数顺序" class="headerlink" title="1️⃣ 构造函数顺序"></a>1️⃣ 构造函数顺序</h3><ul>
<li>基类构造函数：如果有多个基类，则构造函数调用顺序是某类在「类派生列表」中出现的顺序，而不是它们在成员初始化表中的顺序</li>
<li>成员类对象构造函数：如果有多个成员类对象，则构造函数的调用顺序是对象在类中被声明的顺序，而不是它们出现在成员初始化表中的顺序</li>
<li>派生类构造函数</li>
</ul>
<blockquote>
<p>类派生列表</p>
</blockquote>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> 派生类名:类派生列表 {</span><br><span class="line">    成员列表</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base1, <span class="keyword">public</span> Base2 {</span><br><span class="line">    成员列表</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="2️⃣-析构函数顺序"><a href="#2️⃣-析构函数顺序" class="headerlink" title="2️⃣ 析构函数顺序"></a>2️⃣ 析构函数顺序</h3><ul>
<li>调用派生类的析构函数</li>
<li>调用成员类对象的析构函数</li>
<li>调用基类的析构函数</li>
</ul>
<h2 id="17-静态绑定和动态绑定"><a href="#17-静态绑定和动态绑定" class="headerlink" title="17. 静态绑定和动态绑定"></a>17. 静态绑定和动态绑定</h2><p>我们首先要知道静态类型和动态类型：</p>
<ul>
<li>静态类型：在程序中被声明时所采用的类型，<strong>在编译期间确定</strong></li>
<li>动态类型：目前所指对象的实际类型，<strong>在运行期间确定</strong></li>
</ul>
<p>关于静态绑定和动态绑定：</p>
<ul>
<li>静态绑定，又称早绑定，绑定的是静态类型，所对应的函数或属性依赖于对象的静态类型，发生在编译期间。</li>
<li>动态绑定，又称晚绑定，绑定的是动态类型，所对应的函数或属性依赖于动态类型，发生在运行期间。</li>
</ul>
<p>比如说，<code>virtual</code> 函数是动态绑定的，非虚函数是静态绑定的，缺省参数值也是静态绑定的。</p>
<p>⚠️ 注意，我们不应该重新定义继承而来的缺省参数，因为即使我们重定义了，也不会起到效果。因为一个基类的指针指向一个派生类对象，在派生类的对象中针对虚函数的参数缺省值进行了重定义， 但是缺省参数值是静态绑定的，静态绑定绑定的是静态类型相关的内容。</p>
<h2 id="18-纯虚函数"><a href="#18-纯虚函数" class="headerlink" title="18. 纯虚函数"></a>18. 纯虚函数</h2><p>纯虚函数是在基类中「声明但不实现」的虚函数，其声明方式是在函数声明的结尾处添加 <code>= 0</code>，类中如果至少包含一个纯虚函数，则该类称为抽象类，<strong>抽象类是不能实例化对象的</strong>。</p>
<p>纯虚函数的主要作用是定义接口规范，强制要求派生类必须实现这些函数，从而实现借口的统一和标准化。派生类中必须实现继承于基类的纯虚函数，否则含有纯虚函数的类又会是抽象类，无法实例化。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">()</span> </span>= <span class="number">0</span>; <span class="comment">// 纯虚函数</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> : <span class="keyword">public</span> Shape {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 必须实现，否则该派生类为抽象类，不能实例化</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="keyword">override</span> </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"Drawing a circle"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    Shape* shape = <span class="keyword">new</span> <span class="built_in">Circle</span>();</span><br><span class="line">    shape-&gt;<span class="built_in">draw</span>(); <span class="comment">// 输出：Drawing a circle</span></span><br><span class="line">    <span class="keyword">delete</span> shape;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="19-深拷贝和浅拷贝的区别（举例说明深拷贝的安全性）"><a href="#19-深拷贝和浅拷贝的区别（举例说明深拷贝的安全性）" class="headerlink" title="19. 深拷贝和浅拷贝的区别（举例说明深拷贝的安全性）"></a>19. 深拷贝和浅拷贝的区别（举例说明深拷贝的安全性）</h2><p>1️⃣ <strong>浅拷贝</strong>：</p>
<ul>
<li>当出现类的等号 <code>=</code> 赋值时，会调用拷贝构造函数，在未显式定义拷贝构造函数的情况下，系统会调用默认的拷贝函数 —— 即浅拷贝，它能够完成成员的复制，当数据成员中没有指针时，浅拷贝是可行的；</li>
<li>但当数据成员中有<strong>指针</strong>时，如果采用简单的浅拷贝，则两个类中的两个指针指向同一个地址，当对象快要结束时，<strong>会调用两次析构函数，从而导致野指针的问题</strong>。</li>
</ul>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ShallowCopy</span> {</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span>* data;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ShallowCopy</span>(<span class="type">int</span> d) : <span class="built_in">data</span>(<span class="keyword">new</span> <span class="built_in">int</span>(d)) {}</span><br><span class="line">    <span class="comment">// 而且在对象结束时，会调用两次析构函数，从而导致野指针问题</span></span><br><span class="line">    ~<span class="built_in">ShallowCopy</span>() { <span class="keyword">delete</span> data; }</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setData</span><span class="params">(<span class="type">int</span> d)</span> </span>{ *data = d; }</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getData</span><span class="params">()</span> <span class="type">const</span> </span>{ <span class="keyword">return</span> *data; }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认拷贝构造函数（浅拷贝）</span></span><br><span class="line">    <span class="built_in">ShallowCopy</span>(<span class="type">const</span> ShallowCopy&amp; source) : <span class="built_in">data</span>(source.data) {}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">ShallowCopy <span class="title">obj1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    ShallowCopy obj2 = obj1; <span class="comment">// 使用默认拷贝构造函数</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">"obj1 data: "</span> &lt;&lt; obj<span class="number">1.</span><span class="built_in">getData</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"obj2 data: "</span> &lt;&lt; obj<span class="number">2.</span><span class="built_in">getData</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    obj<span class="number">1.</span><span class="built_in">setData</span>(<span class="number">20</span>); <span class="comment">// 修改 obj1 的数据</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">"After modifying obj1"</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"obj1 data: "</span> &lt;&lt; obj<span class="number">1.</span><span class="built_in">getData</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"obj2 data: "</span> &lt;&lt; obj<span class="number">2.</span><span class="built_in">getData</span>() &lt;&lt; endl; <span class="comment">// obj2 数据也被修改了</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>2️⃣ <strong>深拷贝</strong>：在数据成员含有指针时，必须采用深拷贝（自定义拷贝构造函数），在拷贝构造函数中创建一个全新对象，与原对象完全独立。深拷⻉与浅拷⻉之间的区别就在于，<strong>深拷⻉会在堆内存中另外申请空间来存储数据</strong>，从而解决来野指针的问题。简而言之，当数据成员中有指针时，必需要用深拷⻉更加安全。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DeepCopy</span> {</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> *data;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">DeepCopy</span>(<span class="type">int</span> d) : <span class="built_in">data</span>(<span class="keyword">new</span> <span class="built_in">int</span>(d)) {}</span><br><span class="line">    ~<span class="built_in">DeepCopy</span>() { <span class="keyword">delete</span> data; }</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setData</span><span class="params">(<span class="type">int</span> d)</span> </span>{ *data = d; }</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getData</span><span class="params">()</span> <span class="type">const</span> </span>{ <span class="keyword">return</span> *data; }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自定义拷贝构造函数（深拷贝）</span></span><br><span class="line">    <span class="built_in">DeepCopy</span>(<span class="type">const</span> DeepCopy &amp;source) : <span class="built_in">data</span>(<span class="keyword">new</span> <span class="built_in">int</span>(*source.data)) {}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">DeepCopy <span class="title">obj1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    DeepCopy obj2 = obj1; <span class="comment">// 使用自定义拷贝构造函数</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">"obj1 data: "</span> &lt;&lt; obj<span class="number">1.</span><span class="built_in">getData</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"obj2 data: "</span> &lt;&lt; obj<span class="number">2.</span><span class="built_in">getData</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    obj<span class="number">1.</span><span class="built_in">setData</span>(<span class="number">20</span>); <span class="comment">// 修改 obj1 的数据</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">"After modifying obj1"</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"obj1 data: "</span> &lt;&lt; obj<span class="number">1.</span><span class="built_in">getData</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"obj2 data: "</span> &lt;&lt; obj<span class="number">2.</span><span class="built_in">getData</span>() &lt;&lt; endl; <span class="comment">// obj2 数据没有变化</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="20-说一下你理解的-C-四种智能指针｜shared-ptr-的简易实现"><a href="#20-说一下你理解的-C-四种智能指针｜shared-ptr-的简易实现" class="headerlink" title="20. 说一下你理解的 C++ 四种智能指针｜shared_ptr 的简易实现"></a>20. 说一下你理解的 C++ 四种智能指针｜shared_ptr 的简易实现</h2><blockquote>
<p>更多信息：<a target="_blank" rel="noopener" href="https://jacktang816.github.io/post/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/">C++ 智能指针</a>、<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/137958974">知乎 C++ 智能指针</a></p>
<p>看这两篇，取取交集</p>
</blockquote>
<p>在使用 C++ 开发过程中，最容易也是最麻烦的问题便是内存泄漏。相较于 Java、Python 或者 Go 语言都拥有垃圾回收机制，在对象没有引用时就会被系统自动回收而且基本上没有指针的概念，但是 C++ 则要求程序员自己管理内存，这一方面让程序员有更大的自由度但是也会很大影响程序员的开发效率。因此 C++11 标准中新推出了 <code>shared_ptr</code>、<code>unique_ptr</code> 和 <code>weak_ptr</code> 三个智能指针来帮助管理内存。</p>
<p>智能指针就是一个类，当超出了类的作用域时，类会自动调用析构函数，析构函数会自动释放资源，所以智能指针的作用原理就是在函数结束时自动释放内存空间，不需要手动释放。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">T* <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line">T&amp; <span class="keyword">operator</span>*();</span><br><span class="line">T* <span class="keyword">operator</span>-&gt;();</span><br><span class="line">T&amp; <span class="keyword">operator</span>=(<span class="type">const</span> T&amp; val);</span><br><span class="line"><span class="function">T* <span class="title">release</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reset</span> <span class="params">(T* ptr = <span class="literal">nullptr</span>)</span></span>;</span><br></pre></td></tr></tbody></table></figure>

<p>常用接口：</p>
<ul>
<li><code>T</code> 是模板参数，即传入的类型</li>
<li><code>get()</code> 用来获取 <code>auto_ptr</code> 封装在内部的指针，也就是获取原生指针</li>
<li><code>operator*()</code> 重载 <code>*</code>，<code>operator-&gt;()</code> 重载 <code>-&gt;</code>，<code>operator=()</code> 重载 <code>=</code></li>
<li><code>release()</code> 将 <code>auto_ptr</code> 封装在内部的指针置为 <code>nullptr</code>，但不会破坏指针所指向的内容，函数返回的是内部指针置空之前的值</li>
<li><code>reset()</code> 直接释放封装的内部指针所指向的内存，如果指定了 <code>ptr</code> 的值，则将内部指针初始化为该值</li>
</ul>
<p>接下来说说哪四种智能指针：</p>
<ul>
<li><code>auto_ptr</code> 为 C++98 的方案，C++11 已抛弃</li>
<li>C++11 引入<ol>
<li><code>std::shared_ptr</code></li>
<li><code>std::weak_ptr</code></li>
<li><code>std::unique_ptr</code></li>
</ol>
</li>
</ul>
<h3 id="0️⃣-auto-ptr"><a href="#0️⃣-auto-ptr" class="headerlink" title="0️⃣ auto_ptr"></a>0️⃣ auto_ptr</h3><blockquote>
<p>C++98 方案，C++11 已抛弃</p>
</blockquote>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">auto_ptr&lt;std::string&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> string(<span class="string">"string"</span>))</span></span>;</span><br><span class="line">auto_ptr&lt;std::string&gt; p2;</span><br><span class="line">p2 = p1;    <span class="comment">// auto_ptr 不会报错</span></span><br></pre></td></tr></tbody></table></figure>

<p>p2 剥夺了 p1 的所有权，但是当程序运行时访问 p1 将会报错，所以 <code>auto_ptr</code> 缺点就是存在潜在的内存崩溃问题。</p>
<h3 id="1️⃣-shared-ptr-共享式智能指针"><a href="#1️⃣-shared-ptr-共享式智能指针" class="headerlink" title="1️⃣ shared_ptr 共享式智能指针"></a>1️⃣ shared_ptr 共享式智能指针</h3><blockquote>
<p>彻底理解：<code>shared_ptr</code> 是<strong>有两层析构</strong>：</p>
<ul>
<li>shared_ptr 本身析构会使得指向的共享对象的引用数 -1，当共享对象引用数为 0 时，则调用共享对象本身的析构函数</li>
<li>这样就可以理解循环引用了：共享对象引用还是 1，未调用共享对象本身的析构函数，其中成员 shared_ptr 的析构函数也不会被调用</li>
</ul>
</blockquote>
<p><code>shared_ptr</code> 能够自动记录共享对象的引用次数，并且在引用计数降至零时自动删除对象，从而防止内存泄漏。每个 <code>shared_ptr</code> 的拷贝都指向相同的内存，在最后一个 <code>shared_ptr</code> 析构的时候其指向的内存资源才会被释放。</p>
<p><code>shared_ptr</code> 初始化方式：</p>
<ol>
<li>构造函数</li>
<li><code>std::make_shared()</code> 辅助函数</li>
<li><code>reset()</code></li>
</ol>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">1</span>))</span></span>;</span><br><span class="line">std::shared_ptr&lt;<span class="type">int</span>&gt; p2 = p;</span><br><span class="line">std::shared_ptr&lt;A&gt; ap = std::<span class="built_in">make_shared</span>&lt;A&gt;();</span><br><span class="line"></span><br><span class="line">std::shared_ptr&lt;<span class="type">int</span>&gt; ptr;</span><br><span class="line">ptr.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">1</span>));</span><br></pre></td></tr></tbody></table></figure>

<p><strong>不能将一个原始指针直接赋值给一个智能指针</strong>，如：<code>std::shared_ptr&lt;int&gt; p = new int(1)</code>。</p>
<p>对于一个未初始化的智能指针，可以通过调用 <code>reset</code> 方法初始化，当智能指针中有值的时候，调用 <code>reset</code> 方法会使引用计数减 1。当需要获取原指针的时候可以通过 <code>get</code> 方法返回原始指针：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">1</span>))</span></span>;</span><br><span class="line"><span class="type">int</span> *ptr = p.<span class="built_in">get</span>();</span><br></pre></td></tr></tbody></table></figure>

<p>智能指针初始化时也可以指定删除器，当其引用计数为 0 时将自动调用删除器来释放对象，删除器可以是一个函数对象。<strong>如当使用 <code>shared_ptr</code> 管理动态数组时，需要指定删除器，因为 <code>shared_ptr</code> 默认删除器不支持数组对象</strong>：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lambda 表达式作为删除器</span></span><br><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>], [](<span class="type">int</span> *p) { <span class="keyword">delete</span> []p; })</span></span></span><br></pre></td></tr></tbody></table></figure>

<p>关于 <code>shared_ptr</code> 的注意事项：</p>
<ul>
<li><strong>不要用一个裸指针初始化多个 <code>shared_ptr</code></strong>，会出现 <em><strong>double_free</strong></em> 导致程序崩溃</li>
<li>通过 <code>shared_from_this()</code> 返回 this 指针，不要把 this 指针作为 <code>shared_ptr</code> 返回出来，因为 <code>this</code> 指针本质就是裸指针，通过 this 返回可能会导致重复析构，<strong>不能把 this 指针交给智能指针管理</strong>。</li>
</ul>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> {</span><br><span class="line">      <span class="function">shared_ptr&lt;A&gt; <span class="title">GetSelf</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">shared_from_this</span>();</span><br><span class="line">          <span class="comment">// return shared_ptr&lt;A&gt;(this); 错误，会导致 double free</span></span><br><span class="line">    }  </span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>尽量使用 <code>std::make_shared&lt;T&gt;()</code>，少用 <code>new</code></li>
<li><strong>不要 <code>delete</code> <code>get()</code> 返回的裸指针</strong></li>
<li><strong>不是 <code>new</code> 出来的空间要自定义删除器</strong></li>
<li><strong>要避免循环引用</strong>，循环引用导致内存永远不会被释放，造成内存泄漏</li>
</ul>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::shared_ptr&lt;B&gt; b;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::shared_ptr&lt;A&gt; a;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    std::shared_ptr&lt;A&gt; ap = std::<span class="built_in">make_shared</span>&lt;A&gt;();</span><br><span class="line">    std::shared_ptr&lt;B&gt; bp = std::<span class="built_in">make_shared</span>&lt;B&gt;();</span><br><span class="line">    ap-&gt;b = bp;</span><br><span class="line">    bp-&gt;a = ap;</span><br><span class="line">    <span class="comment">// 此时，a 和 b 相互持有对方的 shared_ptr，形成循环引用</span></span><br><span class="line">    <span class="comment">// 程序结束时，a 和 b 的引用计数都不会降为零，导致内存泄漏</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>🌟 <strong>解释说明循环引用</strong>：</p>
<ul>
<li>首先循环引用导致 shared_ptr 指向的共享对象 A 和 B 的引用计数都是 2；</li>
<li>在离开作用域后，根据栈后进先出的特点，首先 <code>shared_ptr&lt;B&gt; bp</code> 析构时只减少 B 的引用次数为 1（这里是对象 shared_ptr 析构而非对象 B 析构），由于此时对象 B 的引用次数仍为 1（减为 0 的 B 才会被释放），所以不会调用（对象 B）内部智能指针 <code>a</code> 的析构函数来减少引用，所以也就无法减少 A 的引用次数了。</li>
<li>接着 <code>ap</code> 析构时减少 A 的引用次数为 1，此时 A 的引用仍为 1 不会被析构，所以无法析构其成员对象 <code>b</code>；</li>
<li>最终导致指针永远不会析构，产生了内存泄漏（解决方案就是使用 <code>weak_ptr</code>）</li>
</ul>
<h3 id="2️⃣-weak-ptr-弱引用智能指针"><a href="#2️⃣-weak-ptr-弱引用智能指针" class="headerlink" title="2️⃣ weak_ptr 弱引用智能指针"></a>2️⃣ weak_ptr 弱引用智能指针</h3><p><code>weak_ptr</code> 是一种不控制对象生命周期的智能指针，它指向一个 shared_ptr 管理的对象，它不管理 <code>shared_ptr</code> 内部指针，进行该对象的内存管理的是那个强引用的 shared_ptr。</p>
<p>weak_ptr 只是提供了对管理对象的一个访问手段。weak_ptr 设计的目的是为配合 shared_ptr 而引入的一种智能指针来协助 shared_ptr 工作，纯粹是作为一个旁观者监视 <code>shared_ptr</code> 中管理的资源是否存在，<strong>它只可以从一个 shared_ptr 或另一个 weak_ptr 对象构造</strong>，<strong>它的构造和析构不会引起引用记数的增加或减少</strong>。</p>
<p>weak_ptr 是用来解决 shared_ptr 相互引用时的死锁问题，如果说两个 shared_ptr 相互引用，那么这两个指针的引用计数永远不可能下降为 0，也就是资源永远不会释放。它是对对象的一种弱引用，不会增加对象的引用计数，<strong>和 shared_ptr 之间可以相互转化</strong>：</p>
<ul>
<li>shared_ptr 可以直接赋值给它</li>
<li>它也可以通过调用 lock 函数来获得 shared_ptr</li>
</ul>
<p>循环引用是当两个智能指针都是 shared_ptr 类型的时候，析构时两个资源引用计数会减 1，但是两者引用计数还是为 1，导致跳出函数时资源没有被释放（<strong>析构函数没有被调用</strong>），解决办法就是把其中一个改为 <code>weak_ptr</code> 就可以。</p>
<p>总之 weak_ptr <strong>可以用来返回 this 指针和解决循环引用问题</strong>。</p>
<ul>
<li>作用 1：返回 this 指针，上面介绍的 <code>shared_from_this()</code> 其实就是通过 <code>weak_ptr</code> 返回的 this 指针</li>
</ul>
<blockquote>
<p>Q：<code>shared_from_this()</code> 是如何实现的？</p>
<p>A：使用 <code>shared_from_this()</code> 的类需要继承 <code>enable_shared_from_this</code> 类，<code>enable_shared_from_this</code> 类中持有一个类型为 <code>weak_ptr</code> 的成员 <code>_M_weak_this</code>，调用 <code>shared_from_this()</code> 就是将内部持有的 <code>weak_ptr</code> 转成了 <code>shared_ptr</code>。</p>
</blockquote>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">enable_shared_from_this</span></span><br><span class="line">{</span><br><span class="line">    <span class="function">shared_ptr&lt;<span class="type">const</span> _Tp&gt; <span class="title">shared_from_this</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">shared_ptr</span>&lt;<span class="type">const</span> _Tp&gt;(<span class="keyword">this</span>-&gt;_M_weak_this);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">mutable</span> weak_ptr&lt;_Tp&gt; _M_weak_this;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>作用 2：解决循环引用问题</li>
</ul>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> {</span><br><span class="line">    std::shared_ptr&lt;B&gt; bptr;</span><br><span class="line">    </span><br><span class="line">    ~<span class="built_in">A</span>() {</span><br><span class="line">        cout &lt;&lt; <span class="string">"A delete"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span> </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"A"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> {</span><br><span class="line">    std::weak_ptr&lt;A&gt; aptr;         <span class="comment">// 这里改成 weak_ptr</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// B 对象销毁时才调用（即引用计数为 0 时）</span></span><br><span class="line">    ~<span class="built_in">B</span>() {</span><br><span class="line">        cout &lt;&lt; <span class="string">"B delete"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">PrintA</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (!aptr.<span class="built_in">expired</span>()) {     <span class="comment">// 监视 shared_ptr 的生命周期</span></span><br><span class="line">            <span class="keyword">auto</span> ptr = aptr.<span class="built_in">lock</span>();</span><br><span class="line">            ptr-&gt;<span class="built_in">Print</span>();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">auto</span> aaptr = std::<span class="built_in">make_shared</span>&lt;A&gt;();</span><br><span class="line">    <span class="keyword">auto</span> bbptr = std::<span class="built_in">make_shared</span>&lt;B&gt;();</span><br><span class="line">    aaptr-&gt;bptr = bbptr;</span><br><span class="line">    bbptr-&gt;aptr = aaptr;</span><br><span class="line">    bbptr-&gt;<span class="built_in">PrintA</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// A</span></span><br><span class="line"><span class="comment">// A delete</span></span><br><span class="line"><span class="comment">// B delete</span></span><br></pre></td></tr></tbody></table></figure>

<p>🔥 代码解释：尽管局部变量的析构顺序是按照后进先出的原则，但<strong>关键在于“对象的销毁时机”是由引用计数决定的，而不是直接由局部变量析构的顺序决定的</strong>：</p>
<ol>
<li><strong>局部变量析构顺序</strong>：在 main 函数中，aaptr 先创建、bbptr 后创建，因此在退出作用域时，bbptr 会先析构，随后 aaptr 析构。</li>
<li><strong>引用计数的影响</strong><ul>
<li>创建时，aaptr 持有 A 对象，bbptr 持有 B 对象。</li>
<li>A 对象内部的成员变量 bptr 又持有 B 对象的 shared_ptr，因此 B 对象的引用计数为 2。</li>
<li>B 对象内部的 weak_ptr 不会影响 A 对象的引用计数。</li>
</ul>
</li>
<li><strong>析构过程</strong><ul>
<li>当 bbptr 析构时，仅仅减少了 B 对象的引用计数，从 2 变为 1，但 B 对象并没有被销毁，因为 <code>aaptr-&gt;bptr</code> 仍然持有它。</li>
<li>随后 aaptr 析构，导致 A 对象的引用计数从 1 变为 0，从而触发 A 的析构函数，输出 “A delete”。</li>
<li>在 A 的析构过程中，其成员变量 bptr 被析构，从而使 B 对象的引用计数从 1 减为 0。此时，B 对象的析构函数被调用，输出 “B delete”。</li>
</ul>
</li>
</ol>
<h3 id="3️⃣-unique-ptr-独占式智能指针（替换-auto-ptr）"><a href="#3️⃣-unique-ptr-独占式智能指针（替换-auto-ptr）" class="headerlink" title="3️⃣ unique_ptr 独占式智能指针（替换 auto_ptr）"></a>3️⃣ unique_ptr 独占式智能指针（替换 <code>auto_ptr</code>）</h3><p><code>unique_ptr</code> 是一个独占型的智能指针，它不允许其他的智能指针共享其内部的指针：</p>
<ul>
<li>不允许通过赋值将一个 <code>unique_ptr</code> 拷贝/赋值给另外一个 <code>unique_ptr</code></li>
<li>但是允许通过函数返回给其他的 <code>unique_ptr</code> 或者通过 <code>std::move</code> 来转移到其他的 <code>unique_ptr</code>，<strong>这样的话它本身就不再拥有原指针的所有权了</strong></li>
</ul>
<p>与 <code>shared_ptr</code> 相比，<code>unique_ptr</code> 除了独占性的特点外，还能够指向一个数组：<code>std::unique_ptr&lt;int []&gt; p(new int[10]);</code>。</p>
<p><code>shared_ptr</code> 与 <code>unique_ptr</code> 的使用需要根据场景决定，如果希望<strong>只有一个智能指针管理资源</strong>或者<strong>管理数组</strong>就使用 <code>unique_ptr</code>，如果希望使用多个智能指针管理同一个资源就使用 <code>shared_ptr</code>。</p>
<h3 id="🔥-实现简易的-shared-ptr"><a href="#🔥-实现简易的-shared-ptr" class="headerlink" title="🔥 实现简易的 shared_ptr"></a>🔥 实现简易的 <code>shared_ptr</code></h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">smartPtr</span> {</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T *_ptr;</span><br><span class="line">    <span class="type">size_t</span>* _count;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">smartPtr</span>(T *ptr = <span class="literal">nullptr</span>):_ptr(ptr) {</span><br><span class="line">        <span class="keyword">if</span> (_ptr) {</span><br><span class="line">            _count = <span class="keyword">new</span> <span class="built_in">size_t</span>(<span class="number">1</span>);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            _count = <span class="keyword">new</span> <span class="built_in">size_t</span>(<span class="number">0</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">smartPtr</span>(<span class="type">const</span> smartPtr &amp;ptr) {</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;ptr) {</span><br><span class="line">            <span class="keyword">this</span>-&gt;_ptr = ptr._ptr;</span><br><span class="line">            <span class="keyword">this</span>-&gt;_count = ptr._count;</span><br><span class="line">            ++(*<span class="keyword">this</span>-&gt;_count)   ;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    smartPtr&amp; <span class="keyword">operator</span>=(<span class="type">const</span> smartPtr &amp;ptr) {</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;_ptr == ptr._ptr)</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;_ptr) {</span><br><span class="line">            --(*<span class="keyword">this</span>-&gt;_count);</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;_count == <span class="number">0</span>) {</span><br><span class="line">                <span class="keyword">delete</span> <span class="keyword">this</span>-&gt;_ptr;</span><br><span class="line">                <span class="keyword">delete</span> <span class="keyword">this</span>-&gt;_count;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>-&gt;_ptr = ptr._ptr;</span><br><span class="line">        <span class="keyword">this</span>-&gt;_count = ptr._count;</span><br><span class="line">        ++(*<span class="keyword">this</span>-&gt;_count);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">smartPtr</span>() {</span><br><span class="line">        --(*<span class="keyword">this</span>-&gt;_count);</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> == *<span class="keyword">this</span>-&gt;_count) {</span><br><span class="line">            <span class="keyword">delete</span> <span class="keyword">this</span>-&gt;_ptr;</span><br><span class="line">            <span class="keyword">delete</span> <span class="keyword">this</span>-&gt;_count;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">use_count</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>-&gt;_count;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    T&amp; <span class="keyword">operator</span>*() {</span><br><span class="line">        <span class="built_in">assert</span>(<span class="keyword">this</span>-&gt;_ptr == <span class="literal">nullptr</span>);</span><br><span class="line">        <span class="keyword">return</span> *(<span class="keyword">this</span>-&gt;_ptr);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    T* <span class="keyword">operator</span>-&gt;() {</span><br><span class="line">        <span class="built_in">assert</span>(<span class="keyword">this</span>-&gt;_ptr == <span class="literal">nullptr</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;_ptr;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<h2 id="21-shared-ptr-的实现，shared-ptr-一定不会导致内存泄漏吗？"><a href="#21-shared-ptr-的实现，shared-ptr-一定不会导致内存泄漏吗？" class="headerlink" title="21. shared_ptr 的实现，shared_ptr 一定不会导致内存泄漏吗？"></a>21. shared_ptr 的实现，shared_ptr 一定不会导致内存泄漏吗？</h2><p><code>std::shared_ptr</code> 的实现基于引用计数，每个 <code>shared_ptr</code> 实例持有一个指向控制块的指针，控制块中包含引用计数和所管理对象的指针。 当 <code>shared_ptr</code> 的引用计数降为零时，控制块会删除所管理的对象。 然而，<code>shared_ptr</code> 并非在所有情况下都能防止内存泄漏。 当存在<strong>循环引用</strong>时，<code>shared_ptr</code> 的引用计数永远不会降为零，导致内存无法被释放，从而引发内存泄漏。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::shared_ptr&lt;B&gt; b;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::shared_ptr&lt;A&gt; a;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    std::shared_ptr&lt;A&gt; a = std::<span class="built_in">make_shared</span>&lt;A&gt;();</span><br><span class="line">    std::shared_ptr&lt;B&gt; b = std::<span class="built_in">make_shared</span>&lt;B&gt;();</span><br><span class="line">    a-&gt;b = b;</span><br><span class="line">    b-&gt;a = a;</span><br><span class="line">    <span class="comment">// 此时，a 和 b 相互持有对方的 shared_ptr，形成循环引用</span></span><br><span class="line">    <span class="comment">// 程序结束时，a 和 b 的引用计数都不会降为零，导致内存泄漏</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>为了解决循环引用问题，可以使用 <code>std::weak_ptr</code>，它是一种不增加引用计数的智能指针。 <code>std::weak_ptr</code> 用于打破循环引用，避免内存泄漏。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::weak_ptr&lt;B&gt; b; <span class="comment">// 使用 weak_ptr 打破循环引用</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::shared_ptr&lt;A&gt; a;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    std::shared_ptr&lt;A&gt; a = std::<span class="built_in">make_shared</span>&lt;A&gt;();</span><br><span class="line">    std::shared_ptr&lt;B&gt; b = std::<span class="built_in">make_shared</span>&lt;B&gt;();</span><br><span class="line">    a-&gt;b = b;</span><br><span class="line">    b-&gt;a = a;</span><br><span class="line">    <span class="comment">// 此时，a 和 b 之间的循环引用被 weak_ptr 打破</span></span><br><span class="line">    <span class="comment">// 程序结束时，a 和 b 的引用计数会降为零，内存会被正确释放</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>或者如果在类之间的引用是单向的（即不会形成循环引用），可以考虑使用 <code>std::unique_ptr</code>。<code>std::unique_ptr</code> 不会引起引用计数问题，因为它是独占的，每个对象只有一个拥有者。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::unique_ptr&lt;B&gt; b; <span class="comment">// 改为 unique_ptr</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::shared_ptr&lt;A&gt; a;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    std::shared_ptr&lt;A&gt; a = std::<span class="built_in">make_shared</span>&lt;A&gt;();</span><br><span class="line">    std::shared_ptr&lt;B&gt; b = std::<span class="built_in">make_shared</span>&lt;B&gt;();</span><br><span class="line">    a-&gt;b = std::<span class="built_in">move</span>(b); <span class="comment">// 转移所有权</span></span><br><span class="line">    <span class="comment">// 使用 unique_ptr 的情况下，没有循环引用问题</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="22-STL-中-vector、list、map-的底层原理实现和适用场景？"><a href="#22-STL-中-vector、list、map-的底层原理实现和适用场景？" class="headerlink" title="22. STL 中 vector、list、map 的底层原理实现和适用场景？"></a>22. STL 中 vector、list、map 的底层原理实现和适用场景？</h2><p>关于 STL 库中所有的结构的底层实现原理：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/542115773">https://zhuanlan.zhihu.com/p/542115773</a></p>
<blockquote>
<p>顺带了解了 set、map、unordered_map、unordered_set 之间区别：</p>
<ul>
<li><code>set</code>、<code>map</code>：底层使用红黑树实现，有序，插入、查找、删除的时间复杂度为 $O(logn)$<ul>
<li>优点：有序性，内部实现红黑树使得很多操作都在 $O(logn)$ 时间复杂度下完成</li>
<li>缺点：空间占用率高，需要额外保存父节点、孩子节点和红/黑性质</li>
</ul>
</li>
<li><code>unordered_set</code>、<code>unordered_map</code>：底层使用哈希表实现，无序，查找的时间复杂度为 $O(1)$<ul>
<li>优点：因为内部实现了哈希表，因此其查找速度非常的快</li>
<li>缺点：哈希表的建立比较费时</li>
</ul>
</li>
</ul>
</blockquote>
<p>1️⃣ vector 动态数组</p>
<ul>
<li><code>vector</code> 底层是动态数组，元素连续存储在堆上</li>
<li>自动扩容机制：<ul>
<li>vector 采用几何增长策略（通常是 2 倍扩容）</li>
<li>当 <code>size() == capacity()</code> 时，会申请更大的内存空间，然后拷贝旧数据到新空间</li>
<li>由于 realloc 可能导致数据搬移，<code>push_back()</code> 的均摊时间复杂度为 $O(1)$，但最坏情况 $O(n)$（扩容时）</li>
</ul>
</li>
<li>❓所以有可能 vector 的<strong>插入操作可能导致迭代器失效</strong>：因为 vector 动态增加大小时，并不是在原空间后增加新空间，而是以原大小两倍在开辟另外一片较大空间，然后将内容拷贝过来，并释放原有空间，所以迭代器失效。</li>
</ul>
<p>适用场景：</p>
<p>✅ 高效的随机访问（<code>O(1)</code>）。<br>✅ 批量尾部插入/删除（<code>push_back()</code>）。<br>❌ 不适合频繁插入/删除中间元素（<code>O(n)</code>）。<br>❌ 扩容会导致数据搬移（不适合超大数据集）。</p>
<p>2️⃣ list 双向链表</p>
<ul>
<li><code>list</code> 底层是双向链表，每个节点存储数据和两个指针</li>
<li>插入和删除操作非常高效，不影响其他元素</li>
<li>不支持随机访问，必须顺序遍历才能找到某个元素 $O(n)$</li>
<li>不会发生扩容问题，适合频繁插入/删除的场景</li>
</ul>
<p>适用场景：</p>
<p>✅ 高效插入/删除（<code>O(1)</code>，特别是中间位置）。<br>✅ 不关心随机访问，仅需遍历。<br>❌ 不适合频繁随机访问（<code>O(n)</code>）。<br>❌ 额外的指针开销（内存占用比 <code>vector</code> 高）。</p>
<p>3️⃣ map 红黑树</p>
<ul>
<li><code>map</code> 底层实现是红黑树（Red-Black Tree），一种自平衡二叉搜索树</li>
<li>key 是有序的</li>
<li>插入、删除、查找 $O(logn)$，因为树的高度是 $O(logn)$</li>
<li>迭代遍历按照 key 顺序进行</li>
</ul>
<table>
<thead>
<tr>
<th>操作</th>
<th>时间复杂度</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>插入 <code>insert()</code></td>
<td>$O(log n)$</td>
<td>需要维护红黑树平衡</td>
</tr>
<tr>
<td>删除 <code>erase()</code></td>
<td>$O(log n)$</td>
<td>删除节点后可能需要旋转</td>
</tr>
<tr>
<td>查找 <code>find()</code></td>
<td>$O(log n)$</td>
<td>通过 BST 进行搜索</td>
</tr>
</tbody></table>
<p>适用场景：</p>
<p>✅ 需要有序存储的数据结构（默认按照 key 递增）。<br>✅ 需要高效查找、插入、删除（<code>O(log n)</code>）。<br>❌ 不适合频繁变更 key（因为 key 作为 BST 节点的一部分）。<br>❌ 遍历效率比 <code>unordered_map</code> 低（有序存储开销大）。</p>
<h2 id="23-菱形继承会出现二义性问题，C-中如何解决这个问题？"><a href="#23-菱形继承会出现二义性问题，C-中如何解决这个问题？" class="headerlink" title="23. 菱形继承会出现二义性问题，C++ 中如何解决这个问题？"></a>23. 菱形继承会出现二义性问题，C++ 中如何解决这个问题？</h2><p>❓镜像问题：一个派生类继承两个父类，这两个父类同时有一个共同基类，如果你去调用两个父类的基类对象函数，会有问题吗？怎么解决？</p>
<blockquote>
<p>注：在 Java 中，<strong>由于 Java 不支持多重继承，所以菱形继承问题也不存在</strong>。 Java 使用接口来替代多重继承，接口只定义了一些抽象的方法，而没有具体的实现。</p>
</blockquote>
<p>这是 C++ 多重继承造成的菱形继承问题，如果一个派生类继承了两个拥有相同基类的父类，<strong>那么基类的成员会被继承两次，这会导致 “二义性问题” 和 “冗余存储”</strong>。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/Wu-yikun/OSS/PicGo/202503070316671.jpg" alt="img"></p>
<p>❌ 编译错误！</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>{ std::cout &lt;&lt; <span class="string">"Base::show()"</span> &lt;&lt; std::endl; }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Parent1</span> : <span class="keyword">public</span> Base {};  <span class="comment">// 继承自 Base</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Parent2</span> : <span class="keyword">public</span> Base {};  <span class="comment">// 继承自 Base</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 多重继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Parent1, <span class="keyword">public</span> Parent2 {};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    Derived d;</span><br><span class="line">    d.<span class="built_in">show</span>();  <span class="comment">// ⚠️ 编译错误：二义性</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>1️⃣ 解决方案一：使用作用域解析符</p>
<p><strong>缺点</strong>：<code>Derived</code> 仍然包含 <strong>两个 <code>Base</code> 实例</strong>，<strong>数据冗余</strong>，而且每次调用 <code>show()</code> 需要手动指定作用域，不优雅。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    Derived d;</span><br><span class="line">    d.Parent1::<span class="built_in">show</span>();  <span class="comment">// 访问 Parent1 继承的 Base</span></span><br><span class="line">    d.Parent2::<span class="built_in">show</span>();  <span class="comment">// 访问 Parent2 继承的 Base</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>2️⃣ 使用虚继承｜最佳方案 ✅ </p>
<blockquote>
<p>虚继承是为了让某个类做出声明，承诺愿意共享它的基类，这个被共享的基类就是虚基类</p>
</blockquote>
<p>多继承除了造成命名冲突，还有数据冗余等问题，为了解决这些问题，C++ 引进了「<strong>虚继承</strong>」</p>
<p>这样能够保证 <code>Derived</code> 只含有一个唯一的 Base 实例。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>{ std::cout &lt;&lt; <span class="string">"Base::show()"</span> &lt;&lt; std::endl; }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 让 Parent1 和 Parent2 进行虚继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Parent1</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> Base {};</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Parent2</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> Base {};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承 Parent1 和 Parent2</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Parent1, <span class="keyword">public</span> Parent2 {};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    Derived d;</span><br><span class="line">    d.<span class="built_in">show</span>();  <span class="comment">// ✅ 现在可以直接调用，不会有二义性</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>不使用 <code>virtual</code> 时</strong></p>
<ul>
<li><code>Derived</code> <strong>会有两个 <code>Base</code> 对象</strong>，导致二义性问题。</li>
<li><strong>内存浪费</strong>（两个 <code>Base</code> 子对象的冗余）。</li>
</ul>
<p><strong>使用 <code>virtual</code> 继承</strong></p>
<ul>
<li><code>Parent1</code> 和 <code>Parent2</code> <strong>不会各自包含 <code>Base</code> 的副本</strong>，而是<strong>共享同一个 <code>Base</code> 实例</strong>。</li>
<li><strong><code>Derived</code> 只会有一个 <code>Base</code> 实例</strong>，所以调用 <code>show()</code> 时不会有二义性。</li>
</ul>
<p>🔥虚继承是为了让某个类做出声明，承诺愿意共享它的基类，这个被共享的基类就是虚基类！</p>
<blockquote>
<p>使用虚继承解决菱形继承中的命名冲突问题</p>
</blockquote>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/Wu-yikun/OSS/PicGo/202503070316430.jpg" alt="img"></p>
<blockquote>
<p>🔥 虚继承在 C++ 标准库中的实际应用</p>
</blockquote>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/Wu-yikun/OSS/PicGo/202503070317150.jpg" alt="img"></p>
<p>再看个虚继承的例子，彻底明白虚继承：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base0</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> var0;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fun0</span><span class="params">()</span> </span>{ cout &lt;&lt; <span class="string">"Member of Base0"</span> &lt;&lt; endl; }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base1</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> Base0 {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> var1;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base2</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> Base0 {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> var2;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base1, <span class="keyword">public</span> Base2 {</span><br><span class="line">    <span class="comment">//定义派生类Derived </span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> var;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">()</span> </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"Member of Derived"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    Derived d;</span><br><span class="line">    d.var0 = <span class="number">2</span>; <span class="comment">//直接访问虚基类的数据成员</span></span><br><span class="line">    d.<span class="built_in">fun0</span>();   <span class="comment">//直接访问虚基类的函数成员</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>⁉️将 Base0 类作为它的直接派生类 Base1 和 Base2 的<strong>虚基类</strong>，即 Base1 虚继承 Base0，Base2 虚继承 Base0。之后 Derived 再继承 Base1 和 Base2，<strong>在 Derived 对象里面就不会存在 Base0 类的双份的成员</strong>。</p>
<p>Derived 对象包含着从 Base1 继承的成员和从 Base2 继承的成员，<strong>但是从 Base1 继承的 Base0 成员实际上这个地方放了一个指针，这个指针指向真正的 Base0 成员，Base2 的也是</strong>。所以实质上从最远的基类继承过来的成员，在最远派生类中只有一份。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/Wu-yikun/OSS/PicGo/202503070325788.png" alt="image-20250307024809735"></p>
<h2 id="24-动态编译-vs-静态编译，动态链接-vs-静态链接？"><a href="#24-动态编译-vs-静态编译，动态链接-vs-静态链接？" class="headerlink" title="24. 动态编译 vs 静态编译，动态链接 vs 静态链接？"></a>24. 动态编译 vs 静态编译，动态链接 vs 静态链接？</h2><p>在编译和链接过程中，我们可以分为以下几个阶段：</p>
<ul>
<li>编译（Compilation）：将源代码 <code>.cpp</code> 转换为目标文件 <code>.o</code>。</li>
<li>链接（Linking）：将多个目标文件和库组合成一个可执行文件。</li>
</ul>
<p><strong>(1) 静态编译 vs 动态编译</strong></p>
<ul>
<li>静态编译（Static Compilation）：所有代码都在 <strong>编译时</strong> 确定，并编译成完整的 <strong>可执行文件</strong>。</li>
<li>动态编译（Dynamic Compilation）：代码可以在 <strong>运行时动态生成或加载</strong>，例如 JIT（Just-In-Time）编译。</li>
</ul>
<p><strong>(2) 静态链接 vs 动态链接</strong></p>
<ul>
<li>静态链接（Static Linking）：<ul>
<li><strong>编译时</strong> 将所有 <strong>库的代码</strong> 直接复制到可执行文件中。</li>
<li>生成的可执行文件 <strong>较大</strong>，但不依赖外部动态库。</li>
</ul>
</li>
<li>动态链接（Dynamic Linking）：<ul>
<li>运行时<strong>按需加载</strong>动态库（<code>.so</code>/<code>.dll</code>）。</li>
<li>可执行文件 <strong>更小</strong>，可以<strong>更新动态库</strong>而无需重新编译整个程序。</li>
</ul>
</li>
</ul>
<h2 id="25-拷贝构造函数与-operator-的区别？"><a href="#25-拷贝构造函数与-operator-的区别？" class="headerlink" title="25. 拷贝构造函数与 operator=() 的区别？"></a>25. 拷贝构造函数与 <code>operator=()</code> 的区别？</h2><p>在 C++ 中，<strong>拷贝构造函数</strong> 和 <strong>赋值运算符 (<code>operator=</code>)</strong> 主要区别在于 <strong>调用时机和行为</strong>。</p>
<p><strong>(1) 拷贝构造函数</strong></p>
<ul>
<li>作用：用于创建新对象时，用已有对象进行初始化。</li>
<li>调用时机：<ol>
<li><strong>用已有对象初始化新对象</strong></li>
<li><strong>函数按值传递参数</strong></li>
<li><strong>函数返回对象（优化前的 NRVO）</strong></li>
</ol>
</li>
</ul>
<p>示例：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> d) : <span class="built_in">data</span>(d) {}</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 拷贝构造函数</span></span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">const</span> MyClass&amp; other) {</span><br><span class="line">        data = other.data;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"Copy Constructor\n"</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">MyClass <span class="title">obj1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    MyClass obj2 = obj1;  <span class="comment">// 拷贝构造</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>输出：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CopyEdit</span><br><span class="line">Copy Constructor</span><br></pre></td></tr></tbody></table></figure>

<p><strong>(2) 赋值运算符 <code>operator=</code></strong></p>
<ul>
<li>作用：用于 <strong>已有对象之间赋值</strong>，即一个对象的内容 <strong>被另一个对象替换</strong>。</li>
<li>调用时机：<ul>
<li>两个已存在对象进行赋值时</li>
<li>🔥 <code>a = b;</code> 而不是 <code>MyClass a = b;</code></li>
</ul>
</li>
</ul>
<p>示例：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> d) : <span class="built_in">data</span>(d) {}</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 赋值运算符</span></span><br><span class="line">    MyClass&amp; <span class="keyword">operator</span>=(<span class="type">const</span> MyClass&amp; other) {</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;other) <span class="keyword">return</span> *<span class="keyword">this</span>;  <span class="comment">// 防止自赋值</span></span><br><span class="line">        data = other.data;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"Assignment Operator\n"</span>;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">MyClass <span class="title">obj1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="function">MyClass <span class="title">obj2</span><span class="params">(<span class="number">20</span>)</span></span>;</span><br><span class="line">    obj2 = obj1;  <span class="comment">// 赋值运算符调用</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>输出：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Assignment Operator</span><br></pre></td></tr></tbody></table></figure>

<p><strong>(3) 主要区别</strong></p>
<table>
<thead>
<tr>
<th><strong>对比项</strong></th>
<th><strong>拷贝构造函数</strong></th>
<th><strong>赋值运算符 (<code>operator=</code>)</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>作用</strong></td>
<td>初始化新对象</td>
<td>赋值给已有对象</td>
</tr>
<tr>
<td><strong>调用时机</strong></td>
<td><code>MyClass a = b;</code></td>
<td><code>a = b;</code></td>
</tr>
<tr>
<td><strong>是否创建新对象</strong></td>
<td>✅ 是</td>
<td>❌ 否</td>
</tr>
<tr>
<td><strong>默认行为</strong></td>
<td>成员逐一拷贝</td>
<td>成员逐一赋值</td>
</tr>
</tbody></table>
<p><strong>(4) 特殊情况</strong></p>
<p>避免自赋值</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span> == &amp;other) <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br></pre></td></tr></tbody></table></figure>

<p>支持链式赋值</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">MyClass&amp; <span class="keyword">operator</span>=(<span class="type">const</span> MyClass&amp; other) {</span><br><span class="line">    <span class="keyword">this</span>-&gt;data = other.data;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">obj1 = obj2 = obj3;  <span class="comment">// 链式赋值</span></span><br></pre></td></tr></tbody></table></figure>

<h2 id="26-右值引用的主要用途？"><a href="#26-右值引用的主要用途？" class="headerlink" title="26. 右值引用的主要用途？"></a>26. 右值引用的主要用途？</h2><blockquote>
<p>等价于问题：什么情况下会用到右值引用。</p>
</blockquote>
<p>右值引用是 C++11 引入的新特性，用于实现移动语义和完美转发：</p>
<h3 id="1️⃣-实现移动语义"><a href="#1️⃣-实现移动语义" class="headerlink" title="1️⃣ 实现移动语义"></a>1️⃣ 实现移动语义</h3><p>在传统 C++ 中，对象的赋值和传递通常涉及深拷贝，这会带来性能开销，通过右值引用，可以触发移动构造函数将资源所有权从一个对象转移到另一个对象（将资源从临时对象移动到新对象），无需深拷贝，<strong>避免了不必要的复制和销毁操作</strong>。</p>
<blockquote>
<p>当一个临时对象或不再使用的资源，需要被高效地“移动”而不是拷贝时，就用到右值引用</p>
</blockquote>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; v1 = {<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>};</span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; v2 = std::<span class="built_in">move</span>(v1); <span class="comment">// 此时v1内容转移给v2，避免深拷贝</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="2️⃣-完美转发"><a href="#2️⃣-完美转发" class="headerlink" title="2️⃣ 完美转发"></a>2️⃣ 完美转发</h3><p>用于函数模板的完美转发，将参数以原始的形式传递给下一个函数，避免了不必要的复制和类型转换。</p>
<blockquote>
<p>模板中利用万能引用（forwarding reference）配合<code>std::forward</code>实现任意类型参数的原始性质传递</p>
</blockquote>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">wrapper</span><span class="params">(T&amp;&amp; arg)</span> </span>{</span><br><span class="line">    <span class="built_in">func</span>(std::forward&lt;T&gt;(arg));  <span class="comment">// 原样传递arg（左值传左值，右值传右值）</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="针对「完美转发」，请看如下例子"><a href="#针对「完美转发」，请看如下例子" class="headerlink" title="针对「完美转发」，请看如下例子"></a>针对「完美转发」，请看如下例子</h3><p>假设我们有两个重载的函数 <code>process</code>，一个接收左值引用，另一个接收右值引用：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(<span class="type">int</span>&amp; i)</span> </span>{</span><br><span class="line">    std::cout &lt;&lt; <span class="string">"左值引用处理: "</span> &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(<span class="type">int</span>&amp;&amp; i)</span> </span>{</span><br><span class="line">    std::cout &lt;&lt; <span class="string">"右值引用处理: "</span> &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>现在，我们希望编写一个模板函数 <code>forwarding</code>，它能够将传入的参数完美地转发给 <code>process</code>，即保持参数的左值或右值属性不变。</p>
<ul>
<li><strong>不使用完美转发的情况</strong>：如果我们直接在模板函数中调用 <code>process(param)</code>，无论传入的是左值还是右值，<code>param</code> 在函数内部都是一个左值，这会导致总是调用接收左值引用的 <code>process</code> 函数：</li>
</ul>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="comment">// void forwarding(T param) 也是如此，即右值无法传递进去导致参数不匹配</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">forwarding</span><span class="params">(T&amp;&amp; param)</span> </span>{</span><br><span class="line">    <span class="built_in">process</span>(param); <span class="comment">// param 被视为左值，即右值无法传递进去导致参数不匹配</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li><strong>使用完美转发的情况</strong>：为了实现完美转发，我们需要：<ul>
<li>使用万能引用：在模板参数中使用 <code>T&amp;&amp;</code>，使得函数能够同时接收左值和右值。</li>
<li>为了解决这个问题，引入了 <code>std::forward</code>, 将模板函数改成如下形式就可以了, <code>forward</code> 被称为完美转发，根据参数的类型（左值或右值）进行条件转发，保持其原有的值类别。语义上：<code>数据是左值就转发成左值，右值就转发成右值，哪怕在万能引用中也是如此</code>。</li>
</ul>
</li>
</ul>
<p>实现如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span> <span class="comment">// std::forward</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">forwarding</span><span class="params">(T&amp;&amp; param)</span> </span>{</span><br><span class="line">    <span class="built_in">process</span>(std::forward&lt;T&gt;(param));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>测试代码：</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    forwarding(a);        <span class="comment">// 传入左值</span></span><br><span class="line">    forwarding(<span class="number">20</span>);       <span class="comment">// 传入右值</span></span><br><span class="line">    forwarding(std::<span class="built_in">move</span>(a)); <span class="comment">// 将左值转换为右值</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>输出结果：</strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">左值引用处理: 10</span><br><span class="line">右值引用处理: 20</span><br><span class="line">右值引用处理: 10</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h3 id="补充：左值引用（-）与右值引用（-）"><a href="#补充：左值引用（-）与右值引用（-）" class="headerlink" title="补充：左值引用（&amp;）与右值引用（&amp;&amp;）"></a>补充：左值引用（&amp;）与右值引用（&amp;&amp;）</h3><p>在 C++11 中提出了右值引用，作用是为了和左值引用区分开来，其作用是: <code>右值引用限制了其只能接收右值，可以利用这个特性从而提供重载</code>，这是右值引用有且唯一的特性，限制了接收参数必为右值, 这点常用在 move construct 中，告诉别人这是一个即将消失的对象的引用，可以瓜分我的对象东西，除此之外，右值引用就没有别的特性了。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">      <span class="built_in">Base</span>(<span class="type">const</span> Base&amp; b){...} <span class="comment">//copy construct </span></span><br><span class="line">      <span class="built_in">Base</span>(Base&amp;&amp; b){...}      <span class="comment">//move construct</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<p>然后，一个右值引用变量在使用上就变成了左值，已经不再携带其是右引用这样的信息，只是一个左值，这就是引用在c++中特殊而且复杂的一点，<code>引用在 c++ 中是一个特别的类型，因为它的值类型和变量类型不一样, 左值/右值引用变量的值类型都是左值, 而不是左值引用或者右值引用</code>。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> val = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span>&amp; val_left_ref = val;      </span><br><span class="line"><span class="type">int</span>&amp;&amp; val_right_ref = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引用必须在初始化时绑定到一个有效的对象，且绑定后无法更改</span></span><br><span class="line">val_left_ref = <span class="number">0</span>;      <span class="comment">// val_left_ref 此时是 int，而不是 int&amp;</span></span><br><span class="line">val_right_ref = <span class="number">0</span>;     <span class="comment">// val_right_ref 此时是 int， 而不是 int&amp;&amp;</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="🔥-补充：万能引用（T-）"><a href="#🔥-补充：万能引用（T-）" class="headerlink" title="🔥 补充：万能引用（T&amp;&amp;）"></a>🔥 补充：万能引用（T&amp;&amp;）</h3><p>模板中的 <code>T&amp;&amp;</code> 不同于普通的右值引用，而是万能引用，其既能接收左值又能接收右值。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">emplace_back</span><span class="params">(T&amp;&amp; arg)</span> </span>{</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">Class Base {</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    Base a;</span><br><span class="line">    <span class="built_in">emplace_back</span>(a);      <span class="comment">// ok</span></span><br><span class="line">    <span class="built_in">emplace_back</span>(<span class="built_in">Base</span>()); <span class="comment">// also ok</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这种特性常用在容器元素的增加上，利用传参是左值还是右值进而在生成元素的时候调用 copy construct 还是 move construct，比如说 <code>vector</code> 的 <code>emplace_back</code>。</p>
<blockquote>
<p>所以为什么需要 <code>std::forwad</code>？</p>
</blockquote>
<p>模板的万能引用只是提供了能够接收同时接收左值引用和右值引用的能力，但是引用类型的唯一作用就是限制了接收的类型，<strong>后续使用中都退化成了左值</strong>，我们希望能够在传递过程中保持它的左值或者右值的属性, 如果不使用 <code>forward</code>，直接按照下面的方式写就会导致问题。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="comment">// void forwarding(T param) 也是如此，即右值无法传递进去导致参数不匹配</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">forwarding</span><span class="params">(T&amp;&amp; param)</span> </span>{</span><br><span class="line">    <span class="built_in">process</span>(param); <span class="comment">// param 被视为左值，即右值无法传递进去导致参数不匹配</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>所以为了解决这个问题引入了 <code>std::forward</code>，将模板函数改成如下形式，即可实现完美转发：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">forwarding</span><span class="params">(T&amp;&amp; param)</span> </span>{</span><br><span class="line">    <span class="built_in">process</span>(std::forward&lt;T&gt;(param));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="27-C-中有哪些锁？"><a href="#27-C-中有哪些锁？" class="headerlink" title="27. C++ 中有哪些锁？"></a>27. C++ 中有哪些锁？</h2><blockquote>
<p>更多参考：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/641510924">如何避免死锁</a>、<a target="_blank" rel="noopener" href="https://interviewguide.cn/notes/03-hunting_job/02-interview/01-01-07-basic.html">介绍几种经典的锁</a></p>
</blockquote>
<ul>
<li>从种类上分：普通锁、读写锁、递归锁</li>
<li>从实现上分：互斥锁、自旋锁、信号量、条件变量</li>
</ul>
<h3 id="互斥锁（Mutex）"><a href="#互斥锁（Mutex）" class="headerlink" title="互斥锁（Mutex）"></a>互斥锁（Mutex）</h3><p>🌟互斥锁是在抢锁失败的情况下<strong>主动放弃 CPU 进入睡眠状态</strong>直到锁的状态改变时再唤醒，而操作系统负责线程调度，为了实现锁的状态发生改变时唤醒阻塞的线程或者进程，需要把锁交给操作系统管理，所以互斥锁在加锁操作时涉及上下文的切换。互斥锁实际的效率还是可以让人接受的，加锁的时间大概 100ns 左右，而实际上互斥锁的一种可能的实现是先自旋一段时间，当自旋的时间超过阀值之后再将线程投入睡眠中，因此在并发运算中使用互斥锁（每次占用锁的时间很短）的效果可能不亚于使用自旋锁。</p>
<ul>
<li>互斥锁（Mutex）：用于保护共享资源，确保任一时刻只有一个线程访问资源。</li>
<li>信号量（Semaphore）：一种特殊的计数器，可以同时允许多个线程访问有限的共享资源。</li>
</ul>
<p>互斥锁相当于信号量初值为 1 的特殊情况；信号量允许多个线程并发访问资源（初值 &gt; 1）。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">std::mutex mtx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">    <span class="comment">// 临界区操作</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>应用场景：</p>
<ul>
<li>保护关键资源（如共享变量）</li>
<li>控制资源的访问量</li>
</ul>
<h3 id="条件锁-条件变量（Condition-Variable）"><a href="#条件锁-条件变量（Condition-Variable）" class="headerlink" title="条件锁/条件变量（Condition Variable）"></a>条件锁/条件变量（Condition Variable）</h3><p>🌟互斥锁一个明显的缺点是他只有两种状态：锁定和非锁定。而条件变量通过允许线程阻塞和等待另一个线程发送信号的方法弥补了互斥锁的不足，他常和互斥锁一起使用，以免出现竞态条件。当条件不满足时，线程往往解开相应的互斥锁并阻塞线程然后等待条件发生变化。一旦其他的某个线程改变了条件变量，他将通知相应的条件变量唤醒一个或多个正被此条件变量阻塞的线程。<strong>总的来说互斥锁是线程间互斥的机制，条件变量则是同步机制</strong>。</p>
<p>条件变量用于线程间通信，当某个条件满足后再唤醒等待线程。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::mutex mtx;</span><br><span class="line">std::condition_variable cv;</span><br><span class="line"><span class="type">bool</span> ready = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">wait_thread</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">    cv.<span class="built_in">wait</span>(lock, [](){ <span class="keyword">return</span> ready; });  <span class="comment">// 等待条件满足</span></span><br><span class="line">    <span class="comment">// 执行后续任务</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">signal_thread</span><span class="params">()</span> </span>{</span><br><span class="line">    {</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">        ready = <span class="literal">true</span>;  <span class="comment">// 修改条件</span></span><br><span class="line">    }</span><br><span class="line">    cv.<span class="built_in">notify_one</span>();  <span class="comment">// 通知等待线程</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>应用场景：</p>
<ul>
<li>生产者-消费者模型</li>
<li>线程等待某条件满足才能执行</li>
</ul>
<h3 id="自旋锁（Spin-Lock）"><a href="#自旋锁（Spin-Lock）" class="headerlink" title="自旋锁（Spin Lock）"></a>自旋锁（Spin Lock）</h3><p>🌟如果线程无法取得锁，线程不会立刻放弃 CPU 时间片，而是一直循环尝试获取锁，直到获取为止。如果别的线程长时期占有锁那么自旋就是在浪费 CPU 做无用功，但是自旋锁一般应用于加锁时间很短的场景，这个时候效率比较高。</p>
<p>线程在等待资源时不会挂起或睡眠，而是不断循环检测锁状态（<strong>忙等待</strong>）</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SpinLock</span> {</span><br><span class="line">    std::atomic_flag lock_ = ATOMIC_FLAG_INIT;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">lock</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">while</span> (lock_.<span class="built_in">test_and_set</span>(std::memory_order_acquire));</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">unlock</span><span class="params">()</span> </span>{</span><br><span class="line">        lock_.<span class="built_in">clear</span>(std::memory_order_release);</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<p>应用场景：</p>
<ul>
<li>临界区非常短小</li>
<li>多核 CPU、短暂等待资源的情况</li>
</ul>
<h3 id="读写锁（Read-Write-Lock）"><a href="#读写锁（Read-Write-Lock）" class="headerlink" title="读写锁（Read-Write Lock）"></a>读写锁（Read-Write Lock）</h3><p>允许多个线程同时进行读操作，但写操作必须独占访问。</p>
<p>特点：</p>
<ul>
<li>读锁共享：多个读线程并发执行</li>
<li>写锁独占：写线程执行时不能有其他读、写线程存在</li>
</ul>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++17 的 shared_mutex</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;shared_mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::shared_mutex rw_mutex;</span><br><span class="line"><span class="type">int</span> shared_data = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reader</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">std::shared_lock&lt;std::shared_mutex&gt; <span class="title">lock</span><span class="params">(rw_mutex)</span></span>;</span><br><span class="line">    <span class="comment">// 读取shared_data</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">writer</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::shared_mutex&gt; <span class="title">lock</span><span class="params">(rw_mutex)</span></span>;</span><br><span class="line">    shared_data++;  <span class="comment">// 写操作</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>应用场景：大量读、少量写的场景（如配置文件读取，缓存数据等）</p>
<h3 id="递归锁（Recursive-Mutex）"><a href="#递归锁（Recursive-Mutex）" class="headerlink" title="递归锁（Recursive Mutex）"></a>递归锁（Recursive Mutex）</h3><p>同一线程可以多次获取同一个锁，但必须释放相同次数后才完全解锁。</p>
<p>特点：</p>
<ul>
<li>避免了同一线程递归调用中因反复加锁而引起的死锁问题</li>
<li>相比普通锁，多了一些额外开销</li>
</ul>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::recursive_mutex r_mutex;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">recursive_function</span><span class="params">(<span class="type">int</span> n)</span> </span>{</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::recursive_mutex&gt; <span class="title">lock</span><span class="params">(r_mutex)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">0</span>) {</span><br><span class="line">        <span class="built_in">recursive_function</span>(n - <span class="number">1</span>); <span class="comment">// 递归调用</span></span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 临界区操作</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>应用场景：函数递归调用或函数间的相互调用都可能再次尝试获取同一锁</p>
<h2 id="28-如何用-C-实现一个读写锁"><a href="#28-如何用-C-实现一个读写锁" class="headerlink" title="28. 如何用 C++ 实现一个读写锁"></a>28. 如何用 C++ 实现一个读写锁</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RWLock</span> {</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::mutex mtx_;</span><br><span class="line">    std::condition_variable cv_;</span><br><span class="line">    <span class="type">int</span> readers_;          <span class="comment">// 正在读取的线程数量</span></span><br><span class="line">    <span class="type">int</span> writers_waiting_;  <span class="comment">// 等待写入的线程数量</span></span><br><span class="line">    <span class="type">bool</span> writing_;         <span class="comment">// 当前是否有写线程</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">RWLock</span>() : <span class="built_in">readers_</span>(<span class="number">0</span>), <span class="built_in">writers_waiting_</span>(<span class="number">0</span>), <span class="built_in">writing_</span>(<span class="literal">false</span>) {}</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读锁定</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">lock_read</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">        <span class="comment">// 当有写操作进行中或等待中的写操作时等待</span></span><br><span class="line">        cv_.<span class="built_in">wait</span>(lock, [<span class="keyword">this</span>]() {</span><br><span class="line">            <span class="keyword">return</span> !writing_ &amp;&amp; writers_waiting_ == <span class="number">0</span>;</span><br><span class="line">        });</span><br><span class="line">        ++readers_;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读解锁</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">unlock_read</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (--readers_ == <span class="number">0</span>) {</span><br><span class="line">            cv_.<span class="built_in">notify_all</span>();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写锁定</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">lock_write</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">        ++writers_waiting_;</span><br><span class="line">        cv_.<span class="built_in">wait</span>(lock, [<span class="keyword">this</span>]() { <span class="keyword">return</span> !writing_ &amp;&amp; readers_ == <span class="number">0</span>; });</span><br><span class="line">        --writers_waiting_;</span><br><span class="line">        writing_ = <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写解锁</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">unlock_write</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">        writing_ = <span class="literal">false</span>;</span><br><span class="line">        cv_.<span class="built_in">notify_all</span>();</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<p>使用实例：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line">RWLock rwlock;</span><br><span class="line"><span class="type">int</span> shared_data = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reader</span><span class="params">(<span class="type">int</span> id)</span> </span>{</span><br><span class="line">    rwlock.<span class="built_in">lock_read</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">"Reader "</span> &lt;&lt; id &lt;&lt; <span class="string">" reads value: "</span> &lt;&lt; shared_data &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">100</span>));</span><br><span class="line">    rwlock.<span class="built_in">unlock_read</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">writer</span><span class="params">(<span class="type">int</span> id)</span> </span>{</span><br><span class="line">    rwlock.<span class="built_in">lock_write</span>();</span><br><span class="line">    ++shared_data;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">"Writer "</span> &lt;&lt; id &lt;&lt; <span class="string">" updated value to: "</span> &lt;&lt; shared_data &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">150</span>));</span><br><span class="line">    rwlock.<span class="built_in">unlock_write</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    std::vector&lt;std::thread&gt; threads;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动读线程</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) {</span><br><span class="line">        threads.<span class="built_in">emplace_back</span>(reader, i);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动写线程</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) {</span><br><span class="line">        threads.<span class="built_in">emplace_back</span>(writer, i);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;t : threads) {</span><br><span class="line">        t.<span class="built_in">join</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li><p>以上实现倾向于<strong>写优先</strong>（有写操作等待时，不允许新的读操作）。</p>
</li>
<li><p>可以通过修改逻辑实现读优先或公平性策略，例如：</p>
<ul>
<li><strong>去除 <code>writers_waiting_ == 0</code> 的约束实现读优先</strong>。</li>
<li>更复杂的公平策略则需要额外的数据结构管理等待顺序。</li>
</ul>
</li>
<li><p>实际应用中，推荐使用现有的成熟实现，例如：</p>
<ul>
<li>C++17 起的标准库提供的 <code>std::shared_mutex</code>（标准的读写锁实现）：</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;shared_mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::shared_mutex rw_mutex;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reader</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">std::shared_lock <span class="title">lock</span><span class="params">(rw_mutex)</span></span>; <span class="comment">// 读锁</span></span><br><span class="line">    <span class="comment">// 读取数据</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">writer</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">std::unique_lock <span class="title">lock</span><span class="params">(rw_mutex)</span></span>; <span class="comment">// 写锁</span></span><br><span class="line">    <span class="comment">// 修改数据</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="29-引用和指针的区别，是否能加-const，作用是什么？"><a href="#29-引用和指针的区别，是否能加-const，作用是什么？" class="headerlink" title="29. 引用和指针的区别，是否能加 const，作用是什么？"></a>29. 引用和指针的区别，是否能加 <code>const</code>，作用是什么？</h2><p><strong>指针</strong>：存储变量的内存地址，可以为空（<code>nullptr</code>），需要通过解引用操作符<code>*</code>访问指针指向的值。指针可以在运行时重新指向不同的对象。指针可以有多级。</p>
<p><strong>引用</strong>：是变量的别名，必须在初始化时绑定到一个有效的对象，且绑定后无法更改。引用不能为空，始终指向初始化时绑定的对象。引用只有一级。</p>
<p><code>const</code>修饰：</p>
<ul>
<li><strong>指针</strong>：<code>const</code>可以修饰指针本身或指针指向的对象。<ul>
<li>指向常量的指针：<code>const int* ptr</code> / <code>int const* ptr</code> 表示指针指向的值是常量，不能通过该指针修改值，但可以改变指针本身的指向。</li>
<li>常量指针：<code>int* const ptr</code>表示指针本身是常量，不能改变指针的指向，但可以通过指针修改指向的值。</li>
<li>指向常量的常量指针：<code>const int* const ptr</code>表示指针本身和指针指向的值都是常量，既不能修改指针的指向，也不能修改指向的值。</li>
</ul>
</li>
<li><strong>引用</strong>：<strong>引用本身不能是常量</strong>，但可以引用一个常量对象。<ul>
<li>指向常量的引用：<code>const int&amp; ref</code>表示引用绑定到一个常量值，不能通过该引用修改值。常量引用常用于函数参数，允许函数接受常量或非常量实参而不进行拷贝。</li>
</ul>
</li>
</ul>
<h2 id="30-哈希桶满了怎么办？"><a href="#30-哈希桶满了怎么办？" class="headerlink" title="30. 哈希桶满了怎么办？"></a>30. 哈希桶满了怎么办？</h2><p>哈希表（如 <code>unordered_map</code>）在插入元素后，如果负载因子（<code>load_factor</code>，即元素个数/桶数量）超过阈值（通常是1.0左右），将触发<strong>扩容（rehash）</strong>：</p>
<ul>
<li>重新分配更多的 bucket（一般是原来容量的2倍或更多）。</li>
<li>重新计算元素位置（rehash），将原有元素重新插入新的 bucket 中。</li>
<li>扩容时性能开销较大 $O(n)$。</li>
</ul>
<p>因此，为了减少扩容次数，可以提前使用 <code>reserve</code> 或 <code>rehash</code> 提高效率。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; umap;</span><br><span class="line">umap.<span class="built_in">reserve</span>(<span class="number">1000</span>); <span class="comment">// 提前预留空间，避免频繁扩容</span></span><br></pre></td></tr></tbody></table></figure>

<h2 id="31-AVL-vs-红黑树"><a href="#31-AVL-vs-红黑树" class="headerlink" title="31. AVL vs. 红黑树"></a>31. AVL vs. 红黑树</h2><p><strong>AVL 树</strong>（严格平衡二叉树）：</p>
<ul>
<li>左右子树高度差<strong>绝对不能超过1</strong>。</li>
<li>插入删除频繁时，旋转调整成本较高（严格的平衡限制）。</li>
<li>查询效率略优于红黑树（更平衡），但插入删除的开销稍高。</li>
<li>适用于对查询操作要求极高，但修改频率较低的场景。</li>
</ul>
<p><strong>红黑树</strong>（弱平衡二叉树）：</p>
<ul>
<li>平衡规则相对宽松，允许一定的高度差异。</li>
<li>插入删除操作旋转调整较少，综合效率更高。</li>
<li>广泛应用于 C++ 中的 STL <code>map</code>、<code>set</code> 等数据结构中。</li>
<li>更适用于<strong>插入删除较频繁的场景</strong>。</li>
</ul>
<p>如果场景<strong>读多写少</strong>，要求非常严格的平衡，AVL 树适合。</p>
<p>如果场景<strong>写操作频繁</strong>，对读写整体性能要求更均衡，红黑树更合适。</p>
<h2 id="32-move-底层原理"><a href="#32-move-底层原理" class="headerlink" title="32. move() 底层原理"></a>32. <code>move()</code> 底层原理</h2><p><code>std::move()</code> 的底层原理实际上非常简单，它本身<strong>并不真正执行移动</strong>，而是一个类型转换工具，用来将<strong>左值（lvalue）强制转换为右值引用（rvalue reference）</strong>，从而允许移动语义发生。</p>
<h3 id="一、源码分析（典型实现）"><a href="#一、源码分析（典型实现）" class="headerlink" title="一、源码分析（典型实现）"></a>一、源码分析（典型实现）</h3><p>在C++标准库中，<code>std::move()</code> 一般可实现为如下模板函数：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> std::<span class="type">remove_reference_t</span>&lt;T&gt;&amp;&amp; <span class="title">move</span><span class="params">(T&amp;&amp; arg)</span> <span class="keyword">noexcept</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;std::<span class="type">remove_reference_t</span>&lt;T&gt;&amp;&amp;&gt;(arg);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>上述代码可以解析为：</p>
<ul>
<li><code>T&amp;&amp; arg</code>：这是一个<strong>万能引用</strong>（forwarding reference），能够绑定到左值或右值。</li>
<li><code>remove_reference_t&lt;T&gt;</code>：移除模板参数 <code>T</code> 可能带有的引用限定符，保证返回的确实是一个右值引用类型。</li>
<li><code>static_cast&lt;remove_reference_t&lt;T&gt;&amp;&amp;&gt;</code>：进行强制类型转换，将传入参数从左值转换为右值引用。</li>
</ul>
<h3 id="二、原理分析"><a href="#二、原理分析" class="headerlink" title="二、原理分析"></a>二、原理分析</h3><p><code>std::move()</code> 本身没有发生移动动作，它只是一个<strong>类型转换工具</strong>：</p>
<ul>
<li><strong>转换前</strong>：变量（对象）本身是<strong>左值</strong>，只能调用拷贝构造函数或拷贝赋值。</li>
<li><strong>转换后</strong>：变量变为<strong>右值引用</strong>，具备调用移动构造函数或移动赋值的资格。</li>
</ul>
<p>本质是告诉编译器：“<strong>这里的对象我不再需要了，可以放心进行资源的移动操作。</strong>”</p>
<p>例如：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::string str1 = <span class="string">"Hello"</span>;</span><br><span class="line">std::string str2 = std::<span class="built_in">move</span>(str1);  </span><br><span class="line"><span class="comment">// str1 的内容被“窃取”，str2 可能直接接管内部缓冲区，而非复制</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="三、实际的“移动”如何发生？"><a href="#三、实际的“移动”如何发生？" class="headerlink" title="三、实际的“移动”如何发生？"></a>三、实际的“移动”如何发生？</h3><p>实际的移动（资源转移）是通过被调用对象的<strong>移动构造函数</strong>或<strong>移动赋值运算符</strong>实现的，而不是通过<code>std::move()</code>实现：</p>
<p>例如，<code>std::string</code> 的移动构造函数的伪代码：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 移动构造函数示意</span></span><br><span class="line"><span class="built_in">string</span>(string&amp;&amp; other) <span class="keyword">noexcept</span> {</span><br><span class="line">    data_ = other.data_;</span><br><span class="line">    size_ = other.size_;</span><br><span class="line">    other.data_ = <span class="literal">nullptr</span>;  <span class="comment">// 原对象失去所有权</span></span><br><span class="line">    other.size_ = <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><code>std::move()</code> 提供右值引用，而真正资源转移的逻辑，由类的移动构造或移动赋值完成。</p>
<h3 id="四、注意事项"><a href="#四、注意事项" class="headerlink" title="四、注意事项"></a>四、注意事项</h3><ul>
<li><strong><code>std::move()</code>不会清空对象</strong>：<ul>
<li>调用<code>std::move()</code>后的对象处于有效但<strong>未指定状态</strong>（valid but unspecified state），通常对象变为空或默认状态。</li>
<li>你可以继续赋值或析构，但不应该继续访问对象原先的资源。</li>
</ul>
</li>
<li><strong>移动语义要求类本身支持移动构造或移动赋值</strong>：<ul>
<li>若类本身未定义移动构造或移动赋值，调用<code>std::move()</code> 仍然可能降级成拷贝。</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>问题</th>
<th>结论</th>
</tr>
</thead>
<tbody><tr>
<td><code>std::move()</code>本质是什么？</td>
<td>类型转换函数，从左值转为右值引用</td>
</tr>
<tr>
<td>真正的移动操作在哪里发生？</td>
<td>类的移动构造函数或移动赋值运算符</td>
</tr>
<tr>
<td>调用后原对象的状态？</td>
<td>有效但未指定</td>
</tr>
</tbody></table>
<p><code>std::move()</code> 本身几乎没有开销，它只是一个编译期的类型转换工具，真正的开销和行为由类型本身的移动构造和赋值函数决定。</p>
<h2 id="33-可执行文件加载到内存里，其内存布局是怎样的？"><a href="#33-可执行文件加载到内存里，其内存布局是怎样的？" class="headerlink" title="33. 可执行文件加载到内存里，其内存布局是怎样的？"></a>33. 可执行文件加载到内存里，其内存布局是怎样的？</h2><p>当可执行文件（如Linux ELF格式）加载到内存中运行时，其典型内存布局为：</p>
<p>从低地址到高地址顺序：</p>
<table>
<thead>
<tr>
<th>内存段</th>
<th>功能说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>代码段（text segment）</strong></td>
<td>存放程序的机器指令（只读、可执行）</td>
</tr>
<tr>
<td><strong>数据段（data segment）</strong></td>
<td>已初始化的全局变量和静态变量</td>
</tr>
<tr>
<td><strong>BSS段（bss segment）</strong></td>
<td>未初始化或初值为零的全局变量和静态变量</td>
</tr>
<tr>
<td><strong>堆（Heap）</strong></td>
<td>动态分配的内存（由低地址向高地址增长）</td>
</tr>
<tr>
<td>↕️</td>
<td>（动态增长空间）</td>
</tr>
<tr>
<td><strong>栈（Stack）</strong></td>
<td>函数调用栈帧（由高地址向低地址增长）</td>
</tr>
</tbody></table>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/Wu-yikun/OSS/PicGo/202503260012924.png" alt="虚拟内存空间划分"></p>
<ul>
<li><strong>代码段</strong>：函数指令</li>
<li><strong>数据段</strong>：全局或静态变量（初值不为0）</li>
<li><strong>BSS段</strong>：全局或静态变量（初值为0或未初始化）</li>
<li><strong>堆段</strong>：动态内存（malloc/new）</li>
<li><strong>栈段</strong>：函数调用的局部变量、调用返回地址、临时变量等</li>
<li><strong>文件映射段</strong>：包括动态库、共享内存等，从低地址开始向上增长（跟硬件和内核版本有关）</li>
</ul>
<h2 id="34-宏定义与函数的区别？"><a href="#34-宏定义与函数的区别？" class="headerlink" title="34. 宏定义与函数的区别？"></a>34. 宏定义与函数的区别？</h2><ul>
<li><strong>宏在预处理阶段完成替换</strong>，之后被替换的文本参与编译，相当于直接插入了代码，运行时不存在函数调用，执行起来更快；函数调用在运行时需要跳转到具体调用函数。</li>
<li>宏定义属于在结构中插入代码，没有返回值；函数调用具有返回值。</li>
<li>宏定义参数没有类型，不进行类型检查；函数参数具有类型，需要检查类型。</li>
</ul>
<h2 id="35-宏定义-define-与-typedef-的区别？"><a href="#35-宏定义-define-与-typedef-的区别？" class="headerlink" title="35. 宏定义 define 与 typedef 的区别？"></a>35. 宏定义 <code>define</code> 与 <code>typedef</code> 的区别？</h2><ul>
<li>宏主要用于定义常量及书写复杂的内容；typedef 主要用于定义类型别名。</li>
<li>宏替换发生在编译阶段之前（<strong>预处理阶段</strong>），属于文本插入替换；typedef 是<strong>编译</strong>的一部分。</li>
<li><strong>宏不检查类型；typedef 会检查数据类型</strong>。</li>
<li>注意对指针的操作，<code>typedef char * p_char</code> 和 <code>#define p_char char *</code> 区别巨大。</li>
</ul>
<h2 id="36-变量声明与定义的区别？"><a href="#36-变量声明与定义的区别？" class="headerlink" title="36. 变量声明与定义的区别？"></a>36. 变量声明与定义的区别？</h2><ul>
<li><strong>声明</strong>仅仅是把变量的声明的位置及类型提供给编译器，并不分配内存空间</li>
<li><strong>定义</strong>要在定义的地方为其分配存储空间</li>
</ul>
<p>相同变量可以在多处声明（外部变量 <code>extern</code>），但只能在一处定义。</p>
<h2 id="37-strlen-和-sizeof-的区别？"><a href="#37-strlen-和-sizeof-的区别？" class="headerlink" title="37. strlen 和 sizeof 的区别？"></a>37. strlen 和 sizeof 的区别？</h2><ul>
<li>sizeof 参数可以是任何数据的类型或者数据（sizeof 参数不退化）</li>
<li>strlen 参数只能是字符指针且结尾是’\0’的字符串</li>
</ul>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* str = <span class="string">"Hello World"</span>;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">sizeof</span>(str) &lt;&lt; endl;    <span class="comment">// 指针字节：8</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">strlen</span>(str) &lt;&lt; endl;    <span class="comment">// 字符串长度(不包含'\0')：11</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="38-final-和-override"><a href="#38-final-和-override" class="headerlink" title="38. final 和 override"></a>38. final 和 override</h2><ul>
<li><code>override</code>：指定了子类的这个虚函数是重写的父类的，如果你名字不小心打错了的话，编译器是不会编译通过的</li>
<li><code>final</code>：当某个类不希望被继承，或者某个虚函数不希望被重写，那么可以在类名和虚函数后添加 <code>final</code> 关键字，添加 final 关键字后被继承或重写，编译器会报错</li>
</ul>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> {</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line">};</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> : <span class="keyword">public</span> Base {</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> <span class="keyword">final</span></span>; <span class="comment">// foo 被 override 并且是最后一个 override，在其子类中不可以重写</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指明 B 是不可以被继承的</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">final</span> : <span class="keyword">public</span> A {</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> <span class="keyword">override</span></span>; <span class="comment">// Error: 在 A 中已经被 final 了</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// Error: B is final</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">public</span> B {</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<h2 id="39-C-与-C-的类型安全"><a href="#39-C-与-C-的类型安全" class="headerlink" title="39. C 与 C++ 的类型安全"></a>39. C 与 C++ 的类型安全</h2><p>类型安全很大程度上可以等价于内存安全，类型安全的代码不会试图访问自己没被授权的内存区域。<strong>“类型安全”常被用来形容编程语言，其根据在于该门编程语言是否提供保障类型安全的机制</strong>；有的时候也用“类型安全”形容某个程序，判别的标准在于该程序是否隐含类型错误。</p>
<p>类型安全的编程语言与类型安全的程序之间，没有必然联系。好的程序员可以使用类型不那么安全的语言写出类型相当安全的程序，相反的，差一点儿的程序员可能使用类型相当安全的语言写出类型不太安全的程序。绝对类型安全的编程语言暂时还没有。</p>
<h3 id="C-的类型安全"><a href="#C-的类型安全" class="headerlink" title="C 的类型安全"></a>C 的类型安全</h3><p>C 只在局部上下文中表现出类型安全，比如试图从一种结构体的指针转换成另一种结构体的指针时，编译器将会报告错误，除非使用显式类型转换。然而，C 中相当多的操作是不安全的。以下是两个十分常见的例子：</p>
<p>1️⃣ printf 格式输出：下述代码中，使用 <code>%d</code> 控制整型数字的输出，没有问题，但是改成 <code>%f</code> 时，明显输出错误，再改成 <code>%s</code> 时，运行直接报 <strong>segmentation fault 错误</strong></p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> {</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, <span class="number">10</span>);    <span class="comment">// 10</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%f\n"</span>, <span class="number">10</span>);    <span class="comment">// 0.00</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>2️⃣ malloc 函数返回值：<code>malloc</code> 是 C 中进行内存分配的函数，它的返回类型是 <code>void*</code> 即空类型指针，常常有这样的用法 <code>char* pStr = (char*)malloc(100 * sizeof(char))</code>，<strong>这里明显做了显式的类型转换</strong>。类型匹配尚且没有问题，但是一旦出现 <code>int* pInt = (int*)malloc(100 * sizeof(char))</code> 就很可能带来一些问题，而这样的转换 C 并不会提示错误。</p>
<h3 id="C-类型安全"><a href="#C-类型安全" class="headerlink" title="C++ 类型安全"></a>C++ 类型安全</h3><p>如果 C++ 使用得当，它将远比 C 更有类型安全性。相比于 C 语言，C++ 提供了一些新的机制保障类型安全：</p>
<ul>
<li>操作符 new 返回的指针类型严格与对象匹配，而不是 <code>void*</code></li>
<li>C 中很多以 <code>void*</code> 为参数的函数可以改写为 C++ 模板函数，而模板是支持类型检查的</li>
<li>引入 <code>const</code> 关键字代替 <code>#define constants</code>，它是有类型、有作用域的，而 <code>#define constants</code> 只是简单的文本替换</li>
<li>一些 <code>#define</code> 宏可被改写为 <code>inline</code> 函数，结合函数的重载，可在类型安全的前提下支持多种类型，当然改写为模板也能保证类型安全</li>
<li>C++ 提供了 <code>dynamic_cast</code> 关键字，使得转换过程更加安全，因为 <code>dynamic_cast</code> 比 <code>static_cast</code> 涉及更多具体的类型检查</li>
</ul>
<h2 id="40-内联函数-inline-和宏定义-define-的区别？"><a href="#40-内联函数-inline-和宏定义-define-的区别？" class="headerlink" title="40. 内联函数 inline 和宏定义 define 的区别？"></a>40. 内联函数 <code>inline</code> 和宏定义 <code>define</code> 的区别？</h2><ul>
<li>在使用时，宏只做简单字符串替换（预处理，即编译前）；而内联函数可以进行参数类型检查（编译时），且具有返回值</li>
<li>内联函数在编译时直接将函数代码嵌入到目标代码中，<strong>省去函数调用的开销来提高执行效率</strong>，并且进行参数类型检查，具有返回值，可以实现重载</li>
<li>宏定义时要注意书写（参数要括起来）否则容易出现歧义，内联函数不会产生歧义</li>
<li>内联函数有类型检测、语法判断等功能，而宏没有</li>
</ul>
<p><strong>内联函数适用场景:</strong></p>
<ul>
<li>使用宏定义的地方都可以使用 inline 函数</li>
<li>作为类成员接口函数来读写类的私有成员或者保护成员，会提高效率</li>
</ul>
<h2 id="41-什么是大小端存储，以及如何用代码判断大小端？"><a href="#41-什么是大小端存储，以及如何用代码判断大小端？" class="headerlink" title="41. 什么是大小端存储，以及如何用代码判断大小端？"></a>41. 什么是大小端存储，以及如何用代码判断大小端？</h2><p>大端存储：字数据的高字节存储在低地址中</p>
<p>小端存储：字数据的低字节存储在低地址中</p>
<p>例如：32bit 的数字 0x12345678</p>
<p><strong>所以在 Socket 编程中，往往需要将操作系统所用的小端存储的 IP 地址转换为大端存储，这样才能进行网络传输</strong></p>
<blockquote>
<p>小端模式中的存储方式为</p>
</blockquote>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/Wu-yikun/OSS/PicGo/202503260131145.png" alt="img"></p>
<blockquote>
<p>大端模式中的存储方式为</p>
</blockquote>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/Wu-yikun/OSS/PicGo/202503260132626.png" alt="img"></p>
<p>了解了大小端存储的方式，如何在代码中进行判断呢？</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">int</span> a = <span class="number">0x1234</span>;</span><br><span class="line">    <span class="comment">//由于 int 和 char 的长度不同，借助 int 型转换成 char 型，只会留下低地址的部分</span></span><br><span class="line">    <span class="type">char</span> c = (<span class="type">char</span>)(a);</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0x12</span>)</span><br><span class="line">        cout &lt;&lt; <span class="string">"big endian"</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="number">0x34</span>)</span><br><span class="line">        cout &lt;&lt; <span class="string">"little endian"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="42-C-中有几种类型的-new？"><a href="#42-C-中有几种类型的-new？" class="headerlink" title="42. C++ 中有几种类型的 new？"></a>42. C++ 中有几种类型的 <code>new</code>？</h2><h3 id="1-plain-new"><a href="#1-plain-new" class="headerlink" title="(1) plain new"></a>(1) plain new</h3><p>言下之意就是普通的new，就是我们常用的new，在C++中定义如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="type">size_t</span>)</span> <span class="title">throw</span><span class="params">(std::bad_alloc)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span> *)</span> <span class="title">throw</span><span class="params">()</span></span>;</span><br></pre></td></tr></tbody></table></figure>

<p>因此 <strong>plain new</strong> 在空间分配失败的情况下，抛出异常 <strong>std::bad_alloc</strong> 而不是返回 NULL，因此通过判断返回值是否为 NULL 是徒劳的。</p>
<h3 id="2-nothrow-new"><a href="#2-nothrow-new" class="headerlink" title="(2) nothrow new"></a>(2) nothrow new</h3><p>nothrow new 在空间分配失败的情况下是不抛出异常，而是返回 NULL，定义如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> * <span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="type">size_t</span>, <span class="type">const</span> std::<span class="type">nothrow_t</span>&amp;)</span> <span class="title">throw</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span>*)</span> <span class="title">throw</span><span class="params">()</span></span>;</span><br></pre></td></tr></tbody></table></figure>

<h3 id="3-placement-new"><a href="#3-placement-new" class="headerlink" title="(3) placement new"></a>(3) placement new</h3><blockquote>
<p>字节校招问题：<strong>placement new</strong> 是什么？</p>
<ul>
<li>一般来说，使用 new 申请空间时，是从系统的“堆”中分配空间。申请所得的空间的位置是根据当时的内存的实际使用情况决定的。但是，在某些特殊情况下，<strong>可能需要在已分配的特定内存创建对象</strong>，这就是所谓的 “定位放置 new” （<code>placement new</code>）操作。 定位放置 new 操作的语法形式不同于普通的 new 操作。例如，一般都用如下语句 <code>A* p = new A;</code> 申请空间，而 placement new 操作则使用如下语句 <code>A* p = new (ptr)A;</code> 申请空间，其中 <code>ptr</code> 就是程序员指定的<strong>内存首地址</strong>。</li>
<li>用定位放置 new 操作，既可以在栈（stack）上生成对象，也可以在堆（heap）上生成对象，如本例就是在栈上生成一个对象。</li>
<li>优势：<strong>复用已有内存空间</strong>；</li>
<li>场景题：如果有这样一个场景，我们需要大量的申请一块类似的内存空间，然后又释放掉，比如在一个 Server 中对于客户端的请求，每个客户端的每一次上行数据我们都需要为此申请一块内存，当我们处理完请求给客户端下行回复时释放掉该内存，表面上看者符合 C++ 的内存管理要求，没有什么错误，但是仔细想想很不合理，<strong>为什么我们每个请求都要重新申请一块内存呢，要知道每一次内存的申请，系统都要在内存中找到一块合适大小的连续的内存空间，这个过程是很慢的（相对而言)，极端情况下，如果当前系统中有大量的内存碎片，并且我们申请的空间很大，甚至有可能失败。为什么我们不能共用一块我们事先准备好的内存呢？可以的，我们可以使用 <code>placement new</code> 来构造对象，那么就会在我们指定的内存空间中构造对象。</strong></li>
</ul>
</blockquote>
<p>这种 new 允许在一块已经分配成功的内存上重新构造对象或对象数组。placement new 不用担心内存分配失败，因为它根本不分配内存，它做的唯一一件事情就是调用对象的构造函数。定义如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span>, <span class="type">void</span>*)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span>*, <span class="type">void</span>*)</span></span>;</span><br></pre></td></tr></tbody></table></figure>

<p>使用 <code>placement new</code> 需要注意两点：</p>
<ul>
<li>palcement new 的主要用途就是反复使用一块较大的动态分配的内存来构造不同类型的对象或者他们的数组</li>
<li>placement new 构造起来的对象数组，要显式的调用他们的析构函数来销毁（析构函数并不释放对象的内存），千万不要使用 <code>delete</code>，这是因为 placement new 构造起来的对象或数组大小并不一定等于原来分配的内存大小，使用 delete 会造成内存泄漏或者之后释放内存时出现运行时错误</li>
</ul>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ADT</span> {</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ADT</span>() {</span><br><span class="line">        i = <span class="number">10</span>;</span><br><span class="line">        j = <span class="number">100</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">"ADT construct i="</span> &lt;&lt; i &lt;&lt; <span class="string">" j="</span>&lt;&lt;j &lt;&lt;endl;</span><br><span class="line">    }</span><br><span class="line">    ~<span class="built_in">ADT</span>() {</span><br><span class="line">        cout &lt;&lt; <span class="string">"ADT destruct"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="type">char</span> *p = <span class="built_in">new</span>(nothrow) <span class="type">char</span>[<span class="keyword">sizeof</span> ADT + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"alloc failed"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">    ADT *q = <span class="built_in">new</span>(p) ADT;  <span class="comment">//placement new:不必担心失败，只要p所指对象的的空间足够ADT创建即可</span></span><br><span class="line">    <span class="comment">//delete q;//错误!不能在此处调用delete q;</span></span><br><span class="line">    q-&gt;ADT::~<span class="built_in">ADT</span>();<span class="comment">//显示调用析构函数</span></span><br><span class="line">    <span class="keyword">delete</span>[] p;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//ADT construct i=10 j=100</span></span><br><span class="line"><span class="comment">//ADT destruct</span></span><br></pre></td></tr></tbody></table></figure>

<h2 id="43-C-11-新特性有哪些？"><a href="#43-C-11-新特性有哪些？" class="headerlink" title="43. C++ 11 新特性有哪些？"></a>43. C++ 11 新特性有哪些？</h2><ol>
<li><strong>自动类型推导（<code>auto</code> 关键字）</strong>：编译器可根据变量初始化表达式自动推导其类型，简化代码编写。</li>
<li><strong><code>decltype</code> 关键字</strong>：用于获取表达式的类型，常与 <code>auto</code> 结合使用，以推导复杂类型。</li>
<li><strong>右值引用和移动语义、<code>move</code> 函数</strong>：通过右值引用（<code>&amp;&amp;</code>）支持移动构造和移动赋值，提高资源管理和程序性能。</li>
<li><strong>初始化列表</strong>：引入统一的列表初始化语法，允许使用花括号对变量进行初始化，增强初始化的灵活性和可读性。</li>
<li><strong><code>nullptr</code> 关键字</strong>：引入新的空指针常量，替代原有的 <code>NULL</code>，提高类型安全性。</li>
<li><strong>强类型枚举（<code>enum class</code>）</strong>：提供作用域限定的枚举类型，避免与其他标识符冲突，并增强类型安全性。</li>
<li><strong><code>constexpr</code> 关键字</strong>：允许在编译期计算常量表达式，提高程序效率。</li>
<li><strong>Lambda 表达式</strong>：支持匿名函数，方便定义内联的回调或操作，简化代码结构。</li>
<li><strong>范围 <code>for</code> 循环</strong>：引入基于范围的 <code>for</code> 循环，简化对容器或数组的遍历操作。</li>
<li><strong>智能指针</strong>：新增 <code>std::unique_ptr</code> 和改进的 <code>std::shared_ptr</code>，提供安全的资源管理机制，减少内存泄漏风险。</li>
<li><strong>线程支持库</strong>：标准库中加入多线程支持，包括线程管理、互斥量、条件变量等，方便进行并发编程。</li>
<li><strong><code>std::tuple</code></strong>：提供固定大小的多元组，允许存储多个不同类型的值，增强数据结构的表达能力。</li>
<li><strong>正则表达式库</strong>：标准库新增正则表达式支持，方便进行字符串匹配和处理。</li>
<li><strong><code>std::array</code></strong>：提供固定大小的数组封装，结合了数组的性能和容器的功能性。</li>
<li><strong><code>std::unordered_map</code> 和 <code>std::unordered_set</code></strong>：新增无序关联容器，基于哈希表实现，提供平均常数时间的查找和插入性能。</li>
<li><strong><code>std::chrono</code> 时间库</strong>：引入时间处理库，提供时钟、时间点、时间间隔等功能，方便进行时间相关的操作。</li>
<li><strong><code>static_assert</code></strong>：在编译期进行断言检查，确保代码满足特定条件，提高代码的可靠性。</li>
<li><strong><code>std::function</code> 和 <code>std::bind</code></strong>：提供通用的函数包装器和绑定器，支持函数对象、成员函数和自由函数的统一调用。</li>
<li><strong>用户定义字面量</strong>：允许为标准类型和自定义类型定义字面量后缀，增强代码的可读性和表达能力。</li>
<li><strong><code>alignas</code> 和 <code>alignof</code> 关键字</strong>：提供对齐控制和查询功能，确保数据在内存中的对齐方式符合特定要求。</li>
<li><strong><code>explicit</code> 关键字</strong>：体现显示转换和隐式转换上的概念要求</li>
<li><code>std::atomic&lt;T&gt;</code> 是 C++11 引入的原子类型，用于在多线程中安全地读写变量</li>
<li>还有虚函数 <code>override</code>、容器非成员函数 <code>swap</code>、新的 <code>bitset</code> 位运算…</li>
</ol>
<h2 id="44-C-class-与-C-struct-的区别？"><a href="#44-C-class-与-C-struct-的区别？" class="headerlink" title="44. C++ class 与 C struct 的区别？"></a>44. C++ class 与 C struct 的区别？</h2><blockquote>
<p>C 语言不支持继承和多态</p>
</blockquote>
<p>1️⃣ 默认访问权限不同</p>
<ul>
<li><strong>C <code>struct</code> 默认权限为 public</strong></li>
<li><strong>C++ <code>class</code> 默认权限为 private</strong></li>
<li>C++ <code>struct</code> 默认权限 public</li>
</ul>
<p>2️⃣ 成员函数</p>
<ul>
<li>C++ 中的 <code>struct</code> 和 <code>class</code> 都可包含成员函数</li>
<li>C 中的 <code>struct</code> 只能包含数据，<strong>不能包含成员函数</strong></li>
</ul>
<p>C++ 的 <code>class</code> 与 <code>struct</code> 都支持模板、虚函数、多态、构造函数、析构函数、重载操作符等高级特性，这些都是 C 中 <code>struct</code> 不具备的功能。</p>
<hr>
<p>以上谈论的是 C struct 和 C++ class 的区别，接下来聊一聊 C++ struct 和 C++ class 的区别。</p>
<p>在 <strong>C++ 中</strong>，<code>class</code> 和 <code>struct</code> 的功能几乎是等价的（除了默认访问权限不同），继承时：</p>
<ul>
<li>struct 的继承默认是 public 继承</li>
<li>class 的继承默认是 private 继承</li>
</ul>
<p>通常情况下，如果类主要用于表示<strong>数据结构</strong>，不需要封装和访问控制，且所有成员均为 <code>public</code>，则常用 <code>struct</code>；如果强调<strong>封装、访问控制</strong>，需要私有或受保护成员时，则倾向于用 <code>class</code>。</p>
<h2 id="45-怎么优化系统性能"><a href="#45-怎么优化系统性能" class="headerlink" title="45. 怎么优化系统性能"></a>45. 怎么优化系统性能</h2><ol>
<li>合理使用缓存机制，如内存缓存、Redis 等</li>
<li>利用多线程或多进程技术，让更多的处理器核心参与计算，提升吞吐量</li>
<li>选择高效的算法和数据结构可以显著提升系统性能</li>
<li>编写高质量的代码，避免冗余计算，减少函数调用和内存分配，合理使用同步和异步操作</li>
<li>采用集群等高可用架构，避免单点故障，确保系统在高负载下仍能稳定运行</li>
<li>负载均衡，通过将请求分配到多台服务器上，避免单一服务器的性能瓶颈</li>
<li>使用消息队列实现高并发下的异步处理，削峰填谷，缓解系统压力</li>
<li><code>perf</code> 工具查看系统性能瓶颈</li>
<li>开启编译优化 <code>-O2</code>、<code>-O3</code></li>
</ol>
<p>以下展开介绍几个主要的优化点。</p>
<h3 id="内存管理优化"><a href="#内存管理优化" class="headerlink" title="内存管理优化"></a>内存管理优化</h3><p><strong>减少内存分配与释放次数：</strong> 频繁的堆内存分配和释放会严重拖慢程序，甚至导致内存碎片。应尽量重用对象、使用内存池等技术来降低分配开销。例如，在 C++ 中可以实现<strong>对象池</strong>，预先分配一定数量的对象，在需要时复用它们而不是每次 <code>new</code> 和 <code>delete</code>。对于生命周期较短且数量巨大的对象，尽可能分配在栈上而非堆上，因为栈上的分配/回收开销远小于堆（注意栈有大小限制，过大的对象还是要放在堆上）。在 Java/Python 等有垃圾回收的语言中，无法手动管理内存，但可以通过减少不必要的临时对象创建来减轻 GC 压力。</p>
<p><strong>避免不必要的数据拷贝</strong>：数据拷贝不仅耗费 CPU 时间，还增加内存占用。在C/C++中，尽量通过指针、引用传递大对象，或使用移动语义（<code>std::move</code>）来避免昂贵的深拷贝。例如，将函数参数改为 <code>const std::vector&lt;T&gt;&amp;</code> 引用而不是传值，可以省去一遍拷贝的成本。</p>
<p><strong>提高内存访问局部性：</strong> 尽量使用连续内存的数据结构，有利于 CPU 缓存命中率。例如，相比链表，数组或动态数组（如 <code>std::vector</code>）在遍历时连续访问内存，对缓存更友好。访问内存时，如果数据分散，CPU缓存无法有效预取，性能会下降。因此，应尽量使常用的数据在内存中连续存放。对于需要处理大批量数据的场景，可以考虑将“数组的结构”转变为“结构的数组”以提高向量化和缓存性能。这种优化在需要对大量对象的某个字段进行批量操作时特别有效，因为连续的内存布局可以充分利用 SIMD 指令和缓存行。</p>
<p><strong>控制内存使用与回收：</strong> 注意避免<strong>内存泄漏</strong>和不必要的内存占用。未释放的内存不仅浪费资源，还可能导致系统频繁进行垃圾回收或交换，从而严重影响性能。应使用恰当的数据结构来节省内存，例如在需要存储大量布尔值时使用位图/位集而不是布尔数组。</p>
<h3 id="I-O-优化"><a href="#I-O-优化" class="headerlink" title="I/O 优化"></a>I/O 优化</h3><p>尽量减少 I/O 调用次数： 外部I/O（磁盘读写、网络通信）往往比内存操作慢几个数量级。优化I/O的一个基本原则是减少系统调用频次。例如，与其逐字节写入文件，不如积累一定数据后一次写入（批处理）；读文件时尽量使用批量读取或流式读取来降低调用开销。将零散的小I/O操作合并为较少的几次大操作，可以大幅降低每次调用的固定成本，提高总体吞吐量。</p>
<p>使用缓冲和缓存： </p>
<ul>
<li>缓冲是在内存中暂存数据，凑够一定量再进行 I/O</li>
<li>缓存则是将经常访问的数据暂存内存，以避免重复从慢速存储获取</li>
</ul>
<p>异步和并行 I/O： 传统同步I/O会阻塞执行线程，等待操作完成。通过异步 I/O，程序可以在等待I/O的同时去处理其他任务，从而提高整体效率和响应性。另外，对于磁盘 I/O 密集型任务，合理利用操作系统的内存映射文件（mmap）也能提升效率，因为操作系统会自动预读和缓存文件内容，且内存映射减少了用户态/内核态的数据拷贝。</p>
<h3 id="性能分析与瓶颈定位"><a href="#性能分析与瓶颈定位" class="headerlink" title="性能分析与瓶颈定位"></a>性能分析与瓶颈定位</h3><p>在展开具体优化工作之前，<strong>识别性能瓶颈</strong>是关键的一步。盲目优化往往事倍功半，甚至优化了非瓶颈部分而徒增代码复杂度。因此建议利用各种分析工具（Profiler）来定位程序中的“热区”和问题点。</p>
<ul>
<li><strong>CPU Profiling</strong>：常用 GNU gprof 工具对应用程序进行采样分析，生成函数级别的耗时报告。在Linux上可以使用 <code>perf</code> 工具对程序采集更底层的性能数据（如CPU周期、缓存未命中等）。跨平台的工具如 Intel VTune, AMD uProf 提供更高级的性能分析（包括线程并发、微架构瓶颈）。另外，Valgrind 的 Callgrind 模块也能分析代码热点和调用关系，并可借助KCachegrind等可视化工具查看分析结果。</li>
<li><strong>内存和资源分析</strong>：使用 Valgrind 的 Memcheck 工具可以检测内存泄漏和非法内存访问，这有助于消除由于内存问题导致的异常行为和性能下降。Massif 是 Valgrind 的堆分析器，可以跟踪程序堆内存使用随时间的变化，找出高峰时占用大的代码路径。对于更复杂的内存分析，可以借助 Google Perf Tools（gperftools）中的 heap profiler 或 Dr. Memory 等工具。在需要分析缓存行为时，Valgrind 的 Cachegrind 模块可以模拟CPU缓存，报告缓存命中率，帮助调整数据结构以提高缓存友好度。</li>
</ul>
<h2 id="46-说说移动构造函数与拷贝构造函数"><a href="#46-说说移动构造函数与拷贝构造函数" class="headerlink" title="46. 说说移动构造函数与拷贝构造函数"></a>46. 说说移动构造函数与拷贝构造函数</h2><ol>
<li>我们用对象 a 初始化对象 b，之后对象 a 我们就不再使用了，但是对象 a 的空间还在（在析构之前），既然拷贝构造函数实际上就是把 a 对象的内容复制一份到 b 中，那么为什么我们不能直接使用 a 的空间呢？这样就避免了新的空间的分配，大大降低了构造的成本。这就是移动构造函数设计的初衷。</li>
<li>‼️<strong>拷贝构造函数中，对于指针，我们一定要采用深拷贝</strong>；而<strong>移动构造函数中，对于指针，我们采用浅拷贝</strong>。</li>
<li>移动构造函数的参数 <code>&amp;&amp;</code> 和拷贝构造函数 <code>&amp;</code> 不同：拷贝构造函数的参数是一个左值引用，但是移动构造函数的初值是一个右值引用。意味着，移动构造函数的参数是一个右值或者将亡值的引用。也就是说，只用一个<strong>右值</strong>或者<strong>将亡值</strong>初始化另一个对象的时候，才会调用移动构造函数。<strong>而那个 <code>move()</code> 语句，就是将一个左值变成一个将亡值</strong>。</li>
</ol>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyString</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">MyString</span>() : <span class="built_in">str</span>(<span class="literal">nullptr</span>), <span class="built_in">len</span>(<span class="number">0</span>) {}</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">MyString</span>(<span class="type">const</span> <span class="type">char</span>* s) : <span class="built_in">str</span>(<span class="literal">nullptr</span>), <span class="built_in">len</span>(<span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">if</span> (s != <span class="literal">nullptr</span>) {</span><br><span class="line">            len = <span class="built_in">strlen</span>(s);</span><br><span class="line">            str = <span class="keyword">new</span> <span class="type">char</span>[len + <span class="number">1</span>];</span><br><span class="line">            <span class="built_in">strcpy</span>(str, s);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拷贝构造函数: 有指针则采用深拷贝</span></span><br><span class="line">    <span class="built_in">MyString</span>(<span class="type">const</span> MyString&amp; other) : <span class="built_in">str</span>(<span class="literal">nullptr</span>), <span class="built_in">len</span>(<span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">if</span> (other.str != <span class="literal">nullptr</span>) {</span><br><span class="line">            len = other.len;</span><br><span class="line">            str = <span class="keyword">new</span> <span class="type">char</span>[len + <span class="number">1</span>];</span><br><span class="line">            <span class="built_in">strcpy</span>(str, other.str);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移动构造函数: 采用浅拷贝</span></span><br><span class="line">    <span class="built_in">MyString</span>(MyString&amp;&amp; other) <span class="keyword">noexcept</span> {</span><br><span class="line">        str = other.str;</span><br><span class="line">        len = other.len;</span><br><span class="line">        other.str = <span class="literal">nullptr</span>;</span><br><span class="line">        other.len = <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">MyString</span>() {</span><br><span class="line">        <span class="keyword">if</span> (str != <span class="literal">nullptr</span>) {</span><br><span class="line">            <span class="keyword">delete</span>[] str;</span><br><span class="line">            str = <span class="literal">nullptr</span>;</span><br><span class="line">            len = <span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span>* str;</span><br><span class="line">    <span class="type">size_t</span> len;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">MyString <span class="title">s1</span><span class="params">(<span class="string">"Hello"</span>)</span></span>;           <span class="comment">// 调用构造函数</span></span><br><span class="line">    <span class="function">MyString <span class="title">s2</span><span class="params">(s1)</span></span>;               <span class="comment">// 调用拷贝构造函数</span></span><br><span class="line">    <span class="function">MyString <span class="title">s3</span><span class="params">(std::move(s1))</span></span>;  <span class="comment">// 调用移动构造函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="47-C-中指针参数传递和引用参数传递有什么区别？底层原理是什么？"><a href="#47-C-中指针参数传递和引用参数传递有什么区别？底层原理是什么？" class="headerlink" title="47. C++ 中指针参数传递和引用参数传递有什么区别？底层原理是什么？"></a>47. C++ 中指针参数传递和引用参数传递有什么区别？底层原理是什么？</h2><blockquote>
<p>恍然大悟</p>
</blockquote>
<h3 id="1-指针参数传递本质上是值传递，它所传递的是一个地址值"><a href="#1-指针参数传递本质上是值传递，它所传递的是一个地址值" class="headerlink" title="(1) 指针参数传递本质上是值传递，它所传递的是一个地址值"></a>(1) 指针参数传递本质上是值传递，它所传递的是一个地址值</h3><p>值传递过程中，被调函数的形式参数作为被调函数的局部变量处理，会在栈中开辟内存空间以存放由主调函数传递进来的实参值，从而形成了实参的一个副本（替身）。</p>
<p>值传递的特点是，被调函数对形式参数的任何操作都是作为局部变量进行的，不会影响主调函数的实参变量的值（<strong>即使是形参指针地址变了，实参指针地址都不会变</strong>）。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">changePointer</span><span class="params">(<span class="type">int</span>* ptr)</span> </span>{</span><br><span class="line">    <span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line">    ptr = &amp;b;  <span class="comment">// 仅改变了形参指针的指向，实参指针不变</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span>* p = &amp;a;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">"Before function call: "</span> &lt;&lt; *p &lt;&lt; endl;  <span class="comment">// 输出 10</span></span><br><span class="line">    <span class="built_in">changePointer</span>(p);</span><br><span class="line">    cout &lt;&lt; <span class="string">"After function call: "</span> &lt;&lt; *p &lt;&lt; endl;   <span class="comment">// 仍然输出 10，不是 20</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="2-引用参数传递过程中，被调函数的形式参数也作为局部变量在栈中开辟了内存空间，但是这时存放的是由主调函数放进来的实参变量的地址"><a href="#2-引用参数传递过程中，被调函数的形式参数也作为局部变量在栈中开辟了内存空间，但是这时存放的是由主调函数放进来的实参变量的地址" class="headerlink" title="(2) 引用参数传递过程中，被调函数的形式参数也作为局部变量在栈中开辟了内存空间，但是这时存放的是由主调函数放进来的实参变量的地址"></a>(2) 引用参数传递过程中，被调函数的形式参数也作为局部变量在栈中开辟了内存空间，但是这时存放的是由主调函数放进来的实参变量的地址</h3><p>被调函数对形参（本体）的任何操作都被处理成间接寻址，即通过栈中存放的地址访问主调函数中的实参变量（根据<strong>别名</strong>找到主调函数中的本体）。</p>
<p>因此，<strong>被调函数对形参的任何操作都会影响主调函数中的实参变量</strong>。</p>
<h3 id="二者区别"><a href="#二者区别" class="headerlink" title="二者区别"></a>二者区别</h3><p><strong>1)</strong> 引用传递和指针传递是不同的，虽然他们都是在被调函数栈空间上的一个局部变量：</p>
<ul>
<li>但是任何对于<strong>引用参数</strong>的处理都会通过一个间接寻址的方式操作到主调函数中的相关变量。</li>
<li>而对于<strong>指针传递的参数</strong>，如果改变被调函数中的指针地址，它将应用不到主调函数的相关变量。🔥 如果想通过指针参数传递来改变主调函数中的相关变量（地址），那就得使用<strong>指向指针的指针</strong>或者<strong>指针引用</strong>。</li>
</ul>
<p><strong>2)</strong> 从编译的角度来讲，程序在编译时分别将指针和引用添加到符号表上，符号表中记录的是变量名及变量所对应地址。</p>
<ul>
<li>指针变量在符号表上对应的地址值为指针变量的地址值，而引用在符号表上对应的地址值为引用对象的地址值（与实参名字不同，地址相同）。</li>
<li>符号表生成之后就不会再改，因此指针可以改变其指向的对象（指针变量中的值可以改），而引用对象则不能修改。</li>
</ul>
<h2 id="48-C-中类成员的访问权限和继承权限问题"><a href="#48-C-中类成员的访问权限和继承权限问题" class="headerlink" title="48. C++ 中类成员的访问权限和继承权限问题"></a>48. C++ 中类成员的访问权限和继承权限问题</h2><h3 id="访问权限"><a href="#访问权限" class="headerlink" title="访问权限"></a>访问权限</h3><p>① <code>public</code>: 用该关键字修饰的成员表示公有成员，该成员不仅可以在类内可以被访问，在类外也是可以被访问的，是类对外提供的可访问接口；</p>
<p>② <code>private</code>: 用该关键字修饰的成员表示私有成员，该成员仅在类内可以被访问，在类体外是隐藏状态；</p>
<p>③ <code>protected</code>: 用该关键字修饰的成员表示保护成员，保护成员在类体外同样是隐藏状态，但是对于该类的派生类来说，相当于公有成员，在派生类中可以被访问。</p>
<h3 id="继承方式"><a href="#继承方式" class="headerlink" title="继承方式"></a>继承方式</h3><p>① 若继承方式是 <code>public</code>，<strong>基类成员在派生类中的访问权限保持不变</strong>，也就是说，基类中的成员访问权限，在派生类中仍然保持原来的访问权限；</p>
<p>② 若继承方式是 <code>private</code>，基类所有成员在派生类中的访问权限都会变为私有 (private) 权限；</p>
<p>③ 若继承方式是 <code>protected</code>，基类的共有成员 <code>public</code> 和保护成员 <code>protected</code> 在派生类中的访问权限都会变为保护 (protected) 权限，私有成员在派生类中的访问权限仍然是私有 (private) 权限。</p>
<h2 id="49-定义与声明的区别"><a href="#49-定义与声明的区别" class="headerlink" title="49. 定义与声明的区别"></a>49. 定义与声明的区别</h2><p>如果是指「变量」的声明和定义： </p>
<ul>
<li>从编译原理上来说，<strong>声明</strong>是仅仅告诉编译器，有个某类型的变量会被使用，但是编译器并不会为它分配任何内存。</li>
<li>而<strong>定义</strong>就是分配了内存。</li>
</ul>
<p>如果是指「函数」的声明和定义： </p>
<ul>
<li>声明：一般在头文件里，对编译器说我有一个函数叫 <code>function()</code> 让编译器知道这个函数的存在。 </li>
<li>定义：一般在源文件里，具体就是函数的实现过程写明函数体。</li>
</ul>
<h2 id="50-你知道-strcpy-与-memcpy-的区别吗"><a href="#50-你知道-strcpy-与-memcpy-的区别吗" class="headerlink" title="50. 你知道 strcpy 与 memcpy 的区别吗"></a>50. 你知道 strcpy 与 memcpy 的区别吗</h2><p>1、复制的内容不同：</p>
<ul>
<li><code>strcpy</code> 只能复制字符串</li>
<li>而 <code>memcpy</code> 可以复制任意内容，例如字符数组、整型、结构体、类等</li>
</ul>
<p>2、复制的方法不同：</p>
<ul>
<li><code>strcpy</code> 不需要指定长度，它遇到被复制字符的串结束符 <code>"\0"</code> 才结束，所以容易溢出</li>
<li><code>memcpy</code> 则是根据其第 3 个参数决定复制的长度。</li>
</ul>
<p>3、用途不同：</p>
<ul>
<li>通常在复制字符串时用 <code>strcpy</code></li>
<li>而需要复制其他类型数据时则一般用 <code>memcpy</code></li>
</ul>
<h2 id="51-volatile-关键字的作用"><a href="#51-volatile-关键字的作用" class="headerlink" title="51. volatile 关键字的作用"></a>51. volatile 关键字的作用</h2><h3 id="面试回答"><a href="#面试回答" class="headerlink" title="面试回答"></a>面试回答</h3><p><code>volatile</code> 的意思是“脆弱的”，表明它修饰的变量的值十分容易被改变，所以编译器就不会对这个变量进行优化（CPU 的优化是让该变量存放到 CPU 寄存器而不是内存），进而提供稳定的访问。每次读取 <code>volatile</code> 的变量时，系统总是会从内存中读取这个变量，并且将它的值立刻保存。</p>
<h3 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h3><p>C/C++ 中的 volatile 关键字和 const 对应，用来修饰变量，通常用于建立语言级别的 memory barrier。</p>
<p><code>volatile</code> 关键字是一种类型修饰符，用它声明的类型变量<strong>表示可以被某些编译器未知的因素更改</strong>，比如：操作系统、硬件或者其它线程等。遇到这个关键字声明的变量，编译器对访问该变量的代码就不再进行优化，从而可以提供对特殊地址的稳定访问。声明时语法：<code>int volatile vInt</code>; 当要求使用 volatile 声明的变量的值的时候，<strong>系统总是重新从它所在的内存读取数据</strong>，即使它前面的指令刚刚从该处读取过数据。而且读取的数据立刻被保存。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">int</span> i = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> a = i;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"i = %d"</span>, a);</span><br><span class="line">    __asm {</span><br><span class="line">        mov dword ptr [ebp<span class="number">-4</span>], <span class="number">20</span>h</span><br><span class="line">    }</span><br><span class="line"> </span><br><span class="line">    <span class="type">int</span> b = i;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"i = %d"</span>, b);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">i = <span class="number">10</span></span><br><span class="line">i = <span class="number">32</span>    <span class="comment">// 如果没有 volatile 关键字修饰则该值为 10</span></span><br></pre></td></tr></tbody></table></figure>

<p>✅ <code>volatile</code> 用在如下的几个地方：</p>
<ol>
<li><strong>中断服务程序</strong>中修改的供其它程序检测的变量需要加 volatile。</li>
<li><strong>多任务环境</strong>下各任务间共享的标志应该加 volatile：当两个线程都要用到某一个变量且该变量的值会被改变时，应该用 volatile 声明，该关键字的作用是防止优化编译器把变量从内存装入 CPU 寄存器中。如果变量被装入寄存器，那么两个线程有可能一个使用内存中的变量，一个使用寄存器中的变量，这会造成程序的错误执行。volatile 的意思是让编译器每次操作该变量时一定要从内存中真正取出，而不是使用已经存在寄存器中的值。</li>
<li>存储器映射的硬件寄存器通常也要加 volatile 说明，因为每次对它的读写都可能有不同意义。</li>
</ol>
<h2 id="52-如果有一个空类，它会默认存在哪些函数？"><a href="#52-如果有一个空类，它会默认存在哪些函数？" class="headerlink" title="52. 如果有一个空类，它会默认存在哪些函数？"></a>52. 如果有一个空类，它会默认存在哪些函数？</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Empty</span>(); <span class="comment">// 缺省构造函数 //</span></span><br><span class="line"><span class="built_in">Empty</span>( <span class="type">const</span> Empty&amp; ); <span class="comment">// 拷贝构造函数 //</span></span><br><span class="line">~<span class="built_in">Empty</span>(); <span class="comment">// 析构函数 //</span></span><br><span class="line">Empty&amp; <span class="keyword">operator</span>=( <span class="type">const</span> Empty&amp; ); <span class="comment">// 赋值运算符 //</span></span><br></pre></td></tr></tbody></table></figure>

<h2 id="53-const-char-与-string-之间的区别"><a href="#53-const-char-与-string-之间的区别" class="headerlink" title="53. const char* 与 string 之间的区别"></a>53. const char* 与 string 之间的区别</h2><p>string 是 C++ 标准库里面其中一个，封装了对字符串的操作，实际操作过程我们可以用 <code>const char*</code> 给 <code>string</code> 类初始化。</p>
<p>三者之间的转化关系如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. string 转 const char*</span></span><br><span class="line">string s = “abc”;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* c_s = s.<span class="built_in">c_str</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. const char* 转 string, 直接赋值即可</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* c_s = “abc”;</span><br><span class="line"><span class="function">string <span class="title">s</span><span class="params">(c_s)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. string 转 char* </span></span><br><span class="line">string s = “abc”;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> len = s.<span class="built_in">length</span>();</span><br><span class="line"><span class="type">char</span>* c;</span><br><span class="line">c = <span class="keyword">new</span> <span class="type">char</span>[len + <span class="number">1</span>];</span><br><span class="line"><span class="built_in">strcpy</span>(c, s.<span class="built_in">c_str</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. char* 转 string, 直接赋值即可</span></span><br><span class="line"><span class="type">char</span>* c = “abc”;</span><br><span class="line"><span class="function">string <span class="title">s</span><span class="params">(c)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. const char* 转 char*</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* cpc = “abc”;</span><br><span class="line"><span class="type">char</span>* pc = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(cpc) + <span class="number">1</span>];</span><br><span class="line"><span class="built_in">strcpy</span>(pc, cpc);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 6. char* 转 const char*, 直接赋值即可</span></span><br><span class="line"><span class="type">char</span>* pc = “abc”;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* cpc = pc;</span><br></pre></td></tr></tbody></table></figure>

<h2 id="54-static-cast-比-C-语言中的转换好在哪里？"><a href="#54-static-cast-比-C-语言中的转换好在哪里？" class="headerlink" title="54. static_cast 比 C 语言中的转换好在哪里？"></a>54. static_cast 比 C 语言中的转换好在哪里？</h2><ol>
<li>更加安全；</li>
<li>更直接明显，能够一眼看出是什么类型转换为什么类型，容易找出程序中的错误；可清楚地辨别代码中每个显式的强制转；可读性更好，能体现程序员的意图。</li>
</ol>
<h2 id="55-delete-和-delete-区别？"><a href="#55-delete-和-delete-区别？" class="headerlink" title="55. delete 和 delete[] 区别？"></a>55. delete 和 delete[] 区别？</h2><ul>
<li><code>delete</code> 只会调用一次析构函数。</li>
<li><code>delete[]</code> 会调用数组中每个元素的析构函数。</li>
</ul>
<h2 id="56-为什么不把所有函数写成内联函数？"><a href="#56-为什么不把所有函数写成内联函数？" class="headerlink" title="56. 为什么不把所有函数写成内联函数？"></a>56. 为什么不把所有函数写成内联函数？</h2><p>内联函数以代码复杂为代价，它以省去函数调用的开销来提高执行效率。所以一方面如果内联函数体内代码执行时间相比函数调用开销较大，则没有太大的意义；另一方面每一处内联函数的调用都要复制代码，消耗更多的内存空间，因此以下情况不宜使用内联函数：</p>
<ul>
<li>函数体内的代码比较长，将导致内存消耗代价</li>
<li>函数体内有循环，函数执行时间要比函数调用开销大</li>
</ul>
<h2 id="57-哪些函数不能是虚函数？"><a href="#57-哪些函数不能是虚函数？" class="headerlink" title="57. 哪些函数不能是虚函数？"></a>57. 哪些函数不能是虚函数？</h2><ol>
<li>构造函数：构造函数初始化对象，派生类必须知道基类函数干了什么，才能进行构造；当有虚函数时，每一个类有一个虚表，每一个对象有一个虚表指针，虚表指针在构造函数中初始化。</li>
<li>内联函数：内联函数表示在编译阶段进行函数体的替换操作，而虚函数意味着在运行期间进行类型确定，所以内联函数不能是虚函数。</li>
<li>静态函数：静态函数不属于对象属于类，静态成员函数没有 this 指针，因此静态函数设置为虚函数没有任何意义。</li>
<li>友元函数：友元函数不属于类的成员函数，不能被继承。对于没有继承特性的函数没有虚函数的说法。</li>
<li>普通函数：普通函数不属于类的成员函数，不具有继承特性，因此普通函数没有虚函数。</li>
</ol>
<h2 id="58-什么原因造成内存泄露，你怎么避免-解决内存泄露？"><a href="#58-什么原因造成内存泄露，你怎么避免-解决内存泄露？" class="headerlink" title="58. 什么原因造成内存泄露，你怎么避免/解决内存泄露？"></a>58. 什么原因造成内存泄露，你怎么避免/解决内存泄露？</h2><h3 id="1️⃣-什么是内存泄露？"><a href="#1️⃣-什么是内存泄露？" class="headerlink" title="1️⃣ 什么是内存泄露？"></a>1️⃣ 什么是内存泄露？</h3><p>在程序运行过程中不再使用的对象没有被正确释放，从而导致程序使用的内存不断增加，最终导致程序异常退出或内存分配失败。</p>
<h3 id="2️⃣-什么原因造成内存泄露？"><a href="#2️⃣-什么原因造成内存泄露？" class="headerlink" title="2️⃣ 什么原因造成内存泄露？"></a>2️⃣ 什么原因造成内存泄露？</h3><ul>
<li>忘记释放内存：分配了内存但没有释放</li>
<li>异常 / 逻辑处理不当：写了内存释放代码，但最后未执行到</li>
<li>循环引用：使用智能指针 shared_ptr 造成内存泄露</li>
</ul>
<h3 id="3️⃣-如何避免-解决内存泄露-‼️"><a href="#3️⃣-如何避免-解决内存泄露-‼️" class="headerlink" title="3️⃣ 如何避免/解决内存泄露 ‼️"></a>3️⃣ 如何避免/解决内存泄露 ‼️</h3><blockquote>
<p>内存泄露一般是因为<strong>分配了内存但没有释放</strong>，要解决这个问题，我通常从以下几个层面入手：</p>
</blockquote>
<ul>
<li>我会用 <strong>RAII 机制管理资源</strong>（构造时分配，析构时释放）</li>
<li>能用<strong>智能指针</strong>（<code>unique_ptr</code>, <code>shared_ptr</code>）的地方绝不手动 <code>new</code>/<code>delete</code>，同时要注意<strong>避免循环引用</strong>（使用弱引用）</li>
<li>对于资源管理比较复杂的类，我会写好析构函数，<strong>并考虑拷贝/移动语义，防止资源重复释放或泄露</strong></li>
<li>正确捕获处理异常 / 回滚式编程：<strong>编写异常安全的代码非常困难</strong></li>
</ul>
<p>解决内存泄露本质上就是：该释放的要释放，生命周期清楚，用好工具，写好代码。我平时更倾向于用智能指针来管理资源，基本上能从根上避免大部分内存泄露问题。</p>
<h3 id="4️⃣-如何定位内存泄露"><a href="#4️⃣-如何定位内存泄露" class="headerlink" title="4️⃣ 如何定位内存泄露"></a>4️⃣ 如何定位内存泄露</h3><blockquote>
<p>🔗参考链接：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/dWbqNIA4pLWs4pd53Gaq8A">Linux内存泄露定位1：valgrind篇</a></li>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzU4NjY0NTExNA==&amp;mid=2247486485&amp;idx=1&amp;sn=a4ff43bbf0f25700369fd433ac66613a&amp;chksm=fdf96700ca8eee1615ef071da78d32ae68986610d69c44915dd6f6fdf9aa87f659889ef33eac&amp;scene=178&amp;cur_album_id=2238988581711282176&amp;search_click_id=#rd">Linux内存泄露定位2：mtrace篇</a></li>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/JX2NVI35ze02k7LwCodhLA">Linux内存泄露定位3：hook+backtrace篇</a></li>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/gb3hcwgoFXTiZhmWxyf-bg">Linux内存泄露定位4：eBPF+uprobes篇</a></li>
</ul>
</blockquote>
<ul>
<li>静态检测工具：检查代码中是否出现内存泄露，<ul>
<li>cppcheck</li>
<li>clang-tidy</li>
</ul>
</li>
<li><code>valgrind</code><ul>
<li>需要调试信息 <code>-g</code></li>
<li><code>valgrind --leak-check=full</code> 可执行程序</li>
<li>可视 valgrind 为虚拟机，将可执行程序当作文件来处理，读取二进制文件的内容，进行指令解析并执行</li>
</ul>
</li>
<li><code>hook</code> + <code>backtrace</code>：侵入式（可能会引起程序异常）<ul>
<li>hook 住内存分配和释放接口</li>
<li>每次申请内存都记录一下，每次释放时也记录一下，然后再把这两种记录进行一个对比，把相同的去掉，剩下就是</li>
</ul>
</li>
<li><code>eBPF</code> + <code>uprobes</code>：非侵入式（内核中进行统计，不会影响程序）<ul>
<li>不需要调试信息</li>
<li>原理与上一种相同，但是不是侵入式，运行在内核</li>
</ul>
</li>
</ul>
<h2 id="59-C-写了析构函数，系统会帮我们生成默认移动构造函数这些吗（介绍-C-六个特殊成员函数）"><a href="#59-C-写了析构函数，系统会帮我们生成默认移动构造函数这些吗（介绍-C-六个特殊成员函数）" class="headerlink" title="59. C++ 写了析构函数，系统会帮我们生成默认移动构造函数这些吗（介绍 C++ 六个特殊成员函数）"></a>59. C++ 写了析构函数，系统会帮我们生成默认移动构造函数这些吗（介绍 C++ 六个特殊成员函数）</h2><p>写了析构函数，系统可能不再自动生成“移动构造”和“移动赋值”函数了，但拷贝构造和拷贝赋值通常还是会生成的。</p>
<p>在 C++ 里，有六个所谓的“特殊成员函数”：</p>
<ol>
<li>默认构造函数 <code>MyClass()</code></li>
<li>析构函数 <code>~MyClass()</code></li>
<li>拷贝构造函数 <code>MyClass(const MyClass&amp; other)</code></li>
<li>拷贝赋值函数 <code>MyClass&amp; operator=(const MyClass&amp; other)</code></li>
<li>移动构造函数（C++11 起）<code>MyClass(MyClass&amp;&amp; other) noexcept</code></li>
<li>移动赋值函数（C++11 起）<code>MyClass&amp; operator=(MyClass&amp;&amp; other) noexcept</code></li>
</ol>
<p>如果你自己写了一个<strong>析构函数</strong>，那编译器就认为你要自己管理资源了。所以出于安全考虑，它<strong>不会再自动生成移动构造函数和移动赋值函数了</strong>，你得自己写，或者用 <code>= default</code> 显式声明。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">MyClass</span>(MyClass&amp;&amp;) = <span class="keyword">default</span>;</span><br><span class="line">MyClass&amp; <span class="keyword">operator</span>=(MyClass&amp;&amp;) = <span class="keyword">default</span>;</span><br></pre></td></tr></tbody></table></figure>

<h2 id="60-C-右值引用和移动拷贝-赋值-函数的作用"><a href="#60-C-右值引用和移动拷贝-赋值-函数的作用" class="headerlink" title="60. C++ 右值引用和移动拷贝(赋值)函数的作用"></a>60. C++ 右值引用和移动拷贝(赋值)函数的作用</h2><p>右值引用和移动语义是在 C++11 之后引入的，目的是<strong>优化性能，避免不必要的资源拷贝</strong>。</p>
<p>以前在 C++98 里，如果你把一个对象传给另一个对象，哪怕那个对象马上就要销毁了，编译器也只能做拷贝，哪怕里面的数据非常大，比如堆上几百 MB 的数组，也得老老实实拷贝一份，非常浪费性能。</p>
<p>而右值引用的出现，<strong>让编译器能识别出“这是一个临时对象”，你可以放心地把它的资源“抢过来”用，而不是复制一份。</strong></p>
<p>移动构造函数 <code>MyClass(MyClass&amp;&amp; a) noexcept</code> 和移动赋值操作符 <code>MyClass&amp; operator=(MyClass&amp;&amp; a) noexcept</code> 的作用就是：</p>
<ul>
<li><strong>移动构造</strong>：当一个临时对象要变成另一个对象时，直接“接管”它的内部资源，比如把指针地址拿过来，然后把原对象的指针清空，这样就不需要重新分配和复制内存。</li>
<li><strong>移动赋值</strong>：和移动构造类似，不过是用于对象已经存在的情况下，把另一个临时对象的资源拿过来，原来的资源先释放，然后再接管。</li>
</ul>
<h2 id="61-C-线程-thread-local-的作用是什么？"><a href="#61-C-线程-thread-local-的作用是什么？" class="headerlink" title="61. C++ 线程 thread_local 的作用是什么？"></a>61. C++ 线程 thread_local 的作用是什么？</h2><blockquote>
<p>它是线程单独拥有的资源，没办法作为共享资源</p>
</blockquote>
<p><code>thread_local</code> 是 C++11 引入的存储类型说明符，用于<strong>为每个线程创建独立的变量副本</strong>。</p>
<p>使用场景：</p>
<ul>
<li>每个线程都需要使用一个自己的变量（如缓存、计数器等），避免同步。</li>
<li>类似于线程的“全局变量”，但互不干扰。</li>
</ul>
<p>示例：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">thread_local</span> <span class="type">int</span> counter = <span class="number">0</span>;</span><br></pre></td></tr></tbody></table></figure>

<p>✅ <strong>示例场景</strong>：日志系统中用 <code>thread_local</code> 缓存上下文</p>
<p>在多线程程序中，很多系统会<strong>给每个线程维护一份独立的日志信息</strong>，比如线程 ID、调用栈、临时日志缓存等。如果所有线程都用一个共享变量，会导致锁竞争、效率低下。</p>
<p>这时候就可以用 <code>thread_local</code> 给每个线程<strong>一份独立副本</strong>！</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Logger</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">log</span><span class="params">(<span class="type">const</span> std::string&amp; message)</span> </span>{</span><br><span class="line">        log_context += message + <span class="string">"\n"</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">flush</span><span class="params">()</span> </span>{</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"[Thread "</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">"]\n"</span>;</span><br><span class="line">        std::cout &lt;&lt; log_context &lt;&lt; std::endl;</span><br><span class="line">        log_context.<span class="built_in">clear</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> <span class="keyword">thread_local</span> std::string log_context; <span class="comment">// 每个线程一份</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">thread_local</span> std::string Logger::log_context;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread_task</span><span class="params">(<span class="type">int</span> id)</span> </span>{</span><br><span class="line">    Logger::<span class="built_in">log</span>(<span class="string">"Start work in thread "</span> + std::<span class="built_in">to_string</span>(id));</span><br><span class="line">    Logger::<span class="built_in">log</span>(<span class="string">"Doing some work..."</span>);</span><br><span class="line">    Logger::<span class="built_in">log</span>(<span class="string">"Finish work in thread "</span> + std::<span class="built_in">to_string</span>(id));</span><br><span class="line">    Logger::<span class="built_in">flush</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(thread_task, <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(thread_task, <span class="number">2</span>)</span></span>;</span><br><span class="line">    t<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">    t<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="62-如何定义一个只能在堆上（栈上）生成对象的类？"><a href="#62-如何定义一个只能在堆上（栈上）生成对象的类？" class="headerlink" title="62. 如何定义一个只能在堆上（栈上）生成对象的类？"></a>62. 如何定义一个只能在堆上（栈上）生成对象的类？</h2><h3 id="只能在堆上"><a href="#只能在堆上" class="headerlink" title="只能在堆上"></a>只能在堆上</h3><p>方法：将析构函数设置为私有</p>
<p>原因：C++ 是静态绑定语言，编译器管理栈上对象的生命周期，编译器在为类对象分配栈空间时，会先检查类的析构函数的访问性。若析构函数不可访问，则不能在栈上创建对象。</p>
<h3 id="只能在栈上"><a href="#只能在栈上" class="headerlink" title="只能在栈上"></a>只能在栈上</h3><p>方法：将 new 和 delete 重载为私有</p>
<p>原因：在堆上生成对象，使用 new 关键词操作，其过程分为两阶段：第一阶段，使用 new 在堆上寻找可用内存，分配给对象；第二阶段，调用构造函数生成对象。将 new 操作设置为私有，那么第一阶段就无法完成，就不能够在堆上生成对象。</p>
<h2 id="63-递归过深会造成什么问题，OOM-吗？"><a href="#63-递归过深会造成什么问题，OOM-吗？" class="headerlink" title="63. 递归过深会造成什么问题，OOM 吗？"></a>63. 递归过深会造成什么问题，OOM 吗？</h2><p>递归过深确实可能引发一些严重问题，但不一定是 OOM（Out of Memory）。更常见的问题是栈溢出（Stack Overflow）。</p>
<p>✅ 栈溢出（Stack Overflow）</p>
<ul>
<li>每次函数调用都会在调用栈上分配一块内存来保存函数的执行上下文（如局部变量、返回地址等）。</li>
<li>如果递归层级太深，调用栈不断增长，最终会超过系统分配给程序的栈空间上限（跟默认「线程栈」大小相关）。</li>
<li>此时程序会抛出 StackOverflowError（Java） 或 Segmentation Fault（C/C++），或者 RecursionError（Python）。</li>
</ul>
<p>❌ 而不是 OOM（Out of Memory）</p>
<ul>
<li>OOM 通常是指 <strong>堆内存</strong> 耗尽，例如大量创建对象、数组或内存泄漏。</li>
<li>除非每层递归都分配了大量堆内存（比如在每层递归里 new 很大的对象），否则递归本身并不会直接造成 OOM。</li>
</ul>
<p>递归过深导致的栈溢出，和线程的栈大小直接相关：每个线程在启动时，操作系统会为它分配一块固定大小的栈内存（线程栈），专门用于保存函数调用帧，如果递归太深，每层调用都占用一点栈空间，栈就会被用完，最终导致栈溢出。线程栈大小是有限的，不同语言/平台有不同的默认值如下：</p>
<ul>
<li>Java 一般是 1MB（可通过 <code>-Xss</code> 参数设置）</li>
<li>Linux 上的原生线程（如 <code>pthread</code>）默认栈大小通常是 8MB</li>
<li>Python 受限于解释器的默认递归深度（<code>sys.getrecursionlimit()</code>）</li>
</ul>
<h2 id="64-如何获取前-K-个最大元素？"><a href="#64-如何获取前-K-个最大元素？" class="headerlink" title="64. 如何获取前 K 个最大元素？"></a>64. 如何获取前 K 个最大元素？</h2><p>这个问题是数据结构与算法中的经典题目之一，常用于考察排序、堆、优先队列的应用。以下是几种常见的解法及其时间复杂度分析：</p>
<h3 id="解法一：排序法（适合数据量不大）"><a href="#解法一：排序法（适合数据量不大）" class="headerlink" title="解法一：排序法（适合数据量不大）"></a>解法一：排序法（适合数据量不大）</h3><p>思路：</p>
<ul>
<li>直接对数组进行排序</li>
<li>取前 K 个元素</li>
</ul>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">topKSort</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>{</span><br><span class="line">    std::<span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), std::<span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">begin</span>() + k);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>时间复杂度：</p>
<ul>
<li>排序时间复杂度：<code>O(n log n)</code></li>
<li>空间复杂度：<code>O(1)</code></li>
</ul>
<h3 id="解法二：最小堆（推荐，适合大数据）"><a href="#解法二：最小堆（推荐，适合大数据）" class="headerlink" title="解法二：最小堆（推荐，适合大数据）"></a>解法二：最小堆（推荐，适合大数据）</h3><p>思路：</p>
<ul>
<li>使用大小为 K 的最小堆来保存当前最大的 K 个元素</li>
<li>遍历整个数组，若当前元素比堆顶大，则替换堆顶</li>
</ul>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">topKHeap</span><span class="params">(<span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (k == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> {};</span><br><span class="line"></span><br><span class="line">    std::priority_queue&lt;<span class="type">int</span>, std::vector&lt;<span class="type">int</span>&gt;, std::greater&lt;<span class="type">int</span>&gt;&gt; minHeap;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : nums) {</span><br><span class="line">        <span class="keyword">if</span> (minHeap.<span class="built_in">size</span>() &lt; k) {</span><br><span class="line">            minHeap.<span class="built_in">push</span>(num);</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (num &gt; minHeap.<span class="built_in">top</span>()) {</span><br><span class="line">            minHeap.<span class="built_in">pop</span>();</span><br><span class="line">            minHeap.<span class="built_in">push</span>(num);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">    <span class="keyword">while</span> (!minHeap.<span class="built_in">empty</span>()) {</span><br><span class="line">        result.<span class="built_in">push_back</span>(minHeap.<span class="built_in">top</span>());</span><br><span class="line">        minHeap.<span class="built_in">pop</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    std::<span class="built_in">sort</span>(result.<span class="built_in">rbegin</span>(), result.<span class="built_in">rend</span>()); <span class="comment">// 可选：从大到小排序</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>时间复杂度：</p>
<ul>
<li>时间复杂度：<code>O(n log k)</code><ul>
<li>构建堆：<code>O(k)</code></li>
<li>遍历其余 $n - k$ 个元素，每次 <code>O(log k)</code>：总共 <code>O((n-k) log k)</code></li>
</ul>
</li>
<li>空间复杂度：<code>O(k)</code></li>
</ul>
<h3 id="🔥-解法三：快排的思想（Top-K-问题，适合不要求完整排序）"><a href="#🔥-解法三：快排的思想（Top-K-问题，适合不要求完整排序）" class="headerlink" title="🔥 解法三：快排的思想（Top-K 问题，适合不要求完整排序）"></a>🔥 解法三：快排的思想（Top-K 问题，适合不要求完整排序）</h3><p>思路：</p>
<ul>
<li>类似快速排序中的分区（partition），选定一个“枢轴”，将大于 pivot 的放左边，小于的放右边</li>
<li>不断递归，直到找到第 K 个最大的数为止</li>
</ul>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span> <span class="comment">// for rand()</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">partition</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>{</span><br><span class="line">    <span class="type">int</span> pivot = nums[right], i = left;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = left; j &lt; right; ++j) {</span><br><span class="line">        <span class="keyword">if</span> (nums[j] &gt;= pivot) {</span><br><span class="line">            std::<span class="built_in">swap</span>(nums[i], nums[j]);</span><br><span class="line">            ++i;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    std::<span class="built_in">swap</span>(nums[i], nums[right]);</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quickSelect</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span> k)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (left &gt;= right)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> pivotIndex = <span class="built_in">partition</span>(nums, left, right);</span><br><span class="line">    <span class="keyword">if</span> (pivotIndex == k)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pivotIndex &lt; k)</span><br><span class="line">        <span class="built_in">quickSelect</span>(nums, pivotIndex + <span class="number">1</span>, right, k);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">quickSelect</span>(nums, left, pivotIndex - <span class="number">1</span>, k);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">topKQuickSelect</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>{</span><br><span class="line">    <span class="built_in">quickSelect</span>(nums, <span class="number">0</span>, nums.<span class="built_in">size</span>() - <span class="number">1</span>, k);</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">begin</span>() + k);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>时间复杂度：</p>
<ul>
<li>平均：<code>O(n)</code><ul>
<li>最坏（退化成链表）：<code>O(n^2)</code></li>
</ul>
</li>
<li>空间复杂度：<code>O(1)</code>（递归栈不计）</li>
</ul>
<h3 id="✅-总结对比"><a href="#✅-总结对比" class="headerlink" title="✅ 总结对比"></a>✅ 总结对比</h3><table>
<thead>
<tr>
<th>方法</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td>排序法</td>
<td>O(n log n)</td>
<td>O(1)</td>
<td>数据量小，代码简单</td>
</tr>
<tr>
<td>最小堆</td>
<td>O(n log k)</td>
<td>O(k)</td>
<td>数据量大，k 远小于 n</td>
</tr>
<tr>
<td>快速选择</td>
<td>平均 O(n)</td>
<td>O(1)</td>
<td>不关心顺序，只要前 K 大</td>
</tr>
</tbody></table>
<h2 id="65-堆和栈在操作系统底层的实现？"><a href="#65-堆和栈在操作系统底层的实现？" class="headerlink" title="65. 堆和栈在操作系统底层的实现？"></a>65. 堆和栈在操作系统底层的实现？</h2><h3 id="堆与栈、进程虚拟内存空间分布"><a href="#堆与栈、进程虚拟内存空间分布" class="headerlink" title="堆与栈、进程虚拟内存空间分布"></a>堆与栈、进程虚拟内存空间分布</h3><p>【速度、安全】栈是用于管理函数调用、局部变量等的高效内存区域，由操作系统自动管理</p>
<p>【动态、灵活】堆是用于动态分配的内存区域，由程序员手动管理（或者通过垃圾回收机制管理 — java）</p>
<p>⚙️ 在 32 位机器上，进程虚拟内存空间分布如下：</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/Wu-yikun/OSS/PicGo/202504281608151.png" alt="image-20250428160810384"></p>
<p>栈为什么适合函数调用：严格的顺序性，嵌套调用不会乱。</p>
<p>递归调用过深，栈会发生什么：栈溢出、触发 SIGSEGV 信号，程序崩溃。</p>
<h3 id="🔥-栈在操作系统底层的实现"><a href="#🔥-栈在操作系统底层的实现" class="headerlink" title="🔥 栈在操作系统底层的实现"></a>🔥 栈在操作系统底层的实现</h3><ol>
<li>线程创建时，操作系统为其创建栈空间（<strong>默认 8 MB</strong>）—— 分成进程栈与线程栈<ol>
<li>进程栈（主线程栈）在进程启动时创建</li>
<li>线程栈通过 <code>pthread_create</code>、<code>clone</code> 系统调用创建</li>
</ol>
</li>
<li>栈的使用：只需要移动栈指针</li>
<li>硬件支持：寄存器 x86 下<ol>
<li>栈顶指针 rsp</li>
<li>栈底指针 rbp</li>
</ol>
</li>
<li>操作系统管理：<ol>
<li>函数调用时，先将参数压栈</li>
<li>执行 call 指令，将返回地址（返回上一级函数的下一条指令）压栈</li>
<li>创建栈帧，保存旧的 rbp，设置新的 rbp</li>
<li>可能为局部变量分配空间（清理局部变量等的栈空间）</li>
<li>恢复之前的 rbp 和 rsp，ret 指令弹出返回地址</li>
</ol>
</li>
</ol>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/Wu-yikun/OSS/PicGo/202504281617109.png" alt="image-20250428161750930"></p>
<h3 id="🔥-堆在操作系统底层的实现"><a href="#🔥-堆在操作系统底层的实现" class="headerlink" title="🔥 堆在操作系统底层的实现"></a>🔥 堆在操作系统底层的实现</h3><p>本质为 <code>malloc</code> 机制：</p>
<ul>
<li>当分配内存的大小 $&lt;128KB$ 时，先从内存池获取，否则通过 <code>brk</code> 系统调用从堆区分配内存，回收时则回收到内存池</li>
<li>当分配内存的大小 $\ge 128KB$ 时，通过 <code>mmap</code> 系统调用从文件映射区分配内存，回收时通过 <code>munmap</code> 释放内存</li>
</ul>
<h3 id="为什么栈的分配速度比堆快？"><a href="#为什么栈的分配速度比堆快？" class="headerlink" title="为什么栈的分配速度比堆快？"></a>为什么栈的分配速度比堆快？</h3><p>栈只需要移动指针，堆需要查找空闲块、处理碎片和系统调用</p>
<h3 id="多线程程序中，堆和栈如何隔离？"><a href="#多线程程序中，堆和栈如何隔离？" class="headerlink" title="多线程程序中，堆和栈如何隔离？"></a>多线程程序中，堆和栈如何隔离？</h3><p>栈是线程私有的，无需隔离；</p>
<p>堆是进程共享的，需同步机制如锁🔒</p>
<h2 id="66-C-mutable-关键字"><a href="#66-C-mutable-关键字" class="headerlink" title="66. C++ mutable 关键字"></a>66. C++ <code>mutable</code> 关键字</h2><blockquote>
<p>腾讯 wxg 一面</p>
</blockquote>
<p>1️⃣ C++ <code>mutable</code> 用于修饰非静态成员函数，使得该成员变量可以在 <code>const</code> 成员函数中允许被修改</p>
<p>2️⃣ 同时也可以用于修饰 <code>lambda</code> 表达式，可以去掉函数调用操作符后 <code>const</code> 关键字，从而可以在 lambda 函数体内可以修改按值捕获的外部变量。</p>
<h2 id="67-详解内存对齐（如何-padding）及其原因"><a href="#67-详解内存对齐（如何-padding）及其原因" class="headerlink" title="67. 详解内存对齐（如何 padding）及其原因"></a>67. 详解内存对齐（如何 padding）及其原因</h2><blockquote>
<p>腾讯 csig 一面</p>
</blockquote>
<p>求 <code>sizeof(S)</code> 的大小并解析，以及为什么进行内存对齐。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span> {</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> {</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">char</span> b;</span><br><span class="line">    <span class="type">short</span> c;</span><br><span class="line">    <span class="type">char</span> d;</span><br><span class="line">    B e;</span><br><span class="line">} S;</span><br></pre></td></tr></tbody></table></figure>

<p>在 C/C++ 中，结构体的大小与成员排列不仅取决于每个成员的大小，还受到**内存对齐（Alignment）**的影响，具体规则如下：</p>
<ol>
<li>每个成员变量的地址必须是其类型对齐大小（对齐边界）的整数倍。</li>
<li>结构体本身的总大小必须是其<strong>最大对齐单位</strong>的整数倍。</li>
<li>编译器会在必要的位置插入 **padding（填充字节）**来满足上述要求，以提高内存访问效率。</li>
</ol>
<blockquote>
<p>对结构体 S 的内存布局分析</p>
</blockquote>
<ol>
<li><strong>结构体 B 的分析：</strong></li>
</ol>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span> {</span><br><span class="line">    <span class="type">int</span> b;   <span class="comment">// 4 bytes, offset 0</span></span><br><span class="line">    <span class="type">char</span> c;  <span class="comment">// 1 byte, offset 4</span></span><br><span class="line">             <span class="comment">// padding 3 bytes to align struct B size to 8</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>成员 <code>int b</code> 对齐为 4 字节，偏移量为 0。</li>
<li>成员 <code>char c</code> 占 1 字节，偏移量为 4。</li>
<li>为满足结构体 <code>B</code> 总大小为最大对齐成员（4 字节）的倍数，需要在末尾添加 3 字节填充。</li>
</ul>
<p>所以 <code>sizeof(B) == 8</code></p>
<ol start="2">
<li><strong>结构体 S 的分析：</strong></li>
</ol>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> {</span><br><span class="line">    <span class="type">int</span> a;    <span class="comment">// 4 bytes, offset 0</span></span><br><span class="line">    <span class="type">char</span> b;   <span class="comment">// 1 byte, offset 4</span></span><br><span class="line">              <span class="comment">// padding 1 byte, to align next 'short' to 2 bytes</span></span><br><span class="line">    <span class="type">short</span> c;  <span class="comment">// 2 bytes, offset 6</span></span><br><span class="line">    <span class="type">char</span> d;   <span class="comment">// 1 byte, offset 8</span></span><br><span class="line">              <span class="comment">// padding 3 bytes, to align next 'B' to 4 bytes</span></span><br><span class="line">    B e;      <span class="comment">// 8 bytes, offset 12</span></span><br><span class="line">} S;</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li><code>int a</code>: 占 4 字节，从 offset 0 开始。</li>
<li><code>char b</code>: 占 1 字节，offset = 4。<ul>
<li>padding 1 字节，使得 <code>short c</code> 对齐到 2 的倍数（offset = 6）。</li>
</ul>
</li>
<li><code>short c</code>: 占 2 字节，offset = 6。</li>
<li><code>char d</code>: 占 1 字节，offset = 8。<ul>
<li>padding 3 字节，使得结构体 <code>B e</code> 对齐到 4 字节边界（offset = 12）。</li>
</ul>
</li>
<li><code>B e</code>: 占 8 字节（因为 <code>sizeof(B) == 8</code>），offset = 12。</li>
<li>最后 offset = 12 + 8 = 20</li>
</ul>
<p>因此： <code>sizeof(S) == 20</code>（假设最后总大小为 21 字节，需要 padding 到 24 字节）</p>
<h2 id="68-int-0-0-的含义？"><a href="#68-int-0-0-的含义？" class="headerlink" title="68. *(int *)0 = 0 的含义？"></a>68. <code>*(int *)0 = 0</code> 的含义？</h2><p><code>*(int *)0 = 0;</code> 这行代码的意思是：将整数值 <code>0</code> 写入内存地址 <code>0</code> 所指向的地方，也就是将值 <code>0</code> 存储到内存的 <strong>地址 0</strong>。</p>
<ul>
<li><code>(int *) 0</code>：把整数 0 强转为 <code>int*</code> 类型的指针</li>
<li><code>*(int *) 0</code>：对地址 <code>0</code> 进行解引用，访问该地址存储的内容</li>
<li><code>*(int *) 0 = 0</code>：对地址 <code>0</code> 存储的内容赋值为 <code>0</code>，试图写入值 <code>0</code> 到地址 <code>0</code></li>
</ul>
<p>在几乎所有现代操作系统中，地址 <code>0</code> 是<strong>无效的地址</strong>，属于操作系统保留的内存区域。</p>
<p>尝试访问（特别是写入）地址 <code>0</code> 会导致<strong>段错误（Segmentation Fault）</strong>，程序异常终止。</p>
<p>在某些低层次编程或嵌入式开发中，地址 <code>0</code> 可能用于特殊用途，但在普通用户态程序中，这样写<strong>没有任何合法理由</strong>，通常是：</p>
<ul>
<li><strong>故意制造崩溃</strong>（例如测试信号处理）。</li>
<li><strong>调试用</strong>，或者模拟空指针解引用的错误。</li>
<li><strong>考察面试者对指针、内存访问的理解</strong>（比如本题）。</li>
</ul>
<h2 id="69-宏定义展开"><a href="#69-宏定义展开" class="headerlink" title="69. 宏定义展开"></a>69. 宏定义展开</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SQR(x) (x * x)</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">int</span> a, b = <span class="number">3</span>;</span><br><span class="line">    a = <span class="built_in">SQR</span>(b + <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a = %d\n"</span>, a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>输出为 <code>a = 11</code> 而非 <code>a = 25</code>，宏展开后为 <code>a = (b + 2 * b + 2)</code>，所以结果为 <code>a = 11</code></p>
<h2 id="70-假设有一个位图数据结构定义为-uint32-t-bitmap-BSIZE-，请写出用于判断位图中第-bit-位是否为-1-的如下宏的实现"><a href="#70-假设有一个位图数据结构定义为-uint32-t-bitmap-BSIZE-，请写出用于判断位图中第-bit-位是否为-1-的如下宏的实现" class="headerlink" title="70. 假设有一个位图数据结构定义为 uint32_t bitmap[BSIZE];，请写出用于判断位图中第 bit 位是否为 1 的如下宏的实现"></a>70. 假设有一个位图数据结构定义为 <code>uint32_t bitmap[BSIZE];</code>，请写出用于判断位图中第 bit 位是否为 1 的如下宏的实现</h2><p><code>#define is_bit_set(bit) ((bitmap[(bit)/32] &amp; (1U &lt;&lt; ((bit)%32))) != 0)</code></p>
<p>解释：一个 <code>uint32_t</code> 只能表示 32 位，题目 bitmap 用的是 <code>uint32_t</code> 数组，所以采用 <code>/32</code> 找到在第几个 <code>uint32_t</code> 中，<code>%32</code> 找到在第几位。</p>
<h2 id="71-读写锁与读优先-写优先"><a href="#71-读写锁与读优先-写优先" class="headerlink" title="71. 读写锁与读优先/写优先"></a>71. 读写锁与读优先/写优先</h2><blockquote>
<p>读写锁和传统互斥锁的区别在于，能支持多个读线程并发执行</p>
</blockquote>
<p>在多线程编程中，读锁和写锁通常是配合**读写锁（读写互斥锁）**使用的，目的是在多个线程并发访问共享资源时提供更高的效率。简单来说，**读锁（共享锁）<strong>允许多个线程同时读取资源，但不允许写操作；而</strong>写锁（独占锁）**则是排他的，同一时间只能有一个线程持有写锁，且写锁期间不允许任何其他线程读或写这个资源。</p>
<p>这个机制的好处在于：在读多写少的场景下，我们不必像传统互斥锁那样每次都加排它锁，而是可以让多个读线程并发执行，提升性能。</p>
<p>具体的使用场景比如：</p>
<ul>
<li><strong>读锁适合的场景</strong>：多个线程同时查询一个共享缓存、配置文件、数据库快照等，数据是只读的，不会被修改。</li>
<li><strong>写锁适合的场景</strong>：当某个线程需要更新缓存、修改配置或写入日志文件等操作时，为了避免其他线程读到不一致的数据，就需要加写锁。</li>
</ul>
<p>在 C++ 中，像 <code>std::shared_mutex</code> 就是一个典型的读写锁实现，可以配合 <code>std::shared_lock</code> 和 <code>std::unique_lock</code> 分别实现读锁和写锁。</p>
<blockquote>
<p>读/写优先是基于读写锁中的策略选择而已，不要搞混了</p>
</blockquote>
<p>在使用读写锁时，读优先和写优先指的是当<strong>读线程和写线程同时竞争锁资源</strong>时，系统会优先允许哪一类线程先获取锁。</p>
<p><strong>读优先</strong>的策略意味着：如果当前有读线程在读，或者有新的读线程请求读锁，就会优先满足它们，哪怕有写线程已经在等待。这种策略的好处是<strong>读性能非常高</strong>，适合“读远远多于写”的场景。但问题是如果读操作持续不断，写线程可能会<strong>长时间得不到执行</strong>，造成“写饥饿”。</p>
<p><strong>写优先</strong>则反过来：一旦有写线程在等待，新的读线程就要等写线程先执行完。这种方式能保证写操作不会被饿死，但也意味着读线程可能会频繁被阻塞，尤其在写比较多时，<strong>整体并发度会下降</strong>。</p>
<p>还有一种是<strong>公平策略</strong>，就是无论读还是写，谁先请求谁先执行。这种方式平衡了读写，防止任何一方饿死，但也可能带来一点性能损耗。</p>
<p>实际使用中，选择哪种策略要看业务特点：</p>
<ul>
<li>如果系统是典型的读多写少，比如缓存、配置系统，用读优先可以提升整体吞吐；</li>
<li>如果写操作比较关键，比如数据库更新或者日志记录，写优先更合适；</li>
<li>如果两者都重要，或者对延迟比较敏感，可以用公平策略。</li>
</ul>
<p>C++ 标准库里的 <code>std::shared_mutex</code> 是不保证写优先的，如果确实要实现写优先或者公平策略，可能需要第三方库（比如 Boost）或者平台相关的原语。</p>
<h2 id="72-多线程之间是如何通信的？线程之间怎么交互的？"><a href="#72-多线程之间是如何通信的？线程之间怎么交互的？" class="headerlink" title="72. 多线程之间是如何通信的？线程之间怎么交互的？"></a>72. 多线程之间是如何通信的？线程之间怎么交互的？</h2><blockquote>
<p><code>&lt;mutex&gt;</code> 和 <code>&lt;condition_variable&gt;</code></p>
</blockquote>
<blockquote>
<p>答案就是<strong>条件变量</strong></p>
</blockquote>
<p>多线程之间的通信和交互主要是通过共享内存来实现的，也就是说多个线程可以访问同一个进程的内存空间，从而读写同一份数据。但因为线程可能同时访问同一块数据，会产生竞态条件，<strong>所以通常需要同步机制来保证数据的一致性和正确性</strong>。</p>
<p>常用的同步方式包括互斥锁（mutex）、读写锁（rwlock）、信号量（semaphore）、条件变量（condition variable）等，这些机制帮助线程协调访问顺序，防止数据冲突。</p>
<p>此外，线程间还可以通过消息队列、事件通知等方式传递信息，尤其在异步或生产者-消费者模式中常见。现代操作系统和语言运行时通常提供了丰富的线程同步和通信工具，确保线程间可以高效且安全地交互和协作。</p>
<h2 id="73-关于使用-比较-double-类型"><a href="#73-关于使用-比较-double-类型" class="headerlink" title="73. 关于使用 == 比较 double 类型"></a>73. 关于使用 <code>==</code> 比较 <code>double</code> 类型</h2><p>在 C++ 中处理<code>double</code>类型时，我们需要理解：</p>
<ol>
<li>为什么不能直接用<code>==</code>比较浮点数（浮点数为什么是近似存储的）</li>
<li>如何正确比较浮点数</li>
</ol>
<h3 id="1-为什么不能直接用-比较"><a href="#1-为什么不能直接用-比较" class="headerlink" title="1. 为什么不能直接用 == 比较"></a>1. 为什么不能直接用 <code>==</code> 比较</h3><p>浮点数在计算机中的存储是近似值而非精确值，<code>double</code> 通常使用 64 位存储（1 符号位 + 11 指数位 + 52 尾数位)，像 0.1 这样的十进制小数无法精确表示为二进制分数，<strong>存储时必须进行舍入（截断无限循环部分），导致微小误差</strong>。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="type">double</span> a = <span class="number">0.1</span>;</span><br><span class="line">    <span class="type">double</span> b = <span class="number">0.2</span>;</span><br><span class="line">    <span class="type">double</span> sum = a + b;</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; std::<span class="built_in">setprecision</span>(<span class="number">20</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">"0.1 in memory: "</span> &lt;&lt; a &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">"0.2 in memory: "</span> &lt;&lt; b &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">"0.1 + 0.2 = "</span> &lt;&lt; sum &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">"0.3 in memory: "</span> &lt;&lt; <span class="number">0.3</span> &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>输出可能类似于：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0.1 in memory: 0.10000000000000000555</span><br><span class="line">0.2 in memory: 0.2000000000000000111</span><br><span class="line">0.1 + 0.2 = 0.30000000000000004441</span><br><span class="line">0.3 in memory: 0.2999999999999999889</span><br></pre></td></tr></tbody></table></figure>

<p>所以使用 <code>==</code> 比较是容易出错的。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="type">double</span> x = <span class="number">0.1</span> + <span class="number">0.2</span>;</span><br><span class="line">    <span class="type">double</span> y = <span class="number">0.3</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (x == y) {</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"Exactly equal\n"</span>;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"Not exactly equal\n"</span>;  <span class="comment">// 通常会输出这个</span></span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="2-正确的浮点数比较方法"><a href="#2-正确的浮点数比较方法" class="headerlink" title="2. 正确的浮点数比较方法"></a>2. 正确的浮点数比较方法</h3><blockquote>
<p>绝对误差比较</p>
</blockquote>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cfloat&gt;</span> <span class="comment">// 对于 DBL_EPSILON</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">nearlyEqual</span><span class="params">(<span class="type">double</span> a, <span class="type">double</span> b, <span class="type">double</span> absEpsilon = <span class="number">1e-12</span>)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">fabs</span>(a - b) &lt;= absEpsilon;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="type">double</span> x = <span class="number">0.1</span> + <span class="number">0.2</span>;</span><br><span class="line">    <span class="type">double</span> y = <span class="number">0.3</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">nearlyEqual</span>(x, y)) {</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"Equal within tolerance\n"</span>;  <span class="comment">// 会输出这个</span></span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"Not equal\n"</span>;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="3-什么时候可以使用-直接比较"><a href="#3-什么时候可以使用-直接比较" class="headerlink" title="3. 什么时候可以使用 == 直接比较"></a>3. 什么时候可以使用 <code>==</code> 直接比较</h3><p>在C++中，虽然大多数情况下不推荐直接用<code>==</code>比较浮点数，但在以下特定情况下可以安全使用（当你能 100% 确定数值来源和没有经过任何浮点运算时，才用<code>==</code>）：</p>
<ul>
<li>比较精确赋值的相同字面值</li>
</ul>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> a = <span class="number">5.0</span>;</span><br><span class="line"><span class="type">double</span> b = <span class="number">5.0</span>;</span><br><span class="line"><span class="keyword">if</span> (a == b) { <span class="comment">/* 总是true */</span> }</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>比较整数范围内的值</li>
</ul>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> x = <span class="number">42.0</span>;  <span class="comment">// 没有小数部分</span></span><br><span class="line"><span class="type">double</span> y = <span class="number">42.0</span>;</span><br><span class="line"><span class="keyword">if</span> (x == y) { <span class="comment">/* 总是true */</span> }</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>比较特殊浮点值</li>
</ul>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 比较正负无穷大</span></span><br><span class="line"><span class="type">double</span> inf1 = std::numeric_limits&lt;<span class="type">double</span>&gt;::<span class="built_in">infinity</span>();</span><br><span class="line"><span class="type">double</span> inf2 = std::numeric_limits&lt;<span class="type">double</span>&gt;::<span class="built_in">infinity</span>();</span><br><span class="line"><span class="keyword">if</span> (inf1 == inf2) { <span class="comment">/* 总是true */</span> }</span><br><span class="line"></span><br><span class="line"><span class="comment">// 比较零值</span></span><br><span class="line"><span class="keyword">if</span> (<span class="number">0.0</span> == <span class="number">-0.0</span>) { <span class="comment">/* 总是true，尽管符号不同 */</span> }</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>比较编译期常量表达式：</li>
</ul>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="type">double</span> PI = <span class="number">3.141592653589793</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">double</span> PI_2 = PI / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (PI_2 == <span class="number">1.5707963267948966</span>) { <span class="comment">/* 编译期计算，总是true */</span> }</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>比较未经过算术运算的相同变量：</li>
</ul>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> val = <span class="built_in">getValue</span>();  <span class="comment">// 假设返回固定值</span></span><br><span class="line"><span class="keyword">if</span> (val == val) { <span class="comment">/* 检测NaN的惯用方法 */</span> }</span><br><span class="line"><span class="comment">// 如果val是NaN，这个条件会是false</span></span><br></pre></td></tr></tbody></table></figure>

<p>⚠️ 特别注意，以下情况<strong>绝不</strong>应该使用<code>==</code>：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 经过算术运算的结果</span></span><br><span class="line"><span class="keyword">if</span> (<span class="number">0.1</span> + <span class="number">0.2</span> == <span class="number">0.3</span>) { <span class="comment">/* 可能false */</span> }</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从不同计算路径得到的结果</span></span><br><span class="line"><span class="type">double</span> a = <span class="built_in">calculateA</span>();</span><br><span class="line"><span class="type">double</span> b = <span class="built_in">calculateB</span>();</span><br><span class="line"><span class="keyword">if</span> (a == b) { <span class="comment">/* 危险 */</span> }</span><br><span class="line"></span><br><span class="line"><span class="comment">// 循环累积的结果</span></span><br><span class="line"><span class="type">double</span> sum = <span class="number">0.0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) {</span><br><span class="line">    sum += <span class="number">0.1</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span> (sum == <span class="number">1.0</span>) { <span class="comment">/* 可能false */</span> }</span><br></pre></td></tr></tbody></table></figure>

<h2 id="74-堆与栈的优缺点比较"><a href="#74-堆与栈的优缺点比较" class="headerlink" title="74. 堆与栈的优缺点比较"></a>74. 堆与栈的优缺点比较</h2><h3 id="栈-Stack"><a href="#栈-Stack" class="headerlink" title="栈 - Stack"></a>栈 - Stack</h3><p>优点：</p>
<ul>
<li>快速分配/释放：栈内存的分配和释放只是移动栈指针，速度快</li>
<li>自动管理：函数返回时自动释放，无需手动管理</li>
<li>缓存友好：栈数据通常位于缓存热点区域，访问速度快</li>
<li>不会产生碎片：严格的 LIFO 顺序避免了内存碎片问题</li>
<li>线程安全：每个线程有自己的栈，无需同步</li>
</ul>
<p>缺点</p>
<ol>
<li>大小有限：栈空间通常较小（几 MB），不适合大对象</li>
<li>生命周期固定：只能在函数调用期间存在，不能跨函数使用</li>
<li>灵活性差：无法动态调整大小，必须是编译时已知的大小</li>
<li>容易溢出：<strong>递归过深</strong>或<strong>大对象</strong>可能导致栈溢出（stack overflow）</li>
</ol>
<h3 id="堆-Heap"><a href="#堆-Heap" class="headerlink" title="堆 - Heap"></a>堆 - Heap</h3><p>优点：</p>
<ol>
<li>大容量：可用内存通常远大于栈空间</li>
<li>动态分配：可以在运行时决定分配大小和生命周期</li>
<li>全局可访问：分配的内存可以被程序任何部分访问</li>
<li>灵活性高：可以动态调整大小(如realloc)</li>
<li>适合大数据：能够处理大型数据结构</li>
</ol>
<p>缺点：</p>
<ol>
<li>分配速度慢：需要寻找合适的内存块，可能涉及系统调用</li>
<li>手动管理特性：堆内存需要显式分配 (<code>new/malloc</code>) 和释放 (<code>delete/free</code>)，存在<strong>内存泄漏</strong>风险</li>
<li>内存碎片：频繁分配释放可能导致碎片</li>
<li>同步开销：多线程环境下需要同步机制</li>
<li>缓存不友好：堆分配的数据可能分散在内存各处</li>
</ol>
<h3 id="使用建议"><a href="#使用建议" class="headerlink" title="使用建议"></a>使用建议</h3><ul>
<li>优先使用栈：适合小型、短生命周期的数据</li>
<li>必要时用堆：大型数据或需要长生命周期时使用</li>
</ul>
<h2 id="75-关于-shared-ptr-的注意事项（20-智能指针）"><a href="#75-关于-shared-ptr-的注意事项（20-智能指针）" class="headerlink" title="75. 关于 shared_ptr 的注意事项（20. 智能指针）"></a>75. 关于 <code>shared_ptr</code> 的注意事项（20. 智能指针）</h2><p>关于 <code>shared_ptr</code> 的注意事项：</p>
<ul>
<li><p><strong>不要用一个裸指针初始化多个 <code>shared_ptr</code></strong>，会出现 <em><strong>double_free</strong></em> 导致程序崩溃</p>
</li>
<li><p>通过 <code>shared_from_this()</code> 返回 this 指针，不要把 this 指针作为 <code>shared_ptr</code> 返回出来，因为 <code>this</code> 指针本质就是裸指针，通过 this 返回可能会导致重复析构，<strong>不能把 this 指针交给智能指针管理</strong>。</p>
</li>
<li><p>尽量使用 <code>std::make_shared&lt;T&gt;()</code>，少用 <code>new</code></p>
</li>
<li><p><strong>不要 <code>delete</code> <code>get()</code> 返回的裸指针</strong></p>
</li>
<li><p><strong>不是 <code>new</code> 出来的空间要自定义删除器</strong></p>
</li>
<li><p><strong>要避免循环引用</strong>，循环引用导致内存永远不会被释放，造成内存泄漏（不在赘述）</p>
</li>
</ul>
<h3 id="1-不要用一个裸指针初始化多个-shared-ptr（会导致-double-free）"><a href="#1-不要用一个裸指针初始化多个-shared-ptr（会导致-double-free）" class="headerlink" title="1. 不要用一个裸指针初始化多个 shared_ptr（会导致 double free）"></a>1. 不要用一个裸指针初始化多个 <code>shared_ptr</code>（会导致 double free）</h3><p>问题场景：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* raw_ptr = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">42</span>);</span><br><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">sp1</span><span class="params">(raw_ptr)</span></span>;</span><br><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">sp2</span><span class="params">(raw_ptr)</span></span>;  <span class="comment">// 危险！</span></span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>两个独立的 <code>shared_ptr</code> 会<strong>各自维护</strong>一个引用计数控制块（相互独立）</li>
<li>当 <code>sp1</code> 和 <code>sp2</code> 销毁时都会尝试释放 <code>raw_ptr</code>，导致 <strong>双重释放</strong>（double free）</li>
<li>结果通常是程序崩溃或未定义行为</li>
</ul>
<p>正确做法：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法1：直接使用 make_shared</span></span><br><span class="line"><span class="comment">// make_shared 一次性分配内存，包含控制块（引用计数、弱引用计数等）；对象存储空间（存储实际值 42）</span></span><br><span class="line"><span class="keyword">auto</span> sp1 = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">42</span>);</span><br><span class="line"><span class="keyword">auto</span> sp2 = sp1;  <span class="comment">// 只是复制指针并增加引用计数，两个 shared_ptr 指向同一个控制块，共享所有权</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法2：如果必须从裸指针创建，确保只创建一次 shared_ptr</span></span><br><span class="line"><span class="type">int</span>* raw_ptr = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">42</span>);</span><br><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">sp1</span><span class="params">(raw_ptr)</span></span>;</span><br><span class="line">std::shared_ptr&lt;<span class="type">int</span>&gt; sp2 = sp1;  <span class="comment">// 复制的是控制块指针，不是重新创建控制块，共享同一个控制块</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="2-正确使用-shared-from-this-而不是直接返回-this-指针"><a href="#2-正确使用-shared-from-this-而不是直接返回-this-指针" class="headerlink" title="2. 正确使用 shared_from_this() 而不是直接返回 this 指针"></a>2. 正确使用 <code>shared_from_this()</code> 而不是直接返回 <code>this</code> 指针</h3><p>问题场景：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BadExample</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">std::shared_ptr&lt;BadExample&gt; <span class="title">get_this</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">shared_ptr</span>&lt;BadExample&gt;(<span class="keyword">this</span>);  <span class="comment">// 危险！</span></span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> obj = std::<span class="built_in">make_shared</span>&lt;BadExample&gt;();</span><br><span class="line"><span class="keyword">auto</span> another_ref = obj-&gt;<span class="built_in">get_this</span>();  <span class="comment">// 创建了独立的控制块</span></span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>这会创建两个独立的 <code>shared_ptr</code> 控制块</li>
<li>当两个 <code>shared_ptr</code> 销毁时都会尝试析构同一个对象</li>
</ul>
<p>正确做法：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GoodExample</span> : <span class="keyword">public</span> std::enable_shared_from_this&lt;GoodExample&gt; {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">std::shared_ptr&lt;GoodExample&gt; <span class="title">get_this</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">shared_from_this</span>();  <span class="comment">// 安全</span></span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> obj = std::<span class="built_in">make_shared</span>&lt;GoodExample&gt;();</span><br><span class="line"><span class="keyword">auto</span> another_ref = obj-&gt;<span class="built_in">get_this</span>();  <span class="comment">// 共享同一个控制块</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="3-优先使用-std-make-shared-而不是-new"><a href="#3-优先使用-std-make-shared-而不是-new" class="headerlink" title="3. 优先使用 std::make_shared<T>() 而不是 new"></a>3. 优先使用 <code>std::make_shared&lt;T&gt;()</code> 而不是 <code>new</code></h3><p>问题场景：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line"><span class="function">std::shared_ptr&lt;MyClass&gt; <span class="title">sp</span><span class="params">(<span class="keyword">new</span> MyClass(arg1, arg2))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐</span></span><br><span class="line"><span class="keyword">auto</span> sp = std::<span class="built_in">make_shared</span>&lt;MyClass&gt;(arg1, arg2);</span><br></pre></td></tr></tbody></table></figure>

<p>优势：</p>
<ol>
<li>性能更好：单次内存分配（对象 + 控制块）</li>
<li>异常安全：不会在 <code>new</code> 和 <code>shared_ptr</code> 构造之间发生泄漏</li>
<li>代码更简洁：不需要重复类型名称</li>
<li>缓存友好：对象和控制块内存相邻</li>
</ol>
<p>例外情况：</p>
<ul>
<li>需要自定义删除器时</li>
<li>需要指定特殊的内存分配方式时</li>
</ul>
<h3 id="4-不要-delete-get-返回的裸指针"><a href="#4-不要-delete-get-返回的裸指针" class="headerlink" title="4. 不要 delete get() 返回的裸指针"></a>4. 不要 <code>delete</code> <code>get()</code> 返回的裸指针</h3><p>问题场景：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> sp = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">42</span>);</span><br><span class="line"><span class="type">int</span>* raw_ptr = sp.<span class="built_in">get</span>();</span><br><span class="line"><span class="keyword">delete</span> raw_ptr;  <span class="comment">// 灾难性错误！</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 当 sp 超出作用域时，会再次尝试删除已删除的内存</span></span><br></pre></td></tr></tbody></table></figure>

<ul>
<li><code>shared_ptr</code> <strong>仍然拥有内存所有权</strong></li>
<li>手动 <code>delete</code> 会导致：<ul>
<li>double free</li>
<li>控制块状态不一致</li>
<li>未定义行为（通常崩溃）</li>
</ul>
</li>
</ul>
<p>正确做法：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> sp = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">42</span>);</span><br><span class="line"><span class="type">int</span>* raw_ptr = sp.<span class="built_in">get</span>();</span><br><span class="line"><span class="comment">// 仅使用 raw_ptr 进行读取/写入操作，绝不手动删除它</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="5-非-new-分配的内存需要自定义删除器"><a href="#5-非-new-分配的内存需要自定义删除器" class="headerlink" title="5. 非 new 分配的内存需要自定义删除器"></a>5. 非 <code>new</code> 分配的内存需要自定义删除器</h3><p>问题场景：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从 malloc 分配的内存</span></span><br><span class="line"><span class="type">void</span>* mem = <span class="built_in">malloc</span>(<span class="number">1024</span>);</span><br><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">void</span>&gt; <span class="title">sp</span><span class="params">(mem)</span></span>;  <span class="comment">// 错误！会用 delete 而不是 free</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 文件指针</span></span><br><span class="line">FILE* fp = <span class="built_in">fopen</span>(<span class="string">"file.txt"</span>, <span class="string">"r"</span>);</span><br><span class="line"><span class="function">std::shared_ptr&lt;FILE&gt; <span class="title">sp</span><span class="params">(fp)</span></span>;  <span class="comment">// 错误！会用 delete 而不是 fclose</span></span><br></pre></td></tr></tbody></table></figure>

<p>正确做法：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用自定义删除器（lambda 表达式作为删除器）</span></span><br><span class="line"><span class="type">void</span>* mem = <span class="built_in">malloc</span>(<span class="number">1024</span>);</span><br><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">void</span>&gt; <span class="title">sp</span><span class="params">(mem, free)</span></span>;  <span class="comment">// 使用 free 作为删除器</span></span><br><span class="line"></span><br><span class="line">FILE* fp = <span class="built_in">fopen</span>(<span class="string">"file.txt"</span>, <span class="string">"r"</span>);</span><br><span class="line"><span class="function">std::shared_ptr&lt;FILE&gt; <span class="title">sp</span><span class="params">(fp, [](FILE* f) { fclose(f); })</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于数组</span></span><br><span class="line"><span class="type">int</span>* arr = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>];</span><br><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">sp</span><span class="params">(arr, [](<span class="type">int</span>* p) { <span class="keyword">delete</span>[] p; })</span></span>;</span><br></pre></td></tr></tbody></table></figure>

<p>常见删除器场景：</p>
<ol>
<li>C 风格内存分配（<code>malloc/calloc/realloc</code>）→ 使用 <code>free</code></li>
<li>文件操作（<code>fopen</code>）→ 使用 <code>fclose</code></li>
<li>系统资源（套接字、句柄等）→ 使用对应的释放函数</li>
<li>数组 → 使用 <code>delete[]</code></li>
</ol>
<h3 id="6-避免循环引用导致的内存泄露"><a href="#6-避免循环引用导致的内存泄露" class="headerlink" title="6. 避免循环引用导致的内存泄露"></a>6. 避免循环引用导致的内存泄露</h3><h4 id="问题场景-1"><a href="#问题场景-1" class="headerlink" title="问题场景 1"></a>问题场景 1</h4><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::shared_ptr&lt;B&gt; b;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::shared_ptr&lt;A&gt; a;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    std::shared_ptr&lt;A&gt; ap = std::<span class="built_in">make_shared</span>&lt;A&gt;();</span><br><span class="line">    std::shared_ptr&lt;B&gt; bp = std::<span class="built_in">make_shared</span>&lt;B&gt;();</span><br><span class="line">    ap-&gt;b = bp;</span><br><span class="line">    bp-&gt;a = ap;</span><br><span class="line">    <span class="comment">// 此时，a 和 b 相互持有对方的 shared_ptr，形成循环引用</span></span><br><span class="line">    <span class="comment">// 程序结束时，a 和 b 的引用计数都不会降为零，导致内存泄漏</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="问题场景-2"><a href="#问题场景-2" class="headerlink" title="问题场景 2"></a>问题场景 2</h4><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::shared_ptr&lt;Node&gt; next;</span><br><span class="line">    std::shared_ptr&lt;Node&gt; prev;  <span class="comment">// 双向链表导致循环引用</span></span><br><span class="line">    ~<span class="built_in">Node</span>() { std::cout &lt;&lt; <span class="string">"Node destroyed\n"</span>; }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> node1 = std::<span class="built_in">make_shared</span>&lt;Node&gt;();</span><br><span class="line"><span class="keyword">auto</span> node2 = std::<span class="built_in">make_shared</span>&lt;Node&gt;();</span><br><span class="line">node1-&gt;next = node2;</span><br><span class="line">node2-&gt;prev = node1;  <span class="comment">// 循环引用形成！</span></span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>当 <code>node1</code> 和 <code>node2</code> 离开作用域时：<ul>
<li><code>node1</code> 的引用计数从 1→0？不，因为 <code>node2-&gt;prev</code> 还持有引用（实际从 2→1）</li>
<li><code>node2</code> 的引用计数同样从 2→1</li>
</ul>
</li>
<li>结果：<strong>两者引用计数永远不为 0</strong>，内存永远不会释放</li>
</ul>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">node1 [refcount=2] --&gt; Node1对象</span><br><span class="line">  ↑next               ↓prev</span><br><span class="line">Node2对象 &lt;-- [refcount=2] node2</span><br></pre></td></tr></tbody></table></figure>

<p>解决方案：<code>weak_ptr</code></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SafeNode</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::shared_ptr&lt;SafeNode&gt; next;</span><br><span class="line">    std::weak_ptr&lt;SafeNode&gt; prev;  <span class="comment">// 使用weak_ptr</span></span><br><span class="line">    </span><br><span class="line">    ~<span class="built_in">SafeNode</span>() { std::cout &lt;&lt; <span class="string">"SafeNode destroyed\n"</span>; }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> node1 = std::<span class="built_in">make_shared</span>&lt;SafeNode&gt;();</span><br><span class="line"><span class="keyword">auto</span> node2 = std::<span class="built_in">make_shared</span>&lt;SafeNode&gt;();</span><br><span class="line">node1-&gt;next = node2;</span><br><span class="line">node2-&gt;prev = node1;  <span class="comment">// weak_ptr不会增加引用计数</span></span><br></pre></td></tr></tbody></table></figure>

<h4 id="何时会出现循环引用？"><a href="#何时会出现循环引用？" class="headerlink" title="何时会出现循环引用？"></a>何时会出现循环引用？</h4><ul>
<li>双向链表、树结构等复杂数据结构</li>
<li>对象相互持有对方的 <code>shared_ptr</code></li>
<li>父子对象互相强引用</li>
<li>观察者模式中主体和观察者互相持有</li>
</ul>
<h2 id="76-std-shared-ptr-可以通过-std-make-shared-和直接使用-new-表达式构造，二者有什么区别？"><a href="#76-std-shared-ptr-可以通过-std-make-shared-和直接使用-new-表达式构造，二者有什么区别？" class="headerlink" title="76. std::shared_ptr 可以通过 std::make_shared 和直接使用 new 表达式构造，二者有什么区别？"></a>76. <code>std::shared_ptr</code> 可以通过 <code>std::make_shared</code> 和直接使用 <code>new</code> 表达式构造，二者有什么区别？</h2><p>在 C++ 中，<code>std::shared_ptr</code> 可以通过 <code>std::make_shared</code> 和直接使用 <code>new</code> 表达式构造，但二者在内存管理、性能和异常安全性方面有显著区别：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 推荐方式：高效且安全</span></span><br><span class="line"><span class="keyword">auto</span> sp1 = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">42</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不推荐：性能更低且可能泄漏</span></span><br><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">sp2</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">42</span>))</span></span>;</span><br></pre></td></tr></tbody></table></figure>

<h3 id="1-内存分配方式"><a href="#1-内存分配方式" class="headerlink" title="1. 内存分配方式"></a>1. 内存分配方式</h3><ul>
<li><p><code>make_shared</code>：一次性分配内存，同时存储对象本身和控制块（引用计数等）。这是更高效的内存布局，减少了内存碎片和分配次数</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> sp = std::<span class="built_in">make_shared</span>&lt;Widget&gt;(args...); <span class="comment">// 单次分配</span></span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p><code>new</code> + <code>shared_ptr</code> 构造函数：需要两次内存分配，一次为对象（<code>new</code>），另一次为控制块（由 <code>shared_ptr</code> 构造函数触发）</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::shared_ptr&lt;Widget&gt; <span class="title">sp</span><span class="params">(<span class="keyword">new</span> Widget(args...))</span></span>; <span class="comment">// 两次分配</span></span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h3 id="2-性能差异"><a href="#2-性能差异" class="headerlink" title="2. 性能差异"></a>2. 性能差异</h3><ul>
<li><code>make_shared</code> 更快：单次内存分配减少了开销，尤其当频繁创建/销毁 <code>shared_ptr</code> 时更明显。</li>
<li><code>new</code> 额外开销：两次分配可能引入性能损耗（尤其是对小型对象）。</li>
</ul>
<blockquote>
<p>解释</p>
</blockquote>
<p>每次 <code>new</code>/<code>malloc</code> 都是一次系统调用：操作系统需要查找合适的内存块、更新内存管理数据结构（如空闲链表），可能触发缺页中断或内核态切换，这些操作本身就有固定开销。两次分配就会有双倍开销。</p>
<p>从内存局部性角度来看：</p>
<ul>
<li><code>make_shared</code> 的内存是连续的，对象和控制块在单块内存中紧密排列，缓存命中率更高。</li>
<li><code>new</code> 的内存可能是分散的，对象和控制块位于不同内存区域，访问时可能触发多次缓存加载，同时产生更多内存碎片。</li>
</ul>
<h3 id="3-异常安全性"><a href="#3-异常安全性" class="headerlink" title="3. 异常安全性"></a>3. 异常安全性</h3><ul>
<li><p><code>make_shared</code> 是异常安全的：若构造函数抛出异常，不会发生内存泄漏（因为内存已由智能指针系统托管）。  </p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">process</span>(std::<span class="built_in">make_shared</span>&lt;Widget&gt;(a, b), <span class="built_in">may_throw</span>()); <span class="comment">// 安全</span></span><br></pre></td></tr></tbody></table></figure></li>
<li><p><code>new</code> 可能泄漏：如果 <code>new</code> 成功但 <code>shared_ptr</code> 构造前发生异常，对象不会被释放：  </p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">process</span>(std::<span class="built_in">shared_ptr</span>&lt;Widget&gt;(<span class="keyword">new</span> <span class="built_in">Widget</span>(a, b)), <span class="built_in">may_throw</span>()); <span class="comment">// 可能泄漏</span></span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h3 id="4-对象生命周期的影响"><a href="#4-对象生命周期的影响" class="headerlink" title="4. 对象生命周期的影响"></a>4. 对象生命周期的影响</h3><ul>
<li><code>make_shared</code> 的延迟释放：对象内存和控制块是连续的，即使引用计数归零，<strong>对象占用的内存可能直到控制块也被释放时才归还</strong>（例如弱引用 <code>weak_ptr</code> 仍存在时）。</li>
<li><code>new</code> 的独立释放：对象内存和控制块分离，对象内存会在引用计数归零时立即释放，控制块则等待所有 <code>weak_ptr</code> 释放后才回收。</li>
</ul>
<h3 id="5-使用场景限制"><a href="#5-使用场景限制" class="headerlink" title="5. 使用场景限制"></a>5. 使用场景限制</h3><ul>
<li>必须用 <code>new</code> 的情况：需要自定义删除器或需从已有裸指针构造时。  <figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::shared_ptr&lt;Widget&gt; <span class="title">sp</span><span class="params">(<span class="keyword">new</span> Widget, custom_deleter)</span></span>;</span><br></pre></td></tr></tbody></table></figure></li>
<li>优先用 <code>make_shared</code>：默认情况下推荐使用，除非有特殊需求。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><table>
<thead>
<tr>
<th>特性</th>
<th><code>make_shared</code></th>
<th><code>new</code> + <code>shared_ptr</code></th>
</tr>
</thead>
<tbody><tr>
<td>内存分配次数</td>
<td>1 次</td>
<td>2 次</td>
</tr>
<tr>
<td>异常安全</td>
<td>是</td>
<td>否（可能泄漏）</td>
</tr>
<tr>
<td>内存释放时机</td>
<td>对象和控制块一起释放</td>
<td>对象先释放，控制块后释放</td>
</tr>
<tr>
<td>自定义删除器</td>
<td>不支持</td>
<td>支持</td>
</tr>
</tbody></table>
<p><strong>最佳实践</strong>：默认使用 <code>make_shared</code>，除非需要自定义删除器或特殊内存管理。</p>
<h2 id="77-shared-ptr-的引用计数是在栈还是堆？"><a href="#77-shared-ptr-的引用计数是在栈还是堆？" class="headerlink" title="77. shared_ptr 的引用计数是在栈还是堆？"></a>77. <code>shared_ptr</code> 的引用计数是在栈还是堆？</h2><p>在 <code>std::shared_ptr</code> 的实现中，引用计数（控制块）存储在堆上，为了<strong>共享</strong>这个这个 reference count 值。</p>
<ul>
<li><code>shared_ptr</code> 和 <code>weak_ptr</code> 可能被拷贝、传递到不同的作用域（如函数调用、线程间共享）。如果引用计数在栈上，它会在栈帧销毁时被释放，导致其他指针无法正确跟踪计数。<ul>
<li><code>make_shared</code> 会将对象数据和引用计数分配在同一块堆内存中</li>
<li><code>new</code> + <code>shared_ptr</code> 则是将对象数据和引用计数分配在两块独立的堆内存</li>
</ul>
</li>
<li>虽然引用计数本身在堆上，但 <code>shared_ptr</code> 的实例（即指针对象本身）可以存储在栈上</li>
</ul>
<blockquote>
<p>总结</p>
</blockquote>
<table>
<thead>
<tr>
<th align="left">存储位置</th>
<th align="left">内容</th>
<th align="left">原因</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>堆内存</strong></td>
<td align="left">引用计数（控制块）、对象数据</td>
<td align="left">需要动态生命周期管理，支持多指针共享，跨作用域存活。</td>
</tr>
<tr>
<td align="left"><strong>栈内存</strong></td>
<td align="left"><code>shared_ptr</code> 实例本身</td>
<td align="left">栈对象自动析构，通过析构函数减少堆上的引用计数，必要时释放对象内存。</td>
</tr>
</tbody></table>
<h2 id="78-基类的虚函数可以声明为-private-吗"><a href="#78-基类的虚函数可以声明为-private-吗" class="headerlink" title="78. 基类的虚函数可以声明为 private 吗"></a>78. 基类的虚函数可以声明为 <code>private</code> 吗</h2><p>基类的虚函数可以声明为 <code>private</code>，但这会影响其可访问性和多态行为的使用方式。</p>
<h3 id="语法允许，但访问受限"><a href="#语法允许，但访问受限" class="headerlink" title="语法允许，但访问受限"></a>语法允许，但访问受限</h3><p>从语法层面，C++ 允许虚函数为 <code>private</code>，编译器不会报错。</p>
<p>派生类不能通过基类指针/引用直接访问 <code>private</code> 虚函数（违反访问控制规则）</p>
<h3 id="多态行为仍然有效"><a href="#多态行为仍然有效" class="headerlink" title="多态行为仍然有效"></a>多态行为仍然有效</h3><p>如果基类提供公有方法调用私有虚函数，派生类重写该私有虚函数后，多态仍能正常工作。</p>
<ul>
<li>派生类重写 <code>foo()</code> 时也必须为 <code>private</code>（访问权限可以更宽松，但不能更严格）。</li>
</ul>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">callFoo</span><span class="params">()</span> </span>{ <span class="built_in">foo</span>(); }  <span class="comment">// 公有接口调用私有虚函数</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>{ std::cout &lt;&lt; <span class="string">"Base::foo"</span>; }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base {</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> <span class="keyword">override</span> </span>{ std::cout &lt;&lt; <span class="string">"Derived::foo"</span>; }  <span class="comment">// 重写私有虚函数</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    Base* ptr = <span class="keyword">new</span> Derived;</span><br><span class="line">    ptr-&gt;<span class="built_in">callFoo</span>();  <span class="comment">// 输出 "Derived::foo"（多态生效）</span></span><br><span class="line">    <span class="keyword">delete</span> ptr;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>对比其他权限</p>
</blockquote>
<table>
<thead>
<tr>
<th align="left">虚函数权限</th>
<th align="left">派生类能否直接调用</th>
<th align="left">派生类能否重写</th>
<th align="left">外部代码能否调用</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>public</code></td>
<td align="left">✅</td>
<td align="left">✅</td>
<td align="left">✅</td>
</tr>
<tr>
<td align="left"><code>protected</code></td>
<td align="left">✅</td>
<td align="left">✅</td>
<td align="left">❌</td>
</tr>
<tr>
<td align="left"><code>private</code></td>
<td align="left">❌</td>
<td align="left">✅（需同权限或更宽松）</td>
<td align="left">❌</td>
</tr>
</tbody></table>
<h2 id="79-如果有-100-个对象，vector、list、map-哪个占用内存高"><a href="#79-如果有-100-个对象，vector、list、map-哪个占用内存高" class="headerlink" title="79. 如果有 100 个对象，vector、list、map 哪个占用内存高"></a>79. 如果有 100 个对象，<code>vector</code>、<code>list</code>、<code>map</code> 哪个占用内存高</h2><p>这个问题本质上考察 STL 容器的内存占用特性。假设我们存放 100 个对象（比如大小相同的自定义类对象），不同容器的内存开销差别主要来自于元素存储方式和额外的结构体开销。</p>
<h3 id="1-vector"><a href="#1-vector" class="headerlink" title="1. vector"></a>1. <code>vector</code></h3><ul>
<li><strong>存储方式</strong>：底层是 <strong>动态数组</strong>，所有元素连续存放。</li>
<li><strong>额外开销</strong>：<ul>
<li>仅仅是 <code>vector</code> 自身维护的三个指针（begin/end/capacity_end），常见实现 24 字节左右。</li>
<li>可能有 <strong>容量冗余</strong>（capacity ≥ size），但不是很大。</li>
</ul>
</li>
<li><strong>内存占用</strong>：<ul>
<li>接近 <strong>100 × sizeof(对象)</strong>，几乎没有额外 per-element 的开销。</li>
<li>在三者中最节省内存。</li>
</ul>
</li>
</ul>
<h3 id="2-list"><a href="#2-list" class="headerlink" title="2. list"></a>2. <code>list</code></h3><ul>
<li><strong>存储方式</strong>：双向链表，每个节点独立分配。</li>
<li><strong>额外开销</strong>：<ul>
<li>每个节点除了存放对象，还要存放两个指针（prev/next），常见实现 16 字节或更多。</li>
<li>由于频繁分配，可能带来额外的 <strong>堆分配和内存碎片开销</strong>。</li>
</ul>
</li>
<li><strong>内存占用</strong>：<ul>
<li>大约 <strong>100 × (sizeof(对象) + 2 × sizeof(指针))</strong>，比 <code>vector</code> 高不少。</li>
<li>在这三者里通常是最浪费内存的。</li>
</ul>
</li>
</ul>
<h3 id="3-map（通常是红黑树）"><a href="#3-map（通常是红黑树）" class="headerlink" title="3. map（通常是红黑树）"></a>3. <code>map</code>（通常是红黑树）</h3><ul>
<li><strong>存储方式</strong>：红黑树节点，每个节点存放 <code>(key, value)</code>，还有指针和颜色信息。</li>
<li><strong>额外开销</strong>：<ul>
<li>一个节点要维护 <strong>父、左、右指针</strong>（3 个指针 = 24 字节）+ <strong>颜色位</strong>（通常填充到 4 字节）。</li>
<li>还要存放键和值对象。</li>
</ul>
</li>
<li><strong>内存占用</strong>：<ul>
<li>大约 <strong>100 × (sizeof(key) + sizeof(value) + 3 × sizeof(指针) + padding)</strong>。</li>
<li>如果 key/value 很小（比如 int/int），开销主要是结构体本身，<strong>比 list 更大</strong>。</li>
</ul>
</li>
</ul>
<h3 id="结论（内存占用比较）"><a href="#结论（内存占用比较）" class="headerlink" title="结论（内存占用比较）"></a>结论（内存占用比较）</h3><p>在存放 100 个对象时，三者大致的内存占用从低到高为：<code>vector</code> &lt; <code>list</code> &lt; <code>map</code></p>
<ul>
<li><code>vector</code>：最节省空间，几乎没有额外 per-element 开销。</li>
<li><code>list</code>：由于链表节点指针和堆分配，开销中等。</li>
<li><code>map</code>：红黑树节点开销更大（指针 + 平衡因子等），通常是最高的。</li>
</ul>
<h2 id="80-虚函数表和虚函数指针存储在哪里？"><a href="#80-虚函数表和虚函数指针存储在哪里？" class="headerlink" title="80. 虚函数表和虚函数指针存储在哪里？"></a>80. 虚函数表和虚函数指针存储在哪里？</h2><h3 id="虚函数表（vtable）"><a href="#虚函数表（vtable）" class="headerlink" title="虚函数表（vtable）"></a>虚函数表（vtable）</h3><ul>
<li>位置：<ul>
<li><strong>编译器生成的全局静态表</strong>，在程序的 <strong>只读数据区（.rodata）</strong> 或类似的静态存储区域。</li>
<li>每个包含虚函数的类（以及其派生类）通常对应一张或多张虚函数表。</li>
<li>表的内容是 <strong>函数指针数组</strong>，指向该类对应的虚函数实现。</li>
</ul>
</li>
<li>特点：<ul>
<li>程序运行时不会修改表的位置，只会改变对象中的指针指向哪一张表。</li>
<li>继承 + 覆盖虚函数时，子类的 vtable 会覆盖父类条目。</li>
</ul>
</li>
</ul>
<h3 id="虚函数指针（vptr）"><a href="#虚函数指针（vptr）" class="headerlink" title="虚函数指针（vptr）"></a>虚函数指针（vptr）</h3><ul>
<li><strong>位置</strong>：<ul>
<li>在 <strong>对象实例的内存中</strong>，通常存放在对象的头部。</li>
<li>每个对象都有一个 vptr，指向对应类的 vtable。</li>
<li>如果类有多个虚继承/多继承，可能会有多个 vptr。</li>
</ul>
</li>
<li><strong>初始化</strong>：<ul>
<li>编译器在构造函数中插入代码，把对象的 vptr 指向正确的 vtable。</li>
<li>析构时，也会相应调整 vptr 以保证多态析构正确。</li>
</ul>
</li>
</ul>
<h3 id="举例与总结"><a href="#举例与总结" class="headerlink" title="举例与总结"></a>举例与总结</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>程序里会生成两张 vtable：<ul>
<li><code>Base</code> 的 vtable，里面有 <code>&amp;Base::foo</code></li>
<li><code>Derived</code> 的 vtable，里面有 <code>&amp;Derived::foo</code></li>
</ul>
</li>
<li><code>Base</code> 或 <code>Derived</code> 对象实例的内存中，都会有一个 <strong>vptr</strong> 指针，指向相应的 vtable。</li>
</ul>
<p>总结</p>
<ul>
<li><strong>虚函数表（vtable）</strong>：编译器生成的全局静态表，存放在只读数据段。</li>
<li><strong>虚函数指针（vptr）</strong>：存放在对象实例内存中（通常在开头），指向该对象对应的 vtable。</li>
</ul>
<h2 id="81-多线程编程一般用哪些库函数？"><a href="#81-多线程编程一般用哪些库函数？" class="headerlink" title="81. 多线程编程一般用哪些库函数？"></a>81. 多线程编程一般用哪些库函数？</h2><h3 id="C-语言层面"><a href="#C-语言层面" class="headerlink" title="C 语言层面"></a>C 语言层面</h3><ul>
<li><strong>POSIX Threads (pthread)</strong>：<code>pthread_create</code>、<code>pthread_join</code>、<code>pthread_mutex_lock</code>、<code>pthread_cond_wait</code> 等，Linux/Unix 常用。</li>
<li><strong>C11 标准库</strong>：<code>thrd_create</code>、<code>mtx_lock</code>（但在实际项目里用得少）。</li>
</ul>
<h3 id="C-层面"><a href="#C-层面" class="headerlink" title="C++ 层面"></a>C++ 层面</h3><ul>
<li><strong>C++11 标准库</strong>：<ul>
<li><code>std::thread</code>（线程创建/管理）</li>
<li><code>std::mutex</code>、<code>std::recursive_mutex</code>、<code>std::timed_mutex</code>（互斥量）</li>
<li><code>std::lock_guard</code>、<code>std::unique_lock</code>（RAII 封装锁）</li>
<li><code>std::condition_variable</code>（条件变量）</li>
<li><code>std::future</code> / <code>std::promise</code> / <code>std::async</code>（任务并发模型）</li>
</ul>
</li>
</ul>
<h2 id="82-为什么需要锁？什么时候需要多线程？举个例子"><a href="#82-为什么需要锁？什么时候需要多线程？举个例子" class="headerlink" title="82. 为什么需要锁？什么时候需要多线程？举个例子"></a>82. 为什么需要锁？什么时候需要多线程？举个例子</h2><blockquote>
<p>为什么需要锁</p>
</blockquote>
<ul>
<li>多线程共享内存 → 存在 <strong>竞态条件（race condition）</strong>。</li>
<li>如果两个线程同时读写同一变量，可能导致数据不一致。</li>
<li><strong>锁（mutex）</strong> 的作用就是保证某段代码在同一时刻只有一个线程能进入，维持数据一致性。</li>
</ul>
<blockquote>
<p>什么时候需要多线程</p>
</blockquote>
<ul>
<li><strong>计算密集型任务</strong>：利用多核 CPU，提高吞吐量（例如矩阵运算、图像处理）。</li>
<li><strong>I/O 密集型任务</strong>：一个线程阻塞 I/O 时，其他线程可以继续执行（例如服务器同时处理多个客户端请求）。</li>
</ul>
<blockquote>
<p>举例</p>
</blockquote>
<p>写一个多线程日志系统：</p>
<ul>
<li>多个工作线程处理业务逻辑，把日志消息写入一个共享队列。</li>
<li>一个单独线程从队列取日志写文件。</li>
<li>共享队列必须加锁，否则多线程写入会导致数据错乱。</li>
</ul>
<h2 id="83-多线程场景下出现内存泄漏怎么调试解决？"><a href="#83-多线程场景下出现内存泄漏怎么调试解决？" class="headerlink" title="83. 多线程场景下出现内存泄漏怎么调试解决？"></a>83. 多线程场景下出现内存泄漏怎么调试解决？</h2><blockquote>
<p>原因</p>
</blockquote>
<ul>
<li>某些线程申请的内存没有释放，线程退出后仍然占用。</li>
<li>使用 TLS（线程局部存储）或全局变量，线程结束时忘记清理。</li>
<li>线程之间交互复杂，某些分支忘记释放内存。</li>
</ul>
<blockquote>
<p>常见调试手段</p>
</blockquote>
<ul>
<li><strong>工具</strong>：<ul>
<li><code>valgrind --tool=memcheck</code>（Linux）</li>
<li><code>asan</code>（AddressSanitizer）</li>
<li><code>gdb</code></li>
</ul>
</li>
<li><strong>策略</strong>：<ul>
<li>用 RAII（C++）避免手动 <code>new/delete</code>。</li>
<li>尽量使用智能指针（<code>std::unique_ptr</code>、<code>std::shared_ptr</code>）。</li>
<li>保证线程退出时执行清理逻辑（析构函数/<code>pthread_cleanup_push</code>）。</li>
</ul>
</li>
<li><strong>分而治之</strong>：把怀疑的线程单独跑，缩小问题范围。</li>
</ul>
<p>下文详细介绍下「gdb 多线程调试」与「打日志 + 线上定位 + 复现副本」这两种方式。</p>
<p>当然能用 gdb 调多线程，而且<strong>线上定位</strong>常常要配合“打日志 + 复现副本”的办法一起用。下面给你一套“面试可讲、实际可用”的流程和要点。</p>
<h3 id="1-用-gdb-调多线程的实用套路"><a href="#1-用-gdb-调多线程的实用套路" class="headerlink" title="(1) 用 gdb 调多线程的实用套路"></a>(1) 用 gdb 调多线程的实用套路</h3><h4 id="基本操作（本地或-attach-线上进程）"><a href="#基本操作（本地或-attach-线上进程）" class="headerlink" title="基本操作（本地或 attach 线上进程）"></a>基本操作（本地或 attach 线上进程）</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 运行时调试</span></span><br><span class="line">gdb ./your_program</span><br><span class="line">(gdb) run ...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 附加到线上/本地正在跑的进程</span></span><br><span class="line">gdb -p &lt;PID&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 一次性抓所有线程的栈</span></span><br><span class="line">(gdb) thread apply all bt</span><br><span class="line">(gdb) thread apply all bt full     <span class="comment"># 带局部变量</span></span><br><span class="line">(gdb) info threads                 <span class="comment"># 线程列表</span></span><br><span class="line">(gdb) thread &lt;<span class="built_in">id</span>&gt;                  <span class="comment"># 切换线程</span></span><br><span class="line">(gdb) bt                           <span class="comment"># 当前线程回溯</span></span><br></pre></td></tr></tbody></table></figure>

<h4 id="让单步-断点更可控（避免线程乱切）"><a href="#让单步-断点更可控（避免线程乱切）" class="headerlink" title="让单步/断点更可控（避免线程乱切）"></a>让单步/断点更可控（避免线程乱切）</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) <span class="built_in">set</span> scheduler-locking on     <span class="comment"># 单步时不让其它线程抢占（on/step可选）</span></span><br><span class="line">(gdb) <span class="built_in">set</span> pagination off</span><br></pre></td></tr></tbody></table></figure>

<h4 id="条件断点-竞争点观察"><a href="#条件断点-竞争点观察" class="headerlink" title="条件断点 / 竞争点观察"></a>条件断点 / 竞争点观察</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 只在指定线程/条件触发</span></span><br><span class="line">(gdb) <span class="built_in">break</span> file.cpp:123 <span class="keyword">if</span> pthread_self() == target_tid &amp;&amp; counter &lt; 0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 监视内存写（找“谁改了这个变量/指针”）</span></span><br><span class="line">(gdb) watch some_global_ptr</span><br><span class="line">(gdb) rwatch x   <span class="comment"># 读监视</span></span><br><span class="line">(gdb) awatch x   <span class="comment"># 读写监视</span></span><br></pre></td></tr></tbody></table></figure>

<h4 id="线程与锁问题的专招"><a href="#线程与锁问题的专招" class="headerlink" title="线程与锁问题的专招"></a>线程与锁问题的专招</h4><ul>
<li><p><strong>死锁/卡住</strong>：先 <code>gdb -p PID</code>，再 <code>thread apply all bt full</code> 看各线程卡在什么锁/条件变量处；很多时候能直接看出两个线程的互相等待链。</p>
</li>
<li><p><strong>条件变量</strong>：在 <code>pthread_cond_wait</code>、<code>pthread_mutex_lock</code> 处下断点或打条件断点，确认唤醒与加锁顺序。</p>
</li>
<li><p><strong>跟踪线程创建</strong>：记录是谁创建了问题线程。</p>
  <figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(gdb) <span class="built_in">break</span> pthread_create</span><br><span class="line">(gdb) commands</span><br><span class="line">&gt; bt</span><br><span class="line">&gt; c</span><br><span class="line">&gt; end</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h4 id="核心转储（coredump）事后排查"><a href="#核心转储（coredump）事后排查" class="headerlink" title="核心转储（coredump）事后排查"></a>核心转储（coredump）事后排查</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ulimit</span> -c unlimited</span><br><span class="line"><span class="comment"># 触发崩溃后</span></span><br><span class="line">gdb ./your_program core</span><br><span class="line">(gdb) thread apply all bt full</span><br></pre></td></tr></tbody></table></figure>

<p>也可以线上“留存一份 core”，再在离线环境慢慢剖析。</p>
<h4 id="录制-重放"><a href="#录制-重放" class="headerlink" title="录制/重放"></a>录制/重放</h4><ul>
<li><strong>rr</strong>（Linux）：<code>rr record ./prog</code>，复现后用 <code>rr replay</code> 进 gdb，可<strong>时间回溯</strong>到变量被改写的一刻，定位数据竞争/时序问题非常好用。</li>
<li>gdb 的 <code>record full</code> 也能用，但 <code>rr</code> 更稳定。</li>
</ul>
<h3 id="2-打日志→线上定位→复现副本→看日志"><a href="#2-打日志→线上定位→复现副本→看日志" class="headerlink" title="(2) 打日志→线上定位→复现副本→看日志"></a>(2) 打日志→线上定位→复现副本→看日志</h3><p>这是大厂很常见、也很靠谱的<strong>生产级排障方法</strong>：</p>
<ol>
<li><strong>打结构化日志</strong>（并带上标识）<ul>
<li>必带：时间戳、<strong>线程ID</strong>、请求ID/traceID、关键状态（队列长度、锁等待时长、对象地址/指针等）。</li>
<li>在<strong>锁关键点</strong>打点：<code>lock acquire start/ok/timeout</code>、<code>cond wait/signal</code>、<code>enqueue/dequeue</code>、<code>state transition</code>。</li>
<li>遇到潜在死锁，记录<strong>锁名/顺序</strong>和<strong>持有时长</strong>，方便识别锁顺序反转。</li>
</ul>
</li>
<li><strong>定位线上问题副本</strong><ul>
<li>用日志把<strong>异常请求/异常时间窗</strong>圈出来（比如特定用户、某个 shard、某台机器）。</li>
<li>从线上环境<strong>抽一个最小有问题的副本</strong>（相同配置/数据切片/版本/流量）到灰度或隔离环境。</li>
<li>这样能在不影响大盘的情况下<strong>复现</strong>，同时你可以随意加日志、开更高日志级别、甚至 attach gdb。</li>
</ul>
</li>
<li><strong>看日志 + 还原时序</strong><ul>
<li>通过 traceID 串起多个线程/模块的跨调用链，按照时间戳排序，重放“谁先拿了哪个锁、谁等在 cond 上”，从而定位<strong>竞态/死锁/饥饿</strong>。</li>
<li>日志中记录的<strong>内存地址/对象ID</strong>可以让你把若干条看似无关的日志对应到<strong>同一对象实例</strong>。</li>
</ul>
</li>
<li><strong>必要时动用在线栈</strong><ul>
<li>现场卡死时，用 <code>gdb -p PID</code> 或运维脚本（比如发送信号触发 <code>backtrace()</code> dump 全线程栈）把<strong>全线程栈</strong>打印出来，和日志时间窗对比，锁点一目了然。</li>
</ul>
</li>
<li><strong>修复后再灰度验证</strong><ul>
<li>在副本/灰度环境验证“日志告警消失、锁等待时长下降、吞吐恢复”，再全量。</li>
</ul>
</li>
</ol>
<p>这套方法的核心是：<strong>用日志重建并发时序</strong>，用<strong>副本</strong>规避线上风险，用 <strong>gdb/栈/录制</strong>补齐细节。</p>
<h2 id="84-程序的内存布局是怎样的？"><a href="#84-程序的内存布局是怎样的？" class="headerlink" title="84. 程序的内存布局是怎样的？"></a>84. 程序的内存布局是怎样的？</h2><p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/Wu-yikun/OSS@master/uPic/20250821-Ovbyi3.png" alt="image-20240725233029022"></p>
<p>一个典型 C/C++ 程序在内存里的分布大致如下：</p>
<ul>
<li><p>代码段：包括二进制可执行代码，通常只读，还可共享（多个进程运行同一程序时只存一份）；</p>
<blockquote>
<p>静态存储区：数据段 + BSS 段</p>
</blockquote>
</li>
<li><p>数据段：包括已初始化的静态常量和全局变量；</p>
</li>
<li><p>BSS 段：包括未初始化的静态变量和全局变量；</p>
</li>
<li><p>堆（比如 <code>malloc/new</code>）：包括动态分配的内存，从低地址开始向上增长，程序员负责管理，容易泄露；</p>
</li>
<li><p>文件映射区（比如 <code>mmap</code>）：包括共享库、文件映射、匿名映射、共享内存等；</p>
</li>
<li><p>栈：包括局部变量和函数调用的上下文（参数、返回地址）等，函数调用或返回会自动分配与释放后。栈的大小是固定的，一般是 8 MB。当然系统也提供了参数，以便我们自定义大小；</p>
</li>
<li><p>内核空间（对用户程序不可见）</p>
</li>
</ul>
<p>上图中的内存布局可以看到，代码段下面还有一段内存空间的（灰色部分），这一块区域是「保留区」，之所以要有保留区这是因为在大多数的系统里，我们认为比较小数值的地址不是一个合法地址，例如，我们通常在 C 的代码里会将无效的指针赋值为 NULL。因此，这里会出现一段不可访问的内存保留区，防止程序因为出现 bug，导致读或写了一些小内存地址的数据，而使得程序跑飞。</p>
<p>在这 7 个内存段中，堆和文件映射段的内存是动态分配的。比如说，使用 C 标准库的 <code>malloc()</code> 或者 <code>mmap()</code>，就可以分别在堆和文件映射段动态分配内存。</p>
<h2 id="85-delete-释放内存的时候并不知道内存大小，如何释放？"><a href="#85-delete-释放内存的时候并不知道内存大小，如何释放？" class="headerlink" title="85. delete 释放内存的时候并不知道内存大小，如何释放？"></a>85. delete 释放内存的时候并不知道内存大小，如何释放？</h2><blockquote>
<p>涉及 <code>new</code> 和 <code>delete</code> 源码及流程</p>
<p>链接：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1ULYRziEbs/?spm_id_from=333.1387.homepage.video_card.click&amp;vd_source=187e83a375c910488a1ad25cc2465299">pdd 二面</a></p>
</blockquote>
<p><code>delete</code> 运算符在释放内存时确实不需要显式指定大小，因为它依赖底层的内存管理器来跟踪分配块的信息。当使用 <code>new</code> 分配内存时，内存管理器（如 glibc 的分配器）会在返回给用户的内存块前端或尾部存储额外的元数据（如分配大小、cookie 等），这些信息对用户透明。调用 <code>delete</code> 时，运算符会根据传入的指针向前偏移一定位置来读取这些元数据，从而确定需要释放的内存块实际大小和边界，确保正确释放。因此，用户无需手动传递大小，所有细节由内存管理器和编译器生成的代码处理。</p>
<h2 id="86-一个空类大小是多少？如果有构造函数和析构函数呢？如果有虚函数？"><a href="#86-一个空类大小是多少？如果有构造函数和析构函数呢？如果有虚函数？" class="headerlink" title="86. 一个空类大小是多少？如果有构造函数和析构函数呢？如果有虚函数？"></a>86. 一个空类大小是多少？如果有构造函数和析构函数呢？如果有虚函数？</h2><blockquote>
<p>腾讯 TEG 一面</p>
</blockquote>
<blockquote>
<p>Q1：一个空类大小是多少？</p>
</blockquote>
<p>在 C++ 中，一个空类（没有任何非静态成员变量和虚函数）的大小通常为 <strong>1 字节</strong>。这是因为编译器需要为每个对象分配一个唯一的地址标识，以确保不同对象在内存中拥有 distinct 的地址。如果大小为 0，可能导致多个对象地址相同，违反语言标准。需要注意的是，如果空类作为基类被继承，可能会发生空基类优化（EBO），此时基子对象不占用额外空间，从而节省内存。</p>
<blockquote>
<p>Q2：如果空类只有构造函数和析构函数，该类大小是多少？</p>
</blockquote>
<p><strong>大小仍然是 1 个字节。</strong> 构造函数和析构函数是普通的成员函数，它们的代码并不存储在每一个对象实例中。这些函数在编译后位于代码段，所有该类的对象共享同一份函数代码。调用它们时，编译器会隐式地传入一个指向当前对象的 <code>this</code> 指针。因此，添加普通的成员函数（包括构造和析构）不会影响对象实例的大小。</p>
<blockquote>
<p>Q3：如果空类只有虚函数，该类大小是多少？</p>
</blockquote>
<p>在 64 位系统上，大小通常是 8 字节（一个指针的大小）；在 32 位系统上，通常是 4 字节。 </p>
<p>一旦一个类拥有虚函数，它就会拥有一个虚函数表（vtable），并且编译器会自动为该类的每一个对象实例添加一个隐藏的成员变量 —— 虚表指针（vptr）。这个 vptr 指向类的 vtable，用于在运行时实现多态（动态绑定）。因此，<strong>对象的大小会增加一个指针的开销</strong>。</p>
<h2 id="87-指针的大小是多少？"><a href="#87-指针的大小是多少？" class="headerlink" title="87. 指针的大小是多少？"></a>87. 指针的大小是多少？</h2><p>指针的大小<strong>不取决于它指向的数据类型</strong>，而<strong>完全取决于目标平台的寻址能力</strong>。</p>
<ul>
<li>在 32 位平台上，指针的大小是 4 字节，因为它需要能表示 $2^{32}$ 个不同的内存地址。</li>
<li>在 64 位平台上，指针的大小是 8 字节，用于表示 $2^{64}$ 个地址空间。</li>
</ul>
<p>无论是指向 <code>int</code>、<code>char</code> 还是一个拥有虚函数的复杂类对象，所有数据指针的大小都遵循这个规则（函数指针可能在某些平台上有所不同）。</p>
<h2 id="88-内存对齐了解过吗，我如果不想对齐，怎么办？"><a href="#88-内存对齐了解过吗，我如果不想对齐，怎么办？" class="headerlink" title="88. 内存对齐了解过吗，我如果不想对齐，怎么办？"></a>88. 内存对齐了解过吗，我如果不想对齐，怎么办？</h2><blockquote>
<p>腾讯 TEG 一面</p>
</blockquote>
<p>内存对齐是编译器和硬件为了提升访问效率而实施的策略。</p>
<p>如果不想对齐，可以通过编译器指令强制取消填充（如 GCC/Clang 的 <code>__attribute__((packed))</code> 或 MSVC 的 <code>#pragma pack(1)</code>），使结构体成员紧凑排列。但这样做有风险：未对齐访问在 x86 架构上会导致性能下降（多次内存访问），在其他架构（如 ARM）上可能直接触发硬件异常造成崩溃。除非有特殊需求（如协议解析或节省内存），否则不建议禁用对齐。</p>
<h2 id="89-讲讲-unordered-map-和-map-的底层实现和区别"><a href="#89-讲讲-unordered-map-和-map-的底层实现和区别" class="headerlink" title="89. 讲讲 unordered_map 和 map 的底层实现和区别"></a>89. 讲讲 unordered_map 和 map 的底层实现和区别</h2><blockquote>
<p>腾讯 TEG 一面</p>
</blockquote>
<h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left"><code>std::map</code></th>
<th align="left"><code>std::unordered_map</code></th>
</tr>
</thead>
<tbody><tr>
<td align="left">底层数据结构</td>
<td align="left"><strong>红黑树</strong> (一种自平衡的二叉搜索树)</td>
<td align="left"><strong>哈希表</strong> (数组 + 链表/红黑树)</td>
</tr>
<tr>
<td align="left">元素顺序</td>
<td align="left"><strong>元素按 key 排序</strong> (默认 <code>std::less</code>，即升序)</td>
<td align="left"><strong>元素无序</strong> (顺序取决于哈希函数)</td>
</tr>
<tr>
<td align="left">搜索时间复杂度</td>
<td align="left"><strong>O(log n)</strong></td>
<td align="left"><strong>平均 O(1)</strong>，最坏情况 O(n)</td>
</tr>
<tr>
<td align="left">插入时间复杂度</td>
<td align="left"><strong>O(log n)</strong></td>
<td align="left"><strong>平均 O(1)</strong>，最坏情况 O(n)</td>
</tr>
<tr>
<td align="left">删除时间复杂度</td>
<td align="left"><strong>O(log n)</strong></td>
<td align="left"><strong>平均 O(1)</strong>，最坏情况 O(n)</td>
</tr>
<tr>
<td align="left">迭代器稳定性</td>
<td align="left"><strong>稳定</strong>（除非删除元素，否则迭代器始终有效）</td>
<td align="left"><strong>插入/删除可能使所有迭代器失效</strong></td>
</tr>
<tr>
<td align="left">需要为 key 定义</td>
<td align="left"><code>operator&lt;</code> 或 <strong>自定义比较器</strong></td>
<td align="left"><code>std::hash</code> <strong>哈希函数</strong> 和 <code>operator==</code> <strong>相等比较</strong></td>
</tr>
<tr>
<td align="left">内存占用</td>
<td align="left">通常较低（树节点开销）</td>
<td align="left">通常较高（需要维护数组桶和链表）</td>
</tr>
<tr>
<td align="left">常用场景</td>
<td align="left">需要元素有序、顺序遍历、或要求最坏情况性能稳定</td>
<td align="left">需要快速查找、插入、删除，且不关心顺序</td>
</tr>
</tbody></table>
<h3 id="底层实现详解"><a href="#底层实现详解" class="headerlink" title="底层实现详解"></a>底层实现详解</h3><h4 id="map-基于红黑树-Red-Black-Tree"><a href="#map-基于红黑树-Red-Black-Tree" class="headerlink" title="map - 基于红黑树 (Red-Black Tree)"></a><code>map</code> - 基于红黑树 (Red-Black Tree)</h4><ul>
<li><p><strong>数据结构</strong>：</p>
<ul>
<li>本质上是一颗<strong>二叉搜索树 (BST)</strong>，这意味着任何节点的左子树所有节点的 key 都小于该节点的 key，右子树所有节点的 key 都大于该节点的 key。这使得中序遍历树时，可以得到有序的 key 序列。</li>
<li>它更具体地是一颗<strong>红黑树</strong>。红黑树是一种<strong>自平衡</strong>的二叉搜索树。它通过为节点添加颜色属性（红或黑）和定义一系列旋转和重新着色的规则，来确保树始终保持大致平衡（没有一条路径会比其他路径长两倍以上）。</li>
</ul>
</li>
<li><p><strong>如何工作</strong>：</p>
<ol>
<li><strong>插入</strong>：首先像普通的 BST 一样找到插入位置。插入新节点后（初始为红色），可能会破坏红黑树的平衡性质（如出现两个连续的红色节点）。这时需要通过<strong>旋转</strong>（左旋、右旋）和<strong>重新着色</strong>来恢复平衡。</li>
<li><strong>查找</strong>：从根节点开始，与当前节点的 key 比较。如果小于，进入左子树；如果大于，进入右子树；如果相等，则找到。由于树是平衡的，查找路径长度最多为树的高度 <strong>O(log n)</strong>。</li>
<li><strong>删除</strong>：同样先找到节点，执行 BST 删除操作后，可能会破坏平衡，需要再次通过旋转和重新着色来调整。</li>
</ol>
</li>
<li><p><strong>优点</strong>：元素始终有序，支持范围查询（如<code>lower_bound()</code>），提供了稳定的 <strong>O(log n)</strong> 操作时间。</p>
</li>
<li><p><strong>缺点</strong>：平均速度比哈希表慢，因为常数因子较大（需要多次比较和可能的内存跳跃）。</p>
</li>
</ul>
<h4 id="unordered-map-基于哈希表-Hash-Table"><a href="#unordered-map-基于哈希表-Hash-Table" class="headerlink" title="unordered_map - 基于哈希表 (Hash Table)"></a><code>unordered_map</code> - 基于哈希表 (Hash Table)</h4><ul>
<li><p><strong>数据结构</strong>：</p>
<ul>
<li>一个<strong>数组</strong>（通常称为“桶”bucket 数组），数组的每个元素是一个<strong>链表</strong>的头指针（或一棵小红黑树的根节点）。</li>
<li>在 C++11 中，标准要求使用“开链法”解决哈希冲突。在极端情况下（一个桶里元素太多），标准允许该桶用树 instead of 链表来实现，以避免最坏性能。</li>
</ul>
</li>
<li><p><strong>如何工作</strong>：</p>
<ol>
<li><strong>插入</strong>：<ul>
<li>对 key 进行<strong>哈希函数</strong>计算，得到一个整型的哈希值。</li>
<li>用这个哈希值 <strong><code>% 桶的数量</code></strong> 来确定元素应该放在哪个桶里（即数组的哪个索引）。</li>
<li>将键值对添加到这个桶对应的链表（或树）的末尾。</li>
</ul>
</li>
<li><strong>查找</strong>：<ul>
<li>同样先计算 key 的哈希值，找到对应的桶。</li>
<li>然后遍历这个桶里的链表（或树），使用<code>operator==</code> 进行精确匹配。</li>
</ul>
</li>
<li><strong>重新哈希 (Rehashing)</strong>：<ul>
<li>当元素数量超过<code>负载因子(load factor) * 桶的数量</code>时，容器会自动进行重新哈希。</li>
<li>这会创建一个新的、更大的桶数组，然后将所有现有元素重新计算哈希并插入到新的数组中。</li>
<li><strong>这个过程会使所有迭代器失效！</strong></li>
</ul>
</li>
</ol>
</li>
<li><p><strong>优点</strong>：平均情况下的查找、插入、删除速度极快，接近常数时间 <strong>O(1)</strong>。</p>
</li>
<li><p><strong>缺点</strong>：</p>
<ul>
<li>元素无序。</li>
<li>最坏情况下的性能是 <strong>O(n)</strong>（例如所有 key 都哈希到同一个桶里）。</li>
<li>迭代器不稳定（重新哈希会导致失效）。</li>
<li>需要为 key 类型提供良好的哈希函数。</li>
</ul>
</li>
</ul>
<h3 id="如何选择？"><a href="#如何选择？" class="headerlink" title="如何选择？"></a>如何选择？</h3><ul>
<li><p><strong>使用 <code>std::map</code> 当：</strong></p>
<ul>
<li>你需要<strong>元素按 key 排序</strong>。</li>
<li>你需要<strong>按顺序遍历</strong>元素。</li>
<li>你无法定义一个好的哈希函数 for your key type。</li>
<li>你非常关心<strong>最坏情况的性能</strong>（保证 O(log n)），而不是平均情况。</li>
</ul>
</li>
<li><p><strong>使用 <code>std::unordered_map</code> 当：</strong></p>
<ul>
<li><strong>查找速度</strong>是首要任务。</li>
<li>你不需要维护元素的任何顺序。</li>
<li>你愿意并且能够为你的 key 类型定义一个高效的哈希函数（例如，基本类型和<code>std::string</code>已有内置哈希）。</li>
</ul>
</li>
</ul>
<h2 id="90-介绍一下B树-B-树-红黑树及其对应的应用场景有哪些"><a href="#90-介绍一下B树-B-树-红黑树及其对应的应用场景有哪些" class="headerlink" title="90. 介绍一下B树/B+树/红黑树及其对应的应用场景有哪些"></a>90. 介绍一下B树/B+树/红黑树及其对应的应用场景有哪些</h2><h3 id="B-树"><a href="#B-树" class="headerlink" title="B 树"></a>B 树</h3><p>B 树是一种多路平衡搜索树，它的每个节点可以拥有多于两个的子节点，这使得它能够保持矮胖的树形结构。</p>
<p>B 树的设计核心是为了减少磁盘 I/O 次数，因为它一个节点的大小通常设置为一个磁盘页的大小，一次磁盘读取就能加载一个包含多个键的巨大节点，然后在内核中进行高效的二分查找。</p>
<p>所以它特别适合用于文件系统和数据库（如 MySQL 的 InnoDB 存储引擎）的索引，这些场景下数据量巨大无法全部装入内存，需要频繁与磁盘交换数据。</p>
<h3 id="B-树-1"><a href="#B-树-1" class="headerlink" title="B+ 树"></a>B+ 树</h3><p>B+树是 B 树的一种变体，也是目前数据库和文件系统索引的事实标准。</p>
<p>它与 B 树的主要区别在于：首先，它的所有数据记录都只存储在叶子节点上，内部节点只存放键作为导航用的索引；其次，叶子节点之间通过指针相连形成了一个有序链表。</p>
<p>这样的设计带来了几个巨大优势：一是内部节点能存放更多的键，使得树更矮，查询需要的磁盘 I/O 更少；二是范围查询性能极高，一旦找到范围的起点，只需顺着叶子节点的链表遍历即可，而不需要像 B 树那样回溯到上层节点。</p>
<p>所以 MySQL 的 InnoDB 引擎、MongoDB、以及几乎所有关系型数据库的索引都在用 B+树。</p>
<h3 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h3><p>红黑树则是一种二叉平衡搜索树，它通过复杂的旋转和变色规则来维持大致的平衡，确保从根到任意叶子节点的最长路径不会超过最短路径的两倍，从而保证了最坏情况下搜索、插入、删除操作的时间复杂度都是 $O(log n)$。</p>
<p>它的主要优势在于内存中操作的效率非常高，且维护平衡的代价相对于严格的 AVL 树更小（旋转次数更少）。</p>
<p>因此，它的应用场景主要集中在内存计算领域，比如 C++ STL 中的 <code>map</code> 和 <code>set</code> 就是用红黑树实现的，此外还有 Linux 系统的进程调度器 Completely Fair Scheduler (CFS) 也用红黑树来管理进程队列。</p>
<h2 id="91-智能指针申请的空间是在堆上还是在栈上？"><a href="#91-智能指针申请的空间是在堆上还是在栈上？" class="headerlink" title="91. 智能指针申请的空间是在堆上还是在栈上？"></a>91. 智能指针申请的空间是在堆上还是在栈上？</h2><p>智能指针（<code>unique_ptr</code>、<code>shared_ptr</code>）<strong>本身</strong>是一个栈上的对象，但它<strong>所管理的内存</strong>是在堆上申请的。</p>
<h2 id="92-介绍下-vector-动态扩容机制"><a href="#92-介绍下-vector-动态扩容机制" class="headerlink" title="92. 介绍下 vector 动态扩容机制"></a>92. 介绍下 <code>vector</code> 动态扩容机制</h2><p><code>std::vector</code> 的动态扩容机制是其核心特性之一，旨在平衡内存使用与操作效率。</p>
<p>其本质在于管理三个核心属性：<code>size</code>（当前元素数量）、<code>capacity</code>（当前分配的内存可容纳的元素数量）和分配策略（通常按固定因子增长，如2倍或1.5倍）。</p>
<p>当执行 <code>push_back</code> 或 <code>emplace_back</code> 等插入操作时，若当前 <code>size</code> 已达到 <code>capacity</code>，则触发扩容流程：</p>
<ol>
<li><strong>计算新容量</strong>：根据预定义的增长因子（Growth Factor，通常为2）确定新的容量值（<code>new_capacity = old_capacity * growth_factor</code>）。</li>
<li><strong>分配新内存</strong>：在自由存储区（堆）上申请一块更大的、连续的内存空间，其大小足以容纳 <code>new_capacity</code> 个元素。</li>
<li><strong>迁移数据</strong>：将原有内存中的所有元素移动（若移动构造函数为 <code>noexcept</code>）或拷贝到新内存的起始位置。此步骤会调用各元素的构造函数，是扩容过程中开销最大的操作，时间复杂度为 O(N)。</li>
<li><strong>释放旧内存</strong>：销毁原内存中的对象并释放原有内存块。</li>
<li><strong>更新内部状态</strong>：将内部指针指向新内存块，并将 <code>capacity</code> 更新为 <code>new_capacity</code>，最后在尾部构造新插入的元素。</li>
</ol>
<p>此机制确保了插入操作的<strong>摊还时间复杂度为 O(1)</strong>。尽管单次扩容成本较高，但由于容量呈指数级增长，扩容频率迅速下降，从而将总成本均摊到多次操作上。</p>
<p>需要注意的是，<strong>扩容会使所有指向原 <code>vector</code> 元素的迭代器、指针和引用失效</strong>，因为数据的存储地址已发生改变。因此，在已知元素数量的场景下，使用 <code>reserve()</code> 预先分配足够容量是避免多次冗余扩容、提升性能的最佳实践。</p>
<h2 id="93-vector-的-push-back-和-emplace-back-的区别？"><a href="#93-vector-的-push-back-和-emplace-back-的区别？" class="headerlink" title="93. vector 的 push_back 和 emplace_back 的区别？"></a>93. <code>vector</code> 的 <code>push_back</code> 和 <code>emplace_back</code> 的区别？</h2><p><code>push_back</code> 和 <code>emplace_back</code> 的核心区别在于<strong>构造对象的时机和方式</strong>。</p>
<ul>
<li><code>push_back</code> 接受一个已存在的对象，并将其拷贝（左值）或移动（右值）到容器末尾，这个过程中可能产生临时对象的开销。</li>
<li><code>emplace_back</code> 则直接接受构造参数，<strong>通过完美转发在容器末尾的内存中原地构造对象</strong>，省去了创建临时对象的步骤，避免了不必要的拷贝或移动操作，因此性能更高。</li>
</ul>
<p>在大多数情况下，尤其是插入临时对象或构造代价较高的对象时，应优先选用 <code>emplace_back</code>。</p>
<h2 id="94-关于-vector-迭代器失效"><a href="#94-关于-vector-迭代器失效" class="headerlink" title="94. 关于 vector 迭代器失效"></a>94. 关于 <code>vector</code> 迭代器失效</h2><p><strong>当 <code>vector</code> 的底层存储发生改变，尤其是内存重新分配时，指向其元素的迭代器、指针和引用都会变得不可用</strong>。</p>
<p>以下是导致 <code>vector</code> 迭代器失效的几种主要情况：</p>
<h3 id="1-插入元素-insert-emplace-push-back-emplace-back"><a href="#1-插入元素-insert-emplace-push-back-emplace-back" class="headerlink" title="1. 插入元素 (insert, emplace, push_back, emplace_back)"></a>1. 插入元素 (<code>insert</code>, <code>emplace</code>, <code>push_back</code>, <code>emplace_back</code>)</h3><p>插入操作是否导致迭代器失效，取决于是否触发了<strong>重新分配（Reallocation）</strong>。</p>
<ul>
<li><strong>导致重新分配</strong>：如果插入新元素后，<code>size()</code> 超过了 <code>capacity()</code>，<code>vector</code> 会申请一块新的更大的内存，并将所有现有元素<strong>移动</strong>或<strong>拷贝</strong>到新内存中，然后释放旧内存。<ul>
<li><strong>后果</strong>：<strong>所有迭代器、指针、引用都会失效</strong>，包括 <code>begin()</code>, <code>end()</code> 以及所有指向元素的迭代器。</li>
</ul>
</li>
<li><strong>未导致重新分配</strong>：如果插入后 <code>size() &lt;= capacity()</code>，则只需要将<strong>插入点之后</strong>的所有元素向后移动。<ul>
<li><strong>后果</strong>：<strong>所有指向插入点之后元素的迭代器、指针、引用都会失效</strong>。插入点之前的迭代器仍然有效。</li>
</ul>
</li>
</ul>
<h3 id="2-删除元素-erase-pop-back"><a href="#2-删除元素-erase-pop-back" class="headerlink" title="2. 删除元素 (erase, pop_back)"></a>2. 删除元素 (<code>erase</code>, <code>pop_back</code>)</h3><p>删除元素会改变序列，为了保持内存连续，需要将<strong>被删除元素之后</strong>的所有元素向前移动。</p>
<ul>
<li><strong>后果</strong>：<strong>所有指向被删除元素及其之后元素的迭代器、指针、引用都会失效</strong>。被删除元素之前的迭代器仍然有效。</li>
<li><strong>特别注意</strong>：<code>erase()</code> 函数会返回一个指向被删除元素之后第一个有效元素的<strong>新迭代器</strong>，你可以利用它来安全地继续遍历。</li>
</ul>
<h3 id="3-改变容量-reserve-resize-shrink-to-fit"><a href="#3-改变容量-reserve-resize-shrink-to-fit" class="headerlink" title="3. 改变容量 (reserve, resize, shrink_to_fit)"></a>3. 改变容量 (<code>reserve</code>, <code>resize</code>, <code>shrink_to_fit</code>)</h3><p>任何可能改变 <code>vector</code> 容量（<code>capacity</code>）的操作都可能引起内存重新分配。</p>
<ul>
<li><code>reserve(n)</code>：如果 <code>n &gt; capacity()</code>，则会申请新内存并进行数据迁移，导致<strong>全部失效</strong>。</li>
<li><code>shrink_to_fit()</code>：请求减少容量以匹配大小，实现可能会进行重新分配，导致<strong>全部失效</strong>。</li>
<li><code>resize(n)</code>：<ul>
<li>如果 <code>n &gt; capacity()</code>（需要扩容），则<strong>全部失效</strong>。</li>
<li>如果只是增大 <code>size()</code> 但未触发重分配，则 <code>end()</code> 迭代器会失效。</li>
<li>如果是减小 <code>size()</code>，则被“抹去”的那些元素的迭代器会失效。</li>
</ul>
</li>
</ul>
<h3 id="4-交换-swap"><a href="#4-交换-swap" class="headerlink" title="4. 交换 (swap)"></a>4. 交换 (<code>swap</code>)</h3><p>当两个 <code>vector</code> 进行交换时，它们的底层数据指针会互换。</p>
<p>迭代器、指针、引用<strong>不会失效，但它们会交换归属</strong>。原来指向容器 A 中元素的迭代器，在交换后指向的是容器 B 中的元素，反之亦然。</p>
<h3 id="5-清空-clear"><a href="#5-清空-clear" class="headerlink" title="5. 清空 (clear)"></a>5. 清空 (<code>clear</code>)</h3><p><code>clear()</code> 函数会移除所有元素，并将 <code>size()</code> 设为 0。它<strong>不保证</strong>会改变 <code>capacity()</code>。</p>
<p><strong>所有指向被清除元素的迭代器、指针、引用都会失效</strong>。因为元素对象已经被销毁了。</p>
<h2 id="95-C-不同权限继承分别会有怎样的表现？"><a href="#95-C-不同权限继承分别会有怎样的表现？" class="headerlink" title="95. C++ 不同权限继承分别会有怎样的表现？"></a>95. C++ 不同权限继承分别会有怎样的表现？</h2><p>C++ 的继承有 <code>public</code>、<code>protected</code>、<code>private</code> 三种方式：</p>
<ul>
<li><code>public</code> 继承：基类的 <code>public</code> 成员仍然是 <code>public</code>，<code>protected</code> 成员仍然是 <code>protected</code>；</li>
<li><code>protected</code> 继承：基类的 <code>public</code> 和 <code>protected</code> 成员都变成 <code>protected</code>；</li>
<li><code>private</code> 继承：基类的 <code>public</code> 和 <code>protected</code> 成员都变成 <code>private</code>。</li>
</ul>
<h2 id="96-单例模式的概念和实现？懒汉式-饿汉式？线程安全？"><a href="#96-单例模式的概念和实现？懒汉式-饿汉式？线程安全？" class="headerlink" title="96. 单例模式的概念和实现？懒汉式/饿汉式？线程安全？"></a>96. 单例模式的概念和实现？懒汉式/饿汉式？线程安全？</h2><blockquote>
<p>概念</p>
</blockquote>
<p>单例模式（Singleton）是一种创建型设计模式，保证一个类在系统中只有一个实例，并提供一个全局访问点。</p>
<ul>
<li>典型实现方式是将构造函数设为 <code>private</code>，在类内维护一个静态指针或引用，并通过一个 <code>static</code> 方法获取实例。</li>
<li>这样可以确保外部无法随意构造对象，而只能通过该方法获得同一个实例。</li>
</ul>
<hr>
<p><strong>懒汉式</strong>：在第一次调用 <code>getInstance()</code> 时才创建实例，节省内存，<strong>但需要考虑多线程时的同步问题</strong>。</p>
<p><strong>饿汉式</strong>：在程序启动时就初始化实例，线程安全且实现简单，但可能造成资源浪费。通常通过加锁（如 <code>mutex</code>）或使用双重检查锁（DCLP）<strong>来保证多线程下实例只被创建一次</strong>，同时避免每次访问都加锁带来的性能损耗。</p>
<ul>
<li>前者加锁在 C++11 后一般都是利用 <strong>函数内静态变量</strong> 的线程安全初始化，而非加锁</li>
</ul>
<h3 id="懒汉式（线程安全）"><a href="#懒汉式（线程安全）" class="headerlink" title="懒汉式（线程安全）"></a>懒汉式（线程安全）</h3><p>特点：进程启动阶段就构造实例；<strong>首次使用时无需加锁</strong>；简单、安全（依赖静态对象初始化顺序规则）。</p>
<blockquote>
<p>饿汉式之所以能保证线程安全，核心原因在于静态对象的初始化时机：</p>
<ul>
<li><code>EagerSingleton::s_instance</code> 是一个 <strong>静态存储期对象</strong>（全局 / namespace 作用域静态变量，或类中的静态成员）。<br>   C++ 标准规定：<ul>
<li>静态存储期对象的构造在 <strong>main 函数执行之前</strong> 完成。</li>
<li>这个初始化过程是由运行时（Runtime）在单线程环境下完成的。换句话说，在进入 <code>main()</code> 之前，<code>s_instance</code> 就已经被安全地构造好了。</li>
</ul>
</li>
</ul>
<p>因此，在程序运行的并发环境里，任何线程调用 <code>EagerSingleton::instance()</code> 时，<code>s_instance</code> 已经是构造完成的对象，不存在“多个线程同时构造”的竞争条件。</p>
</blockquote>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EagerSingleton</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> EagerSingleton&amp; <span class="title">instance</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> s_instance;               <span class="comment">// 已在程序启动时构造完成</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">hello</span><span class="params">()</span> <span class="type">const</span> </span>{ std::cout &lt;&lt; <span class="string">"Eager\n"</span>; }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 禁用拷贝/移动</span></span><br><span class="line">    <span class="built_in">EagerSingleton</span>(<span class="type">const</span> EagerSingleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    EagerSingleton&amp; <span class="keyword">operator</span>=(<span class="type">const</span> EagerSingleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="built_in">EagerSingleton</span>(EagerSingleton&amp;&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    EagerSingleton&amp; <span class="keyword">operator</span>=(EagerSingleton&amp;&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">EagerSingleton</span>() { <span class="comment">/* 初始化资源 */</span> }</span><br><span class="line">    ~<span class="built_in">EagerSingleton</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> EagerSingleton s_instance;    <span class="comment">// 定义见 .cpp</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 若放在同一翻译单元（示例用），需提供定义：</span></span><br><span class="line">EagerSingleton EagerSingleton::s_instance;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    EagerSingleton::<span class="built_in">instance</span>().<span class="built_in">hello</span>();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>要点：</p>
<ul>
<li><code>s_instance</code> 是静态全局对象，程序启动期构造、退出时析构。</li>
<li>如果跨多个翻译单元，建议把定义放进唯一的 <code>.cpp</code> 中，避免 ODR 冲突。</li>
</ul>
<h3 id="饿汉式（线程安全）"><a href="#饿汉式（线程安全）" class="headerlink" title="饿汉式（线程安全）"></a>饿汉式（线程安全）</h3><h4 id="方式-A：Meyers-Singleton（推荐）"><a href="#方式-A：Meyers-Singleton（推荐）" class="headerlink" title="方式 A：Meyers Singleton（推荐）"></a>方式 A：Meyers Singleton（推荐）</h4><p>特点：利用 <strong>函数内静态变量</strong> 的线程安全初始化（C++11 起标准保证），写法最简洁。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LazySingleton</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> LazySingleton&amp; <span class="title">instance</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="type">static</span> LazySingleton inst;   <span class="comment">// 首次调用时构造，线程安全</span></span><br><span class="line">        <span class="keyword">return</span> inst;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">hello</span><span class="params">()</span> <span class="type">const</span> </span>{ std::cout &lt;&lt; <span class="string">"Lazy (Meyers)\n"</span>; }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">LazySingleton</span>(<span class="type">const</span> LazySingleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    LazySingleton&amp; <span class="keyword">operator</span>=(<span class="type">const</span> LazySingleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="built_in">LazySingleton</span>(LazySingleton&amp;&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    LazySingleton&amp; <span class="keyword">operator</span>=(LazySingleton&amp;&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">LazySingleton</span>() { <span class="comment">/* 初始化资源 */</span> }</span><br><span class="line">    ~<span class="built_in">LazySingleton</span>() = <span class="keyword">default</span>;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    LazySingleton::<span class="built_in">instance</span>().<span class="built_in">hello</span>();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>优点：简洁、可靠、由标准保证一次性初始化；缺点：析构顺序不受你精细控制（通常不是问题）。</p>
<h4 id="方式-B：双重检查锁（DCLP）-std-atomic（展示用）"><a href="#方式-B：双重检查锁（DCLP）-std-atomic（展示用）" class="headerlink" title="方式 B：双重检查锁（DCLP）+ std::atomic（展示用）"></a>方式 B：双重检查锁（DCLP）+ <code>std::atomic</code>（展示用）</h4><p>在需要<strong>手动控制生命周期</strong>（如显式 <code>destroy()</code>）的场景可用；写法更复杂，需小心内存序语义。多数情况下 A 足够。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LazySingletonDCLP</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> LazySingletonDCLP* <span class="title">instance</span><span class="params">()</span> </span>{</span><br><span class="line">        LazySingletonDCLP* p = ptr.<span class="built_in">load</span>(std::memory_order_acquire);</span><br><span class="line">        <span class="keyword">if</span> (!p) {</span><br><span class="line">            <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(mtx)</span></span>;</span><br><span class="line">            p = ptr.<span class="built_in">load</span>(std::memory_order_relaxed);</span><br><span class="line">            <span class="keyword">if</span> (!p) {</span><br><span class="line">                p = <span class="keyword">new</span> <span class="built_in">LazySingletonDCLP</span>();</span><br><span class="line">                ptr.<span class="built_in">store</span>(p, std::memory_order_release);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">destroy</span><span class="params">()</span> </span>{               <span class="comment">// 若需要显式销毁（可选）</span></span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(mtx)</span></span>;</span><br><span class="line">        LazySingletonDCLP* p = ptr.<span class="built_in">load</span>(std::memory_order_relaxed);</span><br><span class="line">        <span class="keyword">if</span> (p) {</span><br><span class="line">            <span class="keyword">delete</span> p;</span><br><span class="line">            ptr.<span class="built_in">store</span>(<span class="literal">nullptr</span>, std::memory_order_release);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">hello</span><span class="params">()</span> <span class="type">const</span> </span>{ std::cout &lt;&lt; <span class="string">"Lazy (DCLP)\n"</span>; }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">LazySingletonDCLP</span>(<span class="type">const</span> LazySingletonDCLP&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    LazySingletonDCLP&amp; <span class="keyword">operator</span>=(<span class="type">const</span> LazySingletonDCLP&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="built_in">LazySingletonDCLP</span>(LazySingletonDCLP&amp;&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    LazySingletonDCLP&amp; <span class="keyword">operator</span>=(LazySingletonDCLP&amp;&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">LazySingletonDCLP</span>() { <span class="comment">/* 初始化资源 */</span> }</span><br><span class="line">    ~<span class="built_in">LazySingletonDCLP</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> std::atomic&lt;LazySingletonDCLP*&gt; ptr;</span><br><span class="line">    <span class="type">static</span> std::mutex mtx;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">std::atomic&lt;LazySingletonDCLP*&gt; LazySingletonDCLP::ptr{<span class="literal">nullptr</span>};</span><br><span class="line">std::mutex LazySingletonDCLP::mtx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    LazySingletonDCLP::<span class="built_in">instance</span>()-&gt;<span class="built_in">hello</span>();</span><br><span class="line">    LazySingletonDCLP::<span class="built_in">destroy</span>();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li><strong>首选</strong>：懒汉式的 <strong>Meyers Singleton</strong>（方式 A）或<strong>饿汉式静态对象</strong>，代码最简、标准保证线程安全。</li>
<li>仅当需要<strong>手动销毁</strong>或<strong>自定义分配策略</strong>时，再考虑 DCLP/<code>std::call_once</code> 等更复杂写法。</li>
</ul>
<h2 id="97-虚函数定义为析构函数能避免内存泄露的实现原理是什么？"><a href="#97-虚函数定义为析构函数能避免内存泄露的实现原理是什么？" class="headerlink" title="97. 虚函数定义为析构函数能避免内存泄露的实现原理是什么？"></a>97. 虚函数定义为析构函数能避免内存泄露的实现原理是什么？</h2><p>当基类指针指向派生类对象并通过 <code>delete</code> 释放时，如果基类的析构函数不是虚函数，那么只会调用基类析构函数，派生类部分无法正确析构，导致资源未释放从而造成内存泄露。而将析构函数声明为虚函数后，析构时会触发虚函数表的动态绑定，先调用派生类的析构函数，再调用基类析构函数，确保对象的所有资源被正确释放。</p>
<h2 id="98-为什么哈希表不适合做索引结构？"><a href="#98-为什么哈希表不适合做索引结构？" class="headerlink" title="98. 为什么哈希表不适合做索引结构？"></a>98. 为什么哈希表不适合做索引结构？</h2><blockquote>
<p>阿里面试 · 数据库</p>
<p>参考链接：</p>
<ul>
<li><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1se4y1U7Dn/?spm_id_from=333.337.search-card.all.click&amp;vd_source=187e83a375c910488a1ad25cc2465299">一个视频带你了解常用存储引擎数据结构</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV15V411p7pi/?spm_id_from=333.788.top_right_bar_window_custom_collection.content.click&amp;vd_source=187e83a375c910488a1ad25cc2465299">深入理解 B+ 树原理</a></p>
</li>
</ul>
</blockquote>
<blockquote>
<p>这是一个非常核心的【数据库】问题。</p>
</blockquote>
<p>哈希表虽然拥有 <strong>O(1) 的极致点查询性能</strong>，但它固有的特性使其在大多数情况下<strong>不适合作为数据库的主流索引结构</strong>。</p>
<p>数据库索引的核心需求不仅仅是“快”，更是<strong>灵活性和高效地支持多种查询模式</strong>。哈希表在这一点上存在致命缺陷。</p>
<p>以下是哈希表不适合做（主流的）数据库索引结构的几个关键原因：</p>
<h3 id="1-无法支持范围查询-Range-Queries"><a href="#1-无法支持范围查询-Range-Queries" class="headerlink" title="(1) 无法支持范围查询 (Range Queries)"></a>(1) 无法支持范围查询 (Range Queries)</h3><p>这是哈希索引的<strong>最大死穴</strong>。</p>
<ul>
<li><strong>哈希表的工作方式</strong>：基于哈希函数将键映射到特定的存储位置。这个映射是<strong>分散的、无序的</strong>。<code>id=100</code> 和 <code>id=101</code> 的记录可能被哈希到完全不相干的两个桶（bucket）里。</li>
<li><strong>数据库的常见需求</strong>：查询如 <code>WHERE id &gt; 100 AND id &lt; 200</code>、<code>WHERE name LIKE 'A%'</code>、<code>ORDER BY date</code>。这些查询需要数据是<strong>有序的</strong>。</li>
<li><strong>哈希表的困境</strong>：为了完成一个范围查询，哈希表<strong>必须扫描表中的每一项</strong>，因为数据在存储上是没有顺序的。这相当于全表扫描（O(n)），完全丧失了索引的意义。而 B+树等有序索引可以高效地定位范围的起点，然后通过叶子节点的链表顺序遍历即可。</li>
</ul>
<h3 id="2-无法支持排序-ORDER-BY-和前缀匹配-LIKE-‘abc-’"><a href="#2-无法支持排序-ORDER-BY-和前缀匹配-LIKE-‘abc-’" class="headerlink" title="(2) 无法支持排序 (ORDER BY) 和前缀匹配 (LIKE ‘abc%’)"></a>(2) 无法支持排序 (ORDER BY) 和前缀匹配 (LIKE ‘abc%’)</h3><ul>
<li><strong>排序</strong>：<code>ORDER BY</code> 子句需要数据有序。哈希表输出的数据是杂乱无章的，要排序就必须将所有结果集放入内存或进行磁盘排序，成本极高。</li>
<li><strong>前缀匹配</strong>：<code>LIKE 'abc%'</code> 本质上也是一个范围查询（从’abc’到’abd’），同样需要索引是有序的。哈希函数会把 <code>'abc'</code> 和 <code>'abcd'</code> 哈希成完全不同的值，无法利用索引。</li>
</ul>
<h3 id="3-哈希冲突与性能退化"><a href="#3-哈希冲突与性能退化" class="headerlink" title="(3) 哈希冲突与性能退化"></a>(3) 哈希冲突与性能退化</h3><ul>
<li><strong>冲突处理</strong>：再好的哈希函数也可能存在冲突（两个不同的键被映射到同一个位置）。需要额外的机制来处理（如链表法），这会在冲突发生时增加查询时间。</li>
<li><strong>最坏情况</strong>：如果哈希函数设计不佳或数据有特定模式，大量键可能被哈希到少数几个桶中，导致某些链变得非常长。最坏情况下，查询性能会退化为 <strong>O(n)</strong>，这与设计初衷背道而驰。</li>
</ul>
<h3 id="4-哈希函数的选择至关重要且困难"><a href="#4-哈希函数的选择至关重要且困难" class="headerlink" title="(4) 哈希函数的选择至关重要且困难"></a>(4) 哈希函数的选择至关重要且困难</h3><ul>
<li>选择一个能均匀分散数据的哈希函数非常关键，但这并非易事，需要根据具体的数据分布来决定。</li>
<li>一旦数据特征发生变化，原先合适的哈希函数可能不再高效，而更换哈希函数意味着要<strong>重建整个索引</strong>，成本巨大。</li>
</ul>
<h3 id="5-不支持部分索引（最左匹配原则）"><a href="#5-不支持部分索引（最左匹配原则）" class="headerlink" title="(5) 不支持部分索引（最左匹配原则）"></a>(5) 不支持部分索引（最左匹配原则）</h3><ul>
<li>对于<strong>复合索引</strong>（如索引 <code>(last_name, first_name)</code>），B+树可以支持只查询 <code>last_name</code> 的查询（最左匹配）。</li>
<li>哈希索引必须使用<strong>所有键</strong>来计算哈希值。如果你只知道 <code>last_name</code> 而不知道 <code>first_name</code>，哈希函数将无法计算，索引也就完全失效。</li>
</ul>
<h3 id="6-内存使用效率"><a href="#6-内存使用效率" class="headerlink" title="(6) 内存使用效率"></a>(6) 内存使用效率</h3><ul>
<li>为了避免频繁冲突，哈希表通常需要保持较大的空闲空间（较低的负载因子，如 70%），这会导致<strong>内存/磁盘空间的浪费</strong>。</li>
<li>B+树的页面填充率通常可以很高（如 70%-100%），空间利用率更好。</li>
</ul>
<h2 id="99-B-Tree、B-Tree、LSM-Tree"><a href="#99-B-Tree、B-Tree、LSM-Tree" class="headerlink" title="99. B-Tree、B+ Tree、LSM-Tree"></a>99. B-Tree、B+ Tree、LSM-Tree</h2><p>详细探讨一下在数据库和存储系统中至关重要的三种数据结构：<strong>B 树</strong>、<strong>B+ 树</strong>和 <strong>LSM 树</strong>。</p>
<p>它们都是为了解决不同场景下，如何高效地管理和访问磁盘上的大量数据而设计的。</p>
<h3 id="1-B-树"><a href="#1-B-树" class="headerlink" title="1. B 树"></a>1. B 树</h3><p>B 树是一种自平衡的多路搜索树，它允许每个节点有多个子节点（超过两个）。它旨在最大限度地减少磁盘 I/O 操作，因为从磁盘读取一个节点（即一个页面或块）通常需要一次 I/O，而节点内键的比较则在内存中进行，速度很快。</p>
<h4 id="核心特性与结构"><a href="#核心特性与结构" class="headerlink" title="核心特性与结构"></a>核心特性与结构</h4><ul>
<li><strong>多路平衡</strong>：一个节点可以拥有多个子节点（通常是上百甚至上千个），这大大降低了树的高度。树的高度与磁盘 I/O 次数直接相关，矮胖的树比高瘦的二叉树性能好得多。</li>
<li><strong>排序节点</strong>：每个节点中的键（Key）都是<strong>按顺序存储</strong>的。</li>
<li><strong>节点容量</strong>：一个<strong>m 阶</strong>的 B 树（order-m）满足以下属性：<ol>
<li>每个节点最多有 <strong>m</strong> 个子节点。</li>
<li>每个内部节点（非根非叶）至少有 <strong>⌈m/2⌉</strong> 个子节点。</li>
<li>根节点至少有两个子节点（除非它是叶子节点）。</li>
<li>所有<strong>叶子节点都位于同一层</strong>，显示出完美的平衡。</li>
</ol>
</li>
<li><strong>数据存储</strong>：在<strong>经典的 B 树定义中，所有节点（包括内部节点）都可以存储数据</strong>。</li>
</ul>
<h4 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h4><ul>
<li><strong>查询</strong>：从根节点开始，在节点内部进行二分查找，找到合适的区间，然后递归地进入对应的子节点，直到找到目标键或确认键不存在。</li>
<li><strong>插入</strong>：<ol>
<li>找到应插入的叶子节点。</li>
<li>如果该节点有空间，则直接插入并排序。</li>
<li>如果节点已满，则进行<strong>分裂（Split）</strong>：将中间键提升到父节点，原节点分裂成两个。这个分裂过程可能会一直向上传播到根节点，导致树增高。</li>
</ol>
</li>
<li><strong>删除</strong>：稍微复杂一些，可能涉及从兄弟节点借键（借用）或者与兄弟节点合并，以保持树的平衡和节点的最小度数要求。</li>
</ul>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul>
<li>自动保持平衡，保证查询、插入、删除的时间复杂度为 <strong>O(log n)</strong>。</li>
<li>矮胖的结构减少了磁盘访问次数。</li>
</ul>
<h4 id="缺点（尤其是在数据库索引场景下）"><a href="#缺点（尤其是在数据库索引场景下）" class="headerlink" title="缺点（尤其是在数据库索引场景下）"></a>缺点（尤其是在数据库索引场景下）</h4><ul>
<li><strong>区间查询效率相对较低</strong>：由于数据可能分布在所有节点（包括内部节点），进行范围查询（如<code>SELECT * FROM table WHERE key BETWEEN 10 AND 100</code>）时需要在树中进行多次中序遍历，效率不高。</li>
<li><strong>节点结构相对浪费空间</strong>：每个节点既存储键，也可能存储数据，导致每个节点能存放的键数量相对减少，树的高度可能略高于 B+树。</li>
</ul>
<h3 id="2-B-树"><a href="#2-B-树" class="headerlink" title="2. B+树"></a>2. B+树</h3><p>B+ 树是 B 树的一种变体，是现代关系型数据库（如 MySQL 的 InnoDB、PostgreSQL）索引的<strong>事实标准</strong>。它针对 B 树在数据库应用中的缺点进行了优化。</p>
<h4 id="核心特性与结构（与-B-树的主要区别）"><a href="#核心特性与结构（与-B-树的主要区别）" class="headerlink" title="核心特性与结构（与 B 树的主要区别）"></a>核心特性与结构（与 B 树的主要区别）</h4><ol>
<li><strong>数据只存储在叶子节点</strong>：内部节点<strong>只存储键</strong>（索引信息）和指向子节点的指针。这使得内部节点可以容纳更多的键，从而进一步降低树的高度。</li>
<li><strong>叶子节点通过指针串联</strong>：所有叶子节点构成一个<strong>有序双向链表</strong>。这是实现高效区间查询的关键。</li>
</ol>
<h4 id="操作-1"><a href="#操作-1" class="headerlink" title="操作"></a>操作</h4><ul>
<li>插入和删除过程与 B 树类似，也涉及分裂和合并，但规则稍有不同，因为要维护叶子节点的链表结构。</li>
</ul>
<h4 id="优点（相较于-B-树）"><a href="#优点（相较于-B-树）" class="headerlink" title="优点（相较于 B 树）"></a>优点（相较于 B 树）</h4><ul>
<li><strong>更低的树高</strong>：内部节点不存储数据，可以容纳更多的键，因此在相同数据量下，B+树比 B 树更矮胖，I/O 次数更少。</li>
<li><strong>更稳定的查询性能</strong>：任何查询都必须到达叶子节点，因此每次查找的路径长度都是相同的（O(log n)）。</li>
<li><strong>极高的区间查询效率</strong>：这是 B+树最大的优势。一旦在叶子节点上找到了范围的起始点，就可以通过叶子节点的链表指针顺序扫描，无需回溯到上层节点。</li>
</ul>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li>由于数据只存在于叶子节点，每次查询都必须到达叶子节点，单点查询性能可能略逊于 B 树（如果数据在 B 树的内部节点就找到的话），但这种差异微乎其微。</li>
</ul>
<h3 id="3-LSM-树"><a href="#3-LSM-树" class="headerlink" title="3. LSM 树"></a>3. LSM 树</h3><p>LSM 树的设计理念与 B+树完全不同。它<strong>牺牲了部分的读性能</strong>，来换取<strong>极高的写吞吐量</strong>。它广泛应用于<strong>写多读少</strong>的场景，如 Google Bigtable、HBase、Cassandra、LevelDB、RocksDB 等 NoSQL 数据库中。</p>
<h4 id="设计哲学"><a href="#设计哲学" class="headerlink" title="设计哲学"></a>设计哲学</h4><p>磁盘的<strong>顺序写入</strong>速度远快于<strong>随机写入</strong>。B+ 树需要原地更新数据，可能涉及随机写入（如分裂节点）。LSM 树则通过以下方式将随机写入转换为顺序写入：</p>
<ol>
<li><strong>先写入内存和日志</strong>。</li>
<li><strong>在后台合并和排序</strong>。</li>
</ol>
<h4 id="核心结构与工作流程"><a href="#核心结构与工作流程" class="headerlink" title="核心结构与工作流程"></a>核心结构与工作流程</h4><p>LSM 树通常由两个或多个主要组件构成：</p>
<ol>
<li><p><strong>MemTable</strong>：</p>
<ul>
<li>一个常驻内存的数据结构（通常是跳表 SkipList 或平衡树）。</li>
<li>所有新的写入操作首先被写入 MemTable，同时也会被追加到一个<strong>预写日志（Write-Ahead Log, WAL）</strong> 中用于崩溃恢复。</li>
<li>读操作需要同时查询 MemTable 和后续的 SSTable，然后合并结果。</li>
</ul>
</li>
<li><p><strong>Immutable MemTable</strong>：</p>
<ul>
<li>当 MemTable 的大小达到阈值时，它会变为只读状态（Immutable），并准备被刷写到磁盘。同时，一个新的 MemTable 会被创建来接收新的写入操作。</li>
<li>这个设计避免了读写锁冲突，保证了持续的写入性能。</li>
</ul>
</li>
<li><p><strong>SSTable (Sorted String Table)</strong>：</p>
<ul>
<li>Immutable MemTable 被<strong>顺序、批量</strong>地写入磁盘，形成一个 SSTable 文件。</li>
<li><strong>SSTable 是不可变的（Immutable）</strong>，其中的数据是<strong>按键排序</strong>的。</li>
<li>随着写入不断进行，磁盘上会积累多个 SSTable 文件。</li>
</ul>
</li>
<li><p><strong>Compaction（压缩合并）</strong>：</p>
<ul>
<li>这是 LSM 树的核心后台进程。它会将多个较小的、可能有键重叠的 SSTable <strong>合并（Merge-Sort）</strong> 成一个更大的、新的 SSTable，并在这个过程中丢弃已删除或过时的数据。</li>
<li>这个过程保证了数据的有序性和减少了文件数量，从而优化读性能。</li>
</ul>
</li>
</ol>
<h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><ul>
<li><strong>极高的写入吞吐量</strong>：写入几乎是纯顺序 I/O（写 WAL 和刷写 SSTable），速度极快，远超 B+树的随机写入。</li>
<li><strong>良好的压缩效率</strong>：由于 SSTable 是不可变且有序的，可以采用高效的压缩算法，节省磁盘空间。</li>
</ul>
<h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li><strong>读放大（Read Amplification）</strong>：一次读操作可能需要检查 MemTable 和多个 SSTable 文件（使用布隆过滤器等优化技术来减少不必要的文件查找），延迟可能不如 B+树稳定且通常更高。</li>
<li><strong>写放大（Write Amplification）</strong>：Compaction 过程会反复重写数据，带来额外的磁盘写入。</li>
<li><strong>空间放大（Space Amplification）</strong>：在 Compaction 发生前，重复的数据（不同版本）或已删除的数据可能同时存在于多个 SSTable 中，暂时占用额外空间。</li>
</ul>
<h3 id="总结与对比"><a href="#总结与对比" class="headerlink" title="总结与对比"></a>总结与对比</h3><table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">B 树</th>
<th align="left">B+树</th>
<th align="left">LSM 树</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>设计理念</strong></td>
<td align="left">平衡的多路搜索树，节点存数据</td>
<td align="left">B 树的变体，<strong>数据只存于叶子</strong>，<strong>叶子有链表</strong></td>
<td align="left"><strong>日志结构</strong>，先内存后磁盘，<strong>顺序写入</strong></td>
</tr>
<tr>
<td align="left"><strong>最佳场景</strong></td>
<td align="left">通用（现在较少，多被 B+树替代）</td>
<td align="left"><strong>读多写少</strong>，<strong>频繁区间查询</strong>（OLTP，关系型数据库）</td>
<td align="left"><strong>写多读少</strong>，<strong>批量写入</strong>（时序数据，日志，NoSQL）</td>
</tr>
<tr>
<td align="left"><strong>写入性能</strong></td>
<td align="left">中等，可能涉及随机写入（节点分裂）</td>
<td align="left">中等，可能涉及随机写入（节点分裂）</td>
<td align="left"><strong>极高</strong>，基本是顺序写入</td>
</tr>
<tr>
<td align="left"><strong>读取性能</strong></td>
<td align="left">良好（点查可能更快）</td>
<td align="left"><strong>优秀</strong>（点查和范围查都非常高效）</td>
<td align="left">相对较差，存在读放大，需要查询多个结构</td>
</tr>
<tr>
<td align="left"><strong>空间开销</strong></td>
<td align="left">节点存储数据，树可能略高</td>
<td align="left">内部节点只存键，更矮胖，但叶子链表有额外指针</td>
<td align="left">写放大和空间放大（Compaction 前），但压缩率高</td>
</tr>
<tr>
<td align="left"><strong>复杂度</strong></td>
<td align="left">中（分裂/合并）</td>
<td align="left">中（分裂/合并，维护链表）</td>
<td align="left">高（需管理 MemTable，SSTable，Compaction 策略）</td>
</tr>
</tbody></table>
<ul>
<li>如果你的应用是<strong>传统的 OLTP 业务</strong>，有大量随机读和范围查询（如电商、ERP），<strong>B+ 树</strong>是首选。</li>
<li>如果你的应用是<strong>监控、日志采集、物联网传感器数据</strong>等<strong>海量写入</strong>的场景，对写入速度要求极高，并能接受稍慢的读速度，<strong>LSM 树</strong>是更优的选择。</li>
</ul>
<h2 id="100-placement-new-的使用场景及其内存分配约束"><a href="#100-placement-new-的使用场景及其内存分配约束" class="headerlink" title="100. placement new 的使用场景及其内存分配约束"></a>100. <code>placement new</code> 的使用场景及其内存分配约束</h2><blockquote>
<p>字节面试题、华为面试题</p>
</blockquote>
<p>C++ 中 <code>placement new</code> 的使用场景和内存分配约束。这是一个高级但非常重要的特性，常用于需要精细控制内存管理的场景。</p>
<h3 id="核心概念：将“内存分配”与“对象构造”分离"><a href="#核心概念：将“内存分配”与“对象构造”分离" class="headerlink" title="核心概念：将“内存分配”与“对象构造”分离"></a>核心概念：将“内存分配”与“对象构造”分离</h3><p>通常，<code>new</code> 运算符做了两件事：</p>
<ol>
<li><strong>分配内存</strong>：在堆上分配足够大小的内存以容纳该类型的对象。</li>
<li><strong>构造对象</strong>：在刚刚分配的内存上调用对象的构造函数。</li>
</ol>
<p><code>delete</code> 运算符则做了相反的两件事：</p>
<ol>
<li><strong>析构对象</strong>：调用对象的析构函数。</li>
<li><strong>释放内存</strong>：释放对象所占用的内存。</li>
</ol>
<p><code>placement new</code> 允许你将这两个步骤分离开来。<strong>它只执行第二步（构造对象），而不分配任何内存</strong>。你负责提前提供一块内存，<code>placement new</code> 只是在这块你提供的内存上调用构造函数。</p>
<p>它的标准形式如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;new&gt;</span> <span class="comment">// 必须包含的头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* preallocatedMemory = ...; <span class="comment">// 你事先获得的一块内存</span></span><br><span class="line">MyClass* obj = <span class="built_in">new</span> (preallocatedMemory) <span class="built_in">MyClass</span>(constructorArgs);</span><br></pre></td></tr></tbody></table></figure>
<p>这里的 <code>(preallocatedMemory)</code> 就是“placement”参数。<code>placement new</code> 是 <code>operator new</code> 的一个重载版本。</p>
<h3 id="主要使用场景"><a href="#主要使用场景" class="headerlink" title="主要使用场景"></a>主要使用场景</h3><p><code>placement new</code> 的应用几乎总是围绕着性能、自定义内存管理或特殊需求。</p>
<h4 id="1-内存池和自定义内存分配器"><a href="#1-内存池和自定义内存分配器" class="headerlink" title="1. 内存池和自定义内存分配器"></a>1. 内存池和自定义内存分配器</h4><p>这是最常见和最重要的用途。</p>
<ul>
<li><strong>场景</strong>：在性能关键的系统中（如游戏引擎、高频交易），频繁地使用默认的 <code>new</code> 和 <code>delete</code> 会导致堆碎片和分配开销（因为需要查找合适的内存块、维护堆数据结构等）。</li>
<li><strong>做法</strong>：程序启动时，一次性分配一大块内存（“内存池”）。当需要创建对象时，从这块大内存中手动划分出一小块空闲内存，然后使用 <code>placement new</code> 在这小块内存上构造对象。对象销毁时，手动调用析构函数，然后将内存标记为空闲并归还给内存池，而不是调用 <code>delete</code>。</li>
<li><strong>优点</strong>：<ul>
<li><strong>极快的分配/释放速度</strong>：只是移动指针或操作空闲链表。</li>
<li><strong>避免内存碎片</strong>：所有对象都从连续的大块内存中分配。</li>
<li><strong>更好的局部性</strong>：连续分配的对象在物理内存上也很可能连续，提高缓存命中率。</li>
</ul>
</li>
</ul>
<h4 id="2-在特定内存地址构造对象"><a href="#2-在特定内存地址构造对象" class="headerlink" title="2. 在特定内存地址构造对象"></a>2. 在特定内存地址构造对象</h4><ul>
<li><strong>场景</strong>：需要与硬件或特定系统接口交互时。例如，在嵌入式系统中，你可能需要将一个对象直接构造在某个已知的硬件寄存器地址或共享内存段上。</li>
<li><strong>做法</strong>：直接将硬件地址或共享内存地址作为 <code>placement new</code> 的参数。<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> HardwareRegister* reg = <span class="built_in">new</span> (<span class="number">0xFFFF0000</span>) HardwareRegister;</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h4 id="3-非标准内存布局（例如：数组的精确控制）"><a href="#3-非标准内存布局（例如：数组的精确控制）" class="headerlink" title="3. 非标准内存布局（例如：数组的精确控制）"></a>3. 非标准内存布局（例如：数组的精确控制）</h4><ul>
<li><strong>场景</strong>：你想手动管理一个对象数组的生命周期，或者需要绕过 <code>new[]</code> 和 <code>delete[]</code> 可能带来的额外开销（例如存储数组大小的开销）。</li>
<li><strong>做法</strong>：先分配一个足够大的 <code>char</code> 数组（<code>sizeof(MyClass) * N</code>），然后使用循环和 <code>placement new</code> 在正确的位置逐个构造对象。销毁时，必须手动逆序调用每个对象的析构函数，最后释放整个 <code>char</code> 数组。</li>
</ul>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;new&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> {...};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 分配原始内存（不构造对象）</span></span><br><span class="line"><span class="type">void</span>* memory = <span class="keyword">operator</span> <span class="keyword">new</span>[](<span class="built_in">sizeof</span>(MyClass) * <span class="number">10</span>);</span><br><span class="line">MyClass* objects = <span class="built_in">static_cast</span>&lt;MyClass*&gt;(memory);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 使用 placement new 构造对象</span></span><br><span class="line"><span class="keyword">for</span> (std::<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) {</span><br><span class="line">    <span class="keyword">new</span> (&amp;objects[i]) <span class="built_in">MyClass</span>(...); <span class="comment">// 在指定地址构造</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 手动调用析构函数</span></span><br><span class="line"><span class="keyword">for</span> (std::<span class="type">size_t</span> i = <span class="number">10</span>; i &gt; <span class="number">0</span>; ) {</span><br><span class="line">    --i;</span><br><span class="line">    objects[i].~<span class="built_in">MyClass</span>(); <span class="comment">// 显式析构</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 释放原始内存</span></span><br><span class="line"><span class="keyword">operator</span> <span class="keyword">delete</span>[](memory);</span><br></pre></td></tr></tbody></table></figure>

<h4 id="4-实现类似-std-vector-和-std-make-shared-的容器和智能指针"><a href="#4-实现类似-std-vector-和-std-make-shared-的容器和智能指针" class="headerlink" title="4. 实现类似 std::vector 和 std::make_shared 的容器和智能指针"></a>4. 实现类似 <code>std::vector</code> 和 <code>std::make_shared</code> 的容器和智能指针</h4><p>标准库容器（如 <code>std::vector</code>）在底层使用 <code>allocator</code> 来分配原始内存，然后使用 <code>placement new</code> 在已分配的内存中构造元素。这使它们能够在重新分配时（<code>reserve</code>）将“分配新内存”和“移动/构造元素”分离开来。</p>
<p>类似地，<code>std::make_shared</code> 通常在一次分配中同时获得控制块（引用计数）和对象本身所需的内存，然后使用 <code>placement new</code> 在内存的正确偏移处构造对象。</p>
<h3 id="内存分配约束与注意事项（极其重要）"><a href="#内存分配约束与注意事项（极其重要）" class="headerlink" title="内存分配约束与注意事项（极其重要）"></a>内存分配约束与注意事项（极其重要）</h3><p>使用 <code>placement new</code> 意味着你接管了部分编译器的职责，因此必须严格遵守以下约束：</p>
<h4 id="1-内存必须提前分配且足够大"><a href="#1-内存必须提前分配且足够大" class="headerlink" title="1. 内存必须提前分配且足够大"></a>1. 内存必须提前分配且足够大</h4><p>你提供的指针 <code>preallocatedMemory</code> 必须指向一块已经分配好的内存，并且这块内存的大小<strong>至少</strong>为 <code>sizeof(MyClass)</code> 字节。如果内存不足，构造函数的行为是未定义的（通常是灾难性的崩溃或数据损坏）。</p>
<h4 id="2-内存对齐必须正确"><a href="#2-内存对齐必须正确" class="headerlink" title="2. 内存对齐必须正确"></a>2. 内存对齐必须正确</h4><p>你提供的内存地址必须满足该类型 <code>MyClass</code> 的<strong>内存对齐要求</strong>。C++11 之后可以使用 <code>alignof(MyClass)</code> 来查询对齐要求，使用 <code>alignas(MyClass) char buf[sizeof(MyClass)];</code> 来声明一个正确对齐的缓冲区。</p>
<p><strong>错误示例</strong>：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> buffer[<span class="built_in">sizeof</span>(MyClass)]; <span class="comment">// 一个普通的char数组，可能只按1字节对齐</span></span><br><span class="line">MyClass* obj = <span class="built_in">new</span> (buffer) MyClass; <span class="comment">// 如果MyClass要求4或8字节对齐，此行为未定义！</span></span><br></pre></td></tr></tbody></table></figure>

<p><strong>正确做法</strong>：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++11 之前：使用编译器扩展或union技巧</span></span><br><span class="line"><span class="comment">// C++11 之后：</span></span><br><span class="line"><span class="built_in">alignas</span>(MyClass) std::byte buffer[<span class="built_in">sizeof</span>(MyClass)]; <span class="comment">// 正确对齐的缓冲区</span></span><br><span class="line">MyClass* obj = <span class="built_in">new</span> (buffer) MyClass; <span class="comment">// 安全</span></span><br></pre></td></tr></tbody></table></figure>

<h4 id="3-必须手动调用析构函数"><a href="#3-必须手动调用析构函数" class="headerlink" title="3. 必须手动调用析构函数"></a>3. 必须手动调用析构函数</h4><p>由于 <code>placement new</code> 不分配内存，所以标准的 <code>delete obj;</code> <strong>不能使用</strong>。<code>delete</code> 会尝试释放内存，但你提供的内存并不是由 <code>new</code> 分配的，释放它会导致未定义行为。</p>
<p>你<strong>必须</strong>显式地调用析构函数来销毁对象：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj-&gt;~<span class="built_in">MyClass</span>(); <span class="comment">// 正确：只执行析构，不释放内存</span></span><br></pre></td></tr></tbody></table></figure>
<p>之后，你提供的原始内存如何处理（是复用、归还给内存池还是直接释放）取决于你最初是如何分配它的。</p>
<h4 id="4-生命周期管理的责任完全在程序员"><a href="#4-生命周期管理的责任完全在程序员" class="headerlink" title="4. 生命周期管理的责任完全在程序员"></a>4. 生命周期管理的责任完全在程序员</h4><p>你需要确保：</p>
<ul>
<li>对象在其生命周期内，其底层内存<strong>保持有效且未被覆盖</strong>。</li>
<li><strong>不要</strong>对使用 <code>placement new</code> 创建的对象调用 <code>delete</code>。</li>
<li>在底层内存被释放或重用<strong>之前</strong>，必须调用析构函数。</li>
</ul>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">标准 <code>new</code>/<code>delete</code></th>
<th align="left"><code>placement new</code></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>内存来源</strong></td>
<td align="left">堆</td>
<td align="left"><strong>由程序员预先提供</strong></td>
</tr>
<tr>
<td align="left"><strong>执行操作</strong></td>
<td align="left">分配内存 + 调用构造函数</td>
<td align="left"><strong>仅调用构造函数</strong></td>
</tr>
<tr>
<td align="left"><strong>清理操作</strong></td>
<td align="left">调用析构函数 + 释放内存</td>
<td align="left"><strong>必须手动调用析构函数</strong></td>
</tr>
<tr>
<td align="left"><strong>使用场景</strong></td>
<td align="left">通用</td>
<td align="left"><strong>内存池、自定义分配器、特定地址构造、容器实现</strong></td>
</tr>
<tr>
<td align="left"><strong>风险</strong></td>
<td align="left">低</td>
<td align="left"><strong>高（内存对齐、手动生命周期管理）</strong></td>
</tr>
</tbody></table>
<p><strong>总而言之，<code>placement new</code> 是一个强大的工具，它将对象的构造与内存分配解耦，为你提供了极致的内存控制能力。然而，这种能力也带来了巨大的责任，你必须严格遵守内存对齐和生命周期管理的规则，否则极易引发难以调试的未定义行为</strong>。在大多数日常应用开发中，你不需要直接使用它，但它却是许多高性能库和系统底层实现的基石。</p>
<h2 id="101-智能指针的应用场景和线程安全问题"><a href="#101-智能指针的应用场景和线程安全问题" class="headerlink" title="101. 智能指针的应用场景和线程安全问题"></a>101. 智能指针的应用场景和线程安全问题</h2><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>智能指针用于自动化资源（尤其是动态内存）的生命周期管理，防止内存泄漏。</p>
<ul>
<li><strong><code>std::unique_ptr</code>（独占所有权）</strong>：<ul>
<li><strong>场景</strong>：适用于资源在任何时刻都只能被一个所有者拥有的情况。是资源管理的默认选择。</li>
<li><strong>例子</strong>：作为类的成员变量、在函数内部管理动态分配的对象、作为工厂函数的返回值。它替代了需要手动 <code>delete</code> 的原始指针。</li>
</ul>
</li>
<li><strong><code>std::shared_ptr</code>（共享所有权）</strong>：<ul>
<li><strong>场景</strong>：适用于多个对象需要共享同一个资源，并且只有在最后一个所有者被销毁时资源才能被释放的情况。</li>
<li><strong>例子</strong>：实现缓存机制（多个客户端可能共享同一个缓存对象）、在复杂的数据结构中（如图、节点之间可能共享所有权）、需要将指针存入多个容器中。</li>
</ul>
</li>
<li><strong><code>std::weak_ptr</code>（弱引用）</strong>：<ul>
<li><strong>场景</strong>：与 <code>std::shared_ptr</code> 搭配使用，解决 <code>shared_ptr</code> 的循环引用问题。它提供对共享资源的“非拥有”引用，不会增加引用计数。</li>
<li><strong>例子</strong>：<strong>观察者模式</strong>（主题持有观察者的 <code>weak_ptr</code>，避免观察者无法析构）、<strong>缓存</strong>（持有缓存对象的 <code>weak_ptr</code>，当主所有者释放对象后，缓存自动失效）、<strong>打破循环引用</strong>（如双链表节点中，父节点对子节点用 <code>shared_ptr</code>，子节点对父节点用 <code>weak_ptr</code>）。</li>
</ul>
</li>
</ul>
<h3 id="线程安全问题"><a href="#线程安全问题" class="headerlink" title="线程安全问题"></a>线程安全问题</h3><p><strong>智能指针本身的引用计数操作是线程安全的，但其指向的对象的读写需要用户自己同步。</strong></p>
<ol>
<li><strong>引用计数的线程安全</strong>：<ul>
<li><code>std::shared_ptr</code> 的引用计数控制块（control block）是原子操作的。因此，<strong>在多线程中复制或析构 <code>shared_ptr</code> 本身是安全的</strong>，不会导致引用计数混乱。这是一个非常重要的保证。</li>
</ul>
</li>
<li><strong>指向数据的线程不安全</strong>：<ul>
<li>多个线程同时读写<strong>同一个 <code>shared_ptr</code> 实例</strong>（例如，对其赋值或重置）是<strong>不安全</strong>的，需要加锁。这涉及到指针本身（<code>get()</code> 返回的值）的更改。</li>
<li>多个线程通过<strong>不同的 <code>shared_ptr</code> 实例</strong>（它们指向同一个对象）去访问和修改其指向的对象是<strong>不安全</strong>的。这属于典型的数据竞争，也是必须使用互斥锁（如 <code>std::mutex</code>）或其他同步机制来保护对对象本身的操作。</li>
</ul>
</li>
</ol>
<h2 id="更多内容，请关注牛客面经～"><a href="#更多内容，请关注牛客面经～" class="headerlink" title="更多内容，请关注牛客面经～"></a>更多内容，请关注牛客面经～</h2><p>…</p>

<div class="article-footer fs14">
    <section id="license">
      <div class="header"><span>License</span></div>
      <div class="body"><p>本文由 <a target="_blank" rel="noopener" href="https://github.com/Wu-yikun">Yikun Wu</a> 原创，采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议，转载请注明出处。</p>
</div>
    </section>
    
    <section id="share">
      <div class="header"><span>Share</span></div>
      <div class="body">
        <div class="link"><input class="copy-area" readonly="true" id="copy-link" value="https://wu-yikun.com/post/%E7%A7%8B%E6%8B%9B%E6%8C%87%E5%8D%97/2025-cpp/"></div>
        <div class="social-wrap dis-select"><a class="social share-item wechat" onclick="util.toggle(&quot;qrcode-wechat&quot;)"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/social/b32ef3da1162a.svg"></a><a class="social share-item weibo" target="_blank" rel="external nofollow noopener noreferrer" href="https://service.weibo.com/share/share.php?url=https://wu-yikun.com/post/%E7%A7%8B%E6%8B%9B%E6%8C%87%E5%8D%97/2025-cpp/&amp;title=✍️ 八股文 @ C++ - Coredump&amp;pics=https://cdn.jsdelivr.net/gh/Wu-yikun/OSS@master/uPic/20250823-GIegg2.png&amp;summary=记录面经高频 C++ 题，实时更新中..."><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/social/80c07e4dbb303.svg"></a><a class="social share-item email" href="mailto:?subject=✍️ 八股文 @ C++ - Coredump&amp;body=https://wu-yikun.com/post/%E7%A7%8B%E6%8B%9B%E6%8C%87%E5%8D%97/2025-cpp/"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/social/a1b00e20f425d.svg"></a><a class="social share-item link" onclick="util.copy(&quot;copy-link&quot;, &quot;Copied!&quot;)"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/social/8411ed322ced6.svg"></a></div>
        
        <div class="qrcode" id="qrcode-wechat" style="opacity:0;height:0">
          <img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://api.qrserver.com/v1/create-qr-code/?size=256x256&amp;data=https://wu-yikun.com/post/%E7%A7%8B%E6%8B%9B%E6%8C%87%E5%8D%97/2025-cpp/">
        </div>
        
      </div>
    </section>
    </div>
</article>
<div class="related-wrap" id="read-next"><section class="body"><div class="item" id="prev"><div class="note">Prev</div><a href="/post/%E7%A7%8B%E6%8B%9B%E6%8C%87%E5%8D%97/2025-os/">✍️ 八股文 @ 操作系统</a></div><div class="item" id="next"><div class="note">Next</div><a href="/post/%E7%A7%8B%E6%8B%9B%E6%8C%87%E5%8D%97/2025-scenario-questions/">✍️ 八股文 @ 场景题</a></div></section></div>




  <div class="related-wrap md-text" id="comments">
    <section class="header cmt-title cap theme">
      <p>Join discussion～</p>

    </section>
    <section class="body cmt-body giscus">
      

<svg class="loading" style="vertical-align:middle;fill:currentColor;overflow:hidden;" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2709"><path d="M832 512c0-176-144-320-320-320V128c211.2 0 384 172.8 384 384h-64zM192 512c0 176 144 320 320 320v64C300.8 896 128 723.2 128 512h64z" p-id="2710"></path></svg>

<div id="giscus" src="https://giscus.app/client.js" data-repo="Wu-yikun/wu-yikun.github.io" data-repo-id="R_kgDONub1yw" data-category="Q&amp;A" data-category-id="DIC_kwDONub1y84CmRgy" data-mapping="pathname" data-strict="0" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="top" data-theme="preferred_color_scheme" data-lang="en" data-loading="lazy" crossorigin="anonymous"></div>

    </section>
  </div>



<footer class="page-footer footnote"><hr><div class="text"><script defer="" src="https://vercount.one/js"></script>
<p><span id="busuanzi_container_site_pv">本站总访问量 <span id="busuanzi_value_site_pv"></span> 次</span></p>
<span class="totalcount">本站共发表 118 篇文章 · </span><span class="post-count">总计 472k 字</span><div><span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span></div></div></footer>


<script async="" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<script>
  function createtime() {
    var now = new Date();
    var grt= new Date("01/25/2025 00:00:00");
    now.setTime(now.getTime() + 250);
    days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days);
    hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours);
    if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum);
    mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;}
    seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);
    snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;}
    document.getElementById("timeDate").innerHTML = "本站已运行 "+dnum+" 天 ";
    document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒";
  };
  setInterval("createtime()",250);
</script>
<div class="main-mask" onclick="sidebar.dismiss()"></div></div><aside class="l_right">
<div class="widgets">

<widget class="widget-wrapper toc" id="data-toc" collapse="false"><div class="widget-header dis-select"><span class="name">On This Page</span><a class="cap-action" onclick="sidebar.toggleTOC()"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 6h11m-11 6h11m-11 6h11M4 6h1v4m-1 0h2m0 8H4c0-1 2-2 2-3s-1-1.5-2-1"></path></svg></a></div><div class="widget-body"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-gcc-%E7%BC%96%E8%AF%91%E6%B5%81%E7%A8%8B"><span class="toc-text">1. gcc 编译流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-C-%E5%92%8C-C-%E5%8C%BA%E5%88%AB%EF%BC%88%E5%87%BD%E6%95%B0-%E7%B1%BB-struct-class%EF%BC%89"><span class="toc-text">2. C 和 C++ 区别（函数/类/struct/class）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-C-%E5%92%8C-Java-%E5%8C%BA%E5%88%AB%EF%BC%88%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7%E3%80%81%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E3%80%81%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E7%AD%89%EF%BC%89"><span class="toc-text">3. C++ 和 Java 区别（语言特性、垃圾回收、应用场景等）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-C-%E4%B8%AD-const-%E5%92%8C-static-%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-text">4. C++ 中 const 和 static 关键字的作用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#static"><span class="toc-text">static</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#const"><span class="toc-text">const</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E8%AF%B4%E4%B8%80%E8%AF%B4-C-%E4%B8%AD%E5%9B%9B%E7%A7%8D-cast-%E8%BD%AC%E6%8D%A2"><span class="toc-text">5. 说一说 C++ 中四种 cast 转换</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#const-cast"><span class="toc-text">const_cast</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#static-cast"><span class="toc-text">static_cast</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#dynamic-cast"><span class="toc-text">dynamic_cast</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#reinterpret-cast"><span class="toc-text">reinterpret_cast</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E4%BD%BF%E7%94%A8-C-%E7%9A%84%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2%EF%BC%9F"><span class="toc-text">为什么不使用 C 的强制转换？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#static-cast-%E4%B8%8E-dynamic-cast-%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">static_cast 与 dynamic_cast 之间的区别？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-C-C-%E7%9A%84%E5%9B%9B%E5%A4%A7%E5%86%85%E5%AD%98%E5%88%86%E5%8C%BA%E5%92%8C%E5%B8%B8%E9%87%8F%E7%9A%84%E5%AD%98%E5%82%A8%E4%BD%8D%E7%BD%AE"><span class="toc-text">6. C/C++ 的四大内存分区和常量的存储位置</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%EF%B8%8F%E2%83%A3-%E6%A0%88%E5%8C%BA"><span class="toc-text">1️⃣ 栈区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%EF%B8%8F%E2%83%A3-%E5%A0%86%E5%8C%BA"><span class="toc-text">2️⃣ 堆区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%EF%B8%8F%E2%83%A3-%E9%9D%99%E6%80%81%E5%AD%98%E5%82%A8%E5%8C%BA"><span class="toc-text">3️⃣ 静态存储区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%EF%B8%8F%E2%83%A3-%E4%BB%A3%E7%A0%81%E5%8C%BA"><span class="toc-text">4️⃣ 代码区</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7a-C-%E4%B8%AD-class-%E7%9A%84%E5%A4%A7%E5%B0%8F%E7%94%B1%E5%93%AA%E4%BA%9B%E5%9B%A0%E7%B4%A0%E5%86%B3%E5%AE%9A%EF%BC%9F"><span class="toc-text">7a. C++ 中 class 的大小由哪些因素决定？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7b-7a-%E7%B1%BB%E4%BC%BC%E9%97%AE%E9%A2%98-C-%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8%E7%A9%BA%E9%97%B4%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%89%E6%8E%92%E7%9A%84%EF%BC%9F"><span class="toc-text">7b. [7a 类似问题] C++ 的对象存储空间是怎么安排的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-new-delete-%E5%92%8C-malloc-free-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%E5%92%8C%E8%81%94%E7%B3%BB%EF%BC%9F"><span class="toc-text">8. new/delete 和 malloc/free 有什么区别和联系？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%87%AA%E5%8A%A8%E5%88%A0%E9%99%A4"><span class="toc-text">对象的自动删除</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%94%A5-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9C%89%E4%BA%86-malloc-free-%E8%BF%98%E9%9C%80%E8%A6%81-new-delete"><span class="toc-text">🔥 为什么有了 malloc/free 还需要 new/delete</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%94%A5-malloc-%E4%B8%8E-free-%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%88brk-%E3%80%81mmap-%EF%BC%89"><span class="toc-text">🔥 malloc 与 free 的实现原理（brk()、mmap()）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%94%A5-%E8%A2%AB-free-%E5%9B%9E%E6%94%B6%E7%9A%84%E5%86%85%E5%AD%98%E6%98%AF%E7%AB%8B%E5%8D%B3%E8%BF%94%E5%9B%9E%E7%BB%99%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%90%97%EF%BC%9F"><span class="toc-text">🔥 被 free 回收的内存是立即返回给操作系统吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%94%A5-malloc%E3%80%81realloc%E3%80%81calloc-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">🔥 malloc、realloc、calloc 的区别？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-%E5%BC%82%E5%B8%B8-%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E6%9C%89%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9C%89%E4%BA%9B%E5%9C%BA%E5%90%88%E8%A6%81%E7%A6%81%E7%94%A8%EF%BC%9F"><span class="toc-text">9. 异常/错误处理有几种方法，为什么有些场合要禁用？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-C-%E7%9B%B8%E5%85%B3%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%8C%E4%BB%80%E4%B9%88%E6%98%AF%E9%87%8E%E6%8C%87%E9%92%88%EF%BC%8C%E6%9C%89%E5%93%AA%E4%BA%9B%E9%87%8E%E6%8C%87%E9%92%88%EF%BC%9F"><span class="toc-text">10. C 相关的问题，什么是野指针，有哪些野指针？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-%E4%BD%A0%E5%B9%B3%E5%B8%B8%E6%80%8E%E4%B9%88%E8%B0%83%E8%AF%95%E4%BB%A3%E7%A0%81%EF%BC%8C%E4%BD%A0%E8%83%BD%E6%83%B3%E5%88%B0%E5%A4%9A%E5%B0%91%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="toc-text">11. 你平常怎么调试代码，你能想到多少方法？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E8%B0%83%E8%AF%95%E5%99%A8-Debugger"><span class="toc-text">使用调试器 (Debugger)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E6%97%A5%E5%BF%97%E8%BE%93%E5%87%BA-Logging"><span class="toc-text">插入日志输出 (Logging)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95-Unit-Testing"><span class="toc-text">单元测试 (Unit Testing)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7-Static-Analysis"><span class="toc-text">静态分析工具 (Static Analysis)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%A1%E6%9F%A5-Code-Review"><span class="toc-text">代码审查 (Code Review)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%86%E6%88%90%E6%B5%8B%E8%AF%95-Integration-Testing"><span class="toc-text">集成测试 (Integration Testing)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E6%A3%80%E6%B5%8B%E5%B7%A5%E5%85%B7"><span class="toc-text">内存泄漏检测工具</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7"><span class="toc-text">运行时分析工具</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E6%96%AD%E7%82%B9%E5%92%8C%E6%97%A5%E5%BF%97%E6%96%AD%E7%82%B9"><span class="toc-text">条件断点和日志断点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9E%E6%BB%9A%E4%B8%8E%E5%88%86%E6%94%AF-Git-Bisect"><span class="toc-text">回滚与分支 (Git Bisect)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%85%E9%9A%9C%E6%B3%A8%E5%85%A5-Fault-Injection"><span class="toc-text">故障注入 (Fault Injection)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%88%86%E6%9E%90%E4%B8%8E%E8%B7%9F%E8%B8%AA-Dynamic-Analysis"><span class="toc-text">动态分析与跟踪 (Dynamic Analysis)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-%E4%BB%80%E4%B9%88%E6%98%AF-C-%E5%A4%9A%E6%80%81%EF%BC%9F"><span class="toc-text">12. 什么是 C++ 多态？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-%E4%BB%80%E4%B9%88%E6%98%AF%E8%99%9A%E5%87%BD%E6%95%B0%E4%B8%8E%E8%99%9A%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%EF%BC%8CC-%E8%99%9A%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="toc-text">13. 什么是虚函数与虚函数指针，C++ 虚函数的实现原理？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E5%87%BD%E6%95%B0-vtable-%E4%B8%8E%E8%99%9A%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88-vptr"><span class="toc-text">虚函数 vtable 与虚函数指针 vptr</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C-%E8%99%9A%E5%87%BD%E6%95%B0%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-text">C++ 虚函数的内存分布 &amp; 实现原理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E5%8F%AF%E4%BB%A5%E6%98%AF%E8%99%9A%E5%87%BD%E6%95%B0%E5%90%97%EF%BC%9F%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E5%BF%85%E9%A1%BB%E6%98%AF%E8%99%9A%E5%87%BD%E6%95%B0%EF%BC%9F"><span class="toc-text">14. 析构函数可以是虚函数吗？什么情况下析构函数必须是虚函数？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%80%E8%88%AC%E4%B8%8D%E5%AE%9A%E4%B9%89%E4%B8%BA%E8%99%9A%E5%87%BD%E6%95%B0"><span class="toc-text">15. 构造函数为什么一般不定义为虚函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%EF%BC%9F%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%EF%BC%9F"><span class="toc-text">16. 构造函数的执行顺序？析构函数的执行顺序？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%EF%B8%8F%E2%83%A3-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E9%A1%BA%E5%BA%8F"><span class="toc-text">1️⃣ 构造函数顺序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%EF%B8%8F%E2%83%A3-%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E9%A1%BA%E5%BA%8F"><span class="toc-text">2️⃣ 析构函数顺序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17-%E9%9D%99%E6%80%81%E7%BB%91%E5%AE%9A%E5%92%8C%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A"><span class="toc-text">17. 静态绑定和动态绑定</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#18-%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0"><span class="toc-text">18. 纯虚函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#19-%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%88%E4%B8%BE%E4%BE%8B%E8%AF%B4%E6%98%8E%E6%B7%B1%E6%8B%B7%E8%B4%9D%E7%9A%84%E5%AE%89%E5%85%A8%E6%80%A7%EF%BC%89"><span class="toc-text">19. 深拷贝和浅拷贝的区别（举例说明深拷贝的安全性）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#20-%E8%AF%B4%E4%B8%80%E4%B8%8B%E4%BD%A0%E7%90%86%E8%A7%A3%E7%9A%84-C-%E5%9B%9B%E7%A7%8D%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%EF%BD%9Cshared-ptr-%E7%9A%84%E7%AE%80%E6%98%93%E5%AE%9E%E7%8E%B0"><span class="toc-text">20. 说一下你理解的 C++ 四种智能指针｜shared_ptr 的简易实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#0%EF%B8%8F%E2%83%A3-auto-ptr"><span class="toc-text">0️⃣ auto_ptr</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1%EF%B8%8F%E2%83%A3-shared-ptr-%E5%85%B1%E4%BA%AB%E5%BC%8F%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="toc-text">1️⃣ shared_ptr 共享式智能指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%EF%B8%8F%E2%83%A3-weak-ptr-%E5%BC%B1%E5%BC%95%E7%94%A8%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="toc-text">2️⃣ weak_ptr 弱引用智能指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%EF%B8%8F%E2%83%A3-unique-ptr-%E7%8B%AC%E5%8D%A0%E5%BC%8F%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%EF%BC%88%E6%9B%BF%E6%8D%A2-auto-ptr%EF%BC%89"><span class="toc-text">3️⃣ unique_ptr 独占式智能指针（替换 auto_ptr）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%94%A5-%E5%AE%9E%E7%8E%B0%E7%AE%80%E6%98%93%E7%9A%84-shared-ptr"><span class="toc-text">🔥 实现简易的 shared_ptr</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#21-shared-ptr-%E7%9A%84%E5%AE%9E%E7%8E%B0%EF%BC%8Cshared-ptr-%E4%B8%80%E5%AE%9A%E4%B8%8D%E4%BC%9A%E5%AF%BC%E8%87%B4%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E5%90%97%EF%BC%9F"><span class="toc-text">21. shared_ptr 的实现，shared_ptr 一定不会导致内存泄漏吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#22-STL-%E4%B8%AD-vector%E3%80%81list%E3%80%81map-%E7%9A%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E5%AE%9E%E7%8E%B0%E5%92%8C%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9F"><span class="toc-text">22. STL 中 vector、list、map 的底层原理实现和适用场景？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#23-%E8%8F%B1%E5%BD%A2%E7%BB%A7%E6%89%BF%E4%BC%9A%E5%87%BA%E7%8E%B0%E4%BA%8C%E4%B9%89%E6%80%A7%E9%97%AE%E9%A2%98%EF%BC%8CC-%E4%B8%AD%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E8%BF%99%E4%B8%AA%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-text">23. 菱形继承会出现二义性问题，C++ 中如何解决这个问题？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#24-%E5%8A%A8%E6%80%81%E7%BC%96%E8%AF%91-vs-%E9%9D%99%E6%80%81%E7%BC%96%E8%AF%91%EF%BC%8C%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5-vs-%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5%EF%BC%9F"><span class="toc-text">24. 动态编译 vs 静态编译，动态链接 vs 静态链接？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#25-%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%8E-operator-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">25. 拷贝构造函数与 operator=() 的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#26-%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E7%9A%84%E4%B8%BB%E8%A6%81%E7%94%A8%E9%80%94%EF%BC%9F"><span class="toc-text">26. 右值引用的主要用途？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%EF%B8%8F%E2%83%A3-%E5%AE%9E%E7%8E%B0%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89"><span class="toc-text">1️⃣ 实现移动语义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%EF%B8%8F%E2%83%A3-%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91"><span class="toc-text">2️⃣ 完美转发</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%92%88%E5%AF%B9%E3%80%8C%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91%E3%80%8D%EF%BC%8C%E8%AF%B7%E7%9C%8B%E5%A6%82%E4%B8%8B%E4%BE%8B%E5%AD%90"><span class="toc-text">针对「完美转发」，请看如下例子</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%A5%E5%85%85%EF%BC%9A%E5%B7%A6%E5%80%BC%E5%BC%95%E7%94%A8%EF%BC%88-%EF%BC%89%E4%B8%8E%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%EF%BC%88-%EF%BC%89"><span class="toc-text">补充：左值引用（&amp;）与右值引用（&amp;&amp;）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%94%A5-%E8%A1%A5%E5%85%85%EF%BC%9A%E4%B8%87%E8%83%BD%E5%BC%95%E7%94%A8%EF%BC%88T-%EF%BC%89"><span class="toc-text">🔥 补充：万能引用（T&amp;&amp;）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#27-C-%E4%B8%AD%E6%9C%89%E5%93%AA%E4%BA%9B%E9%94%81%EF%BC%9F"><span class="toc-text">27. C++ 中有哪些锁？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%92%E6%96%A5%E9%94%81%EF%BC%88Mutex%EF%BC%89"><span class="toc-text">互斥锁（Mutex）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E9%94%81-%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F%EF%BC%88Condition-Variable%EF%BC%89"><span class="toc-text">条件锁/条件变量（Condition Variable）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E6%97%8B%E9%94%81%EF%BC%88Spin-Lock%EF%BC%89"><span class="toc-text">自旋锁（Spin Lock）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB%E5%86%99%E9%94%81%EF%BC%88Read-Write-Lock%EF%BC%89"><span class="toc-text">读写锁（Read-Write Lock）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E9%94%81%EF%BC%88Recursive-Mutex%EF%BC%89"><span class="toc-text">递归锁（Recursive Mutex）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#28-%E5%A6%82%E4%BD%95%E7%94%A8-C-%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E8%AF%BB%E5%86%99%E9%94%81"><span class="toc-text">28. 如何用 C++ 实现一个读写锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#29-%E5%BC%95%E7%94%A8%E5%92%8C%E6%8C%87%E9%92%88%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%8C%E6%98%AF%E5%90%A6%E8%83%BD%E5%8A%A0-const%EF%BC%8C%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">29. 引用和指针的区别，是否能加 const，作用是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#30-%E5%93%88%E5%B8%8C%E6%A1%B6%E6%BB%A1%E4%BA%86%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F"><span class="toc-text">30. 哈希桶满了怎么办？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#31-AVL-vs-%E7%BA%A2%E9%BB%91%E6%A0%91"><span class="toc-text">31. AVL vs. 红黑树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#32-move-%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86"><span class="toc-text">32. move() 底层原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E5%85%B8%E5%9E%8B%E5%AE%9E%E7%8E%B0%EF%BC%89"><span class="toc-text">一、源码分析（典型实现）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90"><span class="toc-text">二、原理分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E5%AE%9E%E9%99%85%E7%9A%84%E2%80%9C%E7%A7%BB%E5%8A%A8%E2%80%9D%E5%A6%82%E4%BD%95%E5%8F%91%E7%94%9F%EF%BC%9F"><span class="toc-text">三、实际的“移动”如何发生？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-text">四、注意事项</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#33-%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BD%E5%88%B0%E5%86%85%E5%AD%98%E9%87%8C%EF%BC%8C%E5%85%B6%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84%EF%BC%9F"><span class="toc-text">33. 可执行文件加载到内存里，其内存布局是怎样的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#34-%E5%AE%8F%E5%AE%9A%E4%B9%89%E4%B8%8E%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">34. 宏定义与函数的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#35-%E5%AE%8F%E5%AE%9A%E4%B9%89-define-%E4%B8%8E-typedef-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">35. 宏定义 define 与 typedef 的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#36-%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E%E4%B8%8E%E5%AE%9A%E4%B9%89%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">36. 变量声明与定义的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#37-strlen-%E5%92%8C-sizeof-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">37. strlen 和 sizeof 的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#38-final-%E5%92%8C-override"><span class="toc-text">38. final 和 override</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#39-C-%E4%B8%8E-C-%E7%9A%84%E7%B1%BB%E5%9E%8B%E5%AE%89%E5%85%A8"><span class="toc-text">39. C 与 C++ 的类型安全</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#C-%E7%9A%84%E7%B1%BB%E5%9E%8B%E5%AE%89%E5%85%A8"><span class="toc-text">C 的类型安全</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C-%E7%B1%BB%E5%9E%8B%E5%AE%89%E5%85%A8"><span class="toc-text">C++ 类型安全</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#40-%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0-inline-%E5%92%8C%E5%AE%8F%E5%AE%9A%E4%B9%89-define-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">40. 内联函数 inline 和宏定义 define 的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#41-%E4%BB%80%E4%B9%88%E6%98%AF%E5%A4%A7%E5%B0%8F%E7%AB%AF%E5%AD%98%E5%82%A8%EF%BC%8C%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E7%94%A8%E4%BB%A3%E7%A0%81%E5%88%A4%E6%96%AD%E5%A4%A7%E5%B0%8F%E7%AB%AF%EF%BC%9F"><span class="toc-text">41. 什么是大小端存储，以及如何用代码判断大小端？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#42-C-%E4%B8%AD%E6%9C%89%E5%87%A0%E7%A7%8D%E7%B1%BB%E5%9E%8B%E7%9A%84-new%EF%BC%9F"><span class="toc-text">42. C++ 中有几种类型的 new？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-plain-new"><span class="toc-text">(1) plain new</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-nothrow-new"><span class="toc-text">(2) nothrow new</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-placement-new"><span class="toc-text">(3) placement new</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#43-C-11-%E6%96%B0%E7%89%B9%E6%80%A7%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-text">43. C++ 11 新特性有哪些？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#44-C-class-%E4%B8%8E-C-struct-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">44. C++ class 与 C struct 的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#45-%E6%80%8E%E4%B9%88%E4%BC%98%E5%8C%96%E7%B3%BB%E7%BB%9F%E6%80%A7%E8%83%BD"><span class="toc-text">45. 怎么优化系统性能</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%BC%98%E5%8C%96"><span class="toc-text">内存管理优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#I-O-%E4%BC%98%E5%8C%96"><span class="toc-text">I/O 优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E4%B8%8E%E7%93%B6%E9%A2%88%E5%AE%9A%E4%BD%8D"><span class="toc-text">性能分析与瓶颈定位</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#46-%E8%AF%B4%E8%AF%B4%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%8E%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-text">46. 说说移动构造函数与拷贝构造函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#47-C-%E4%B8%AD%E6%8C%87%E9%92%88%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E5%92%8C%E5%BC%95%E7%94%A8%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">47. C++ 中指针参数传递和引用参数传递有什么区别？底层原理是什么？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%8C%87%E9%92%88%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E6%9C%AC%E8%B4%A8%E4%B8%8A%E6%98%AF%E5%80%BC%E4%BC%A0%E9%80%92%EF%BC%8C%E5%AE%83%E6%89%80%E4%BC%A0%E9%80%92%E7%9A%84%E6%98%AF%E4%B8%80%E4%B8%AA%E5%9C%B0%E5%9D%80%E5%80%BC"><span class="toc-text">(1) 指针参数传递本质上是值传递，它所传递的是一个地址值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%BC%95%E7%94%A8%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E8%BF%87%E7%A8%8B%E4%B8%AD%EF%BC%8C%E8%A2%AB%E8%B0%83%E5%87%BD%E6%95%B0%E7%9A%84%E5%BD%A2%E5%BC%8F%E5%8F%82%E6%95%B0%E4%B9%9F%E4%BD%9C%E4%B8%BA%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E5%9C%A8%E6%A0%88%E4%B8%AD%E5%BC%80%E8%BE%9F%E4%BA%86%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%EF%BC%8C%E4%BD%86%E6%98%AF%E8%BF%99%E6%97%B6%E5%AD%98%E6%94%BE%E7%9A%84%E6%98%AF%E7%94%B1%E4%B8%BB%E8%B0%83%E5%87%BD%E6%95%B0%E6%94%BE%E8%BF%9B%E6%9D%A5%E7%9A%84%E5%AE%9E%E5%8F%82%E5%8F%98%E9%87%8F%E7%9A%84%E5%9C%B0%E5%9D%80"><span class="toc-text">(2) 引用参数传递过程中，被调函数的形式参数也作为局部变量在栈中开辟了内存空间，但是这时存放的是由主调函数放进来的实参变量的地址</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E8%80%85%E5%8C%BA%E5%88%AB"><span class="toc-text">二者区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#48-C-%E4%B8%AD%E7%B1%BB%E6%88%90%E5%91%98%E7%9A%84%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90%E5%92%8C%E7%BB%A7%E6%89%BF%E6%9D%83%E9%99%90%E9%97%AE%E9%A2%98"><span class="toc-text">48. C++ 中类成员的访问权限和继承权限问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90"><span class="toc-text">访问权限</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E6%96%B9%E5%BC%8F"><span class="toc-text">继承方式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#49-%E5%AE%9A%E4%B9%89%E4%B8%8E%E5%A3%B0%E6%98%8E%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">49. 定义与声明的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#50-%E4%BD%A0%E7%9F%A5%E9%81%93-strcpy-%E4%B8%8E-memcpy-%E7%9A%84%E5%8C%BA%E5%88%AB%E5%90%97"><span class="toc-text">50. 你知道 strcpy 与 memcpy 的区别吗</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#51-volatile-%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-text">51. volatile 关键字的作用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E5%9B%9E%E7%AD%94"><span class="toc-text">面试回答</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E9%87%8A"><span class="toc-text">解释</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#52-%E5%A6%82%E6%9E%9C%E6%9C%89%E4%B8%80%E4%B8%AA%E7%A9%BA%E7%B1%BB%EF%BC%8C%E5%AE%83%E4%BC%9A%E9%BB%98%E8%AE%A4%E5%AD%98%E5%9C%A8%E5%93%AA%E4%BA%9B%E5%87%BD%E6%95%B0%EF%BC%9F"><span class="toc-text">52. 如果有一个空类，它会默认存在哪些函数？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#53-const-char-%E4%B8%8E-string-%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">53. const char* 与 string 之间的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#54-static-cast-%E6%AF%94-C-%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E8%BD%AC%E6%8D%A2%E5%A5%BD%E5%9C%A8%E5%93%AA%E9%87%8C%EF%BC%9F"><span class="toc-text">54. static_cast 比 C 语言中的转换好在哪里？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#55-delete-%E5%92%8C-delete-%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">55. delete 和 delete[] 区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#56-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E6%8A%8A%E6%89%80%E6%9C%89%E5%87%BD%E6%95%B0%E5%86%99%E6%88%90%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0%EF%BC%9F"><span class="toc-text">56. 为什么不把所有函数写成内联函数？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#57-%E5%93%AA%E4%BA%9B%E5%87%BD%E6%95%B0%E4%B8%8D%E8%83%BD%E6%98%AF%E8%99%9A%E5%87%BD%E6%95%B0%EF%BC%9F"><span class="toc-text">57. 哪些函数不能是虚函数？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#58-%E4%BB%80%E4%B9%88%E5%8E%9F%E5%9B%A0%E9%80%A0%E6%88%90%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%EF%BC%8C%E4%BD%A0%E6%80%8E%E4%B9%88%E9%81%BF%E5%85%8D-%E8%A7%A3%E5%86%B3%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%EF%BC%9F"><span class="toc-text">58. 什么原因造成内存泄露，你怎么避免/解决内存泄露？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%EF%B8%8F%E2%83%A3-%E4%BB%80%E4%B9%88%E6%98%AF%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%EF%BC%9F"><span class="toc-text">1️⃣ 什么是内存泄露？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%EF%B8%8F%E2%83%A3-%E4%BB%80%E4%B9%88%E5%8E%9F%E5%9B%A0%E9%80%A0%E6%88%90%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%EF%BC%9F"><span class="toc-text">2️⃣ 什么原因造成内存泄露？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%EF%B8%8F%E2%83%A3-%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D-%E8%A7%A3%E5%86%B3%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2-%E2%80%BC%EF%B8%8F"><span class="toc-text">3️⃣ 如何避免/解决内存泄露 ‼️</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%EF%B8%8F%E2%83%A3-%E5%A6%82%E4%BD%95%E5%AE%9A%E4%BD%8D%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2"><span class="toc-text">4️⃣ 如何定位内存泄露</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#59-C-%E5%86%99%E4%BA%86%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%EF%BC%8C%E7%B3%BB%E7%BB%9F%E4%BC%9A%E5%B8%AE%E6%88%91%E4%BB%AC%E7%94%9F%E6%88%90%E9%BB%98%E8%AE%A4%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E8%BF%99%E4%BA%9B%E5%90%97%EF%BC%88%E4%BB%8B%E7%BB%8D-C-%E5%85%AD%E4%B8%AA%E7%89%B9%E6%AE%8A%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%EF%BC%89"><span class="toc-text">59. C++ 写了析构函数，系统会帮我们生成默认移动构造函数这些吗（介绍 C++ 六个特殊成员函数）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#60-C-%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E5%92%8C%E7%A7%BB%E5%8A%A8%E6%8B%B7%E8%B4%9D-%E8%B5%8B%E5%80%BC-%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-text">60. C++ 右值引用和移动拷贝(赋值)函数的作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#61-C-%E7%BA%BF%E7%A8%8B-thread-local-%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">61. C++ 线程 thread_local 的作用是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#62-%E5%A6%82%E4%BD%95%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA%E5%8F%AA%E8%83%BD%E5%9C%A8%E5%A0%86%E4%B8%8A%EF%BC%88%E6%A0%88%E4%B8%8A%EF%BC%89%E7%94%9F%E6%88%90%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%B1%BB%EF%BC%9F"><span class="toc-text">62. 如何定义一个只能在堆上（栈上）生成对象的类？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AA%E8%83%BD%E5%9C%A8%E5%A0%86%E4%B8%8A"><span class="toc-text">只能在堆上</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AA%E8%83%BD%E5%9C%A8%E6%A0%88%E4%B8%8A"><span class="toc-text">只能在栈上</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#63-%E9%80%92%E5%BD%92%E8%BF%87%E6%B7%B1%E4%BC%9A%E9%80%A0%E6%88%90%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%8COOM-%E5%90%97%EF%BC%9F"><span class="toc-text">63. 递归过深会造成什么问题，OOM 吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#64-%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96%E5%89%8D-K-%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0%EF%BC%9F"><span class="toc-text">64. 如何获取前 K 个最大元素？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95%E4%B8%80%EF%BC%9A%E6%8E%92%E5%BA%8F%E6%B3%95%EF%BC%88%E9%80%82%E5%90%88%E6%95%B0%E6%8D%AE%E9%87%8F%E4%B8%8D%E5%A4%A7%EF%BC%89"><span class="toc-text">解法一：排序法（适合数据量不大）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95%E4%BA%8C%EF%BC%9A%E6%9C%80%E5%B0%8F%E5%A0%86%EF%BC%88%E6%8E%A8%E8%8D%90%EF%BC%8C%E9%80%82%E5%90%88%E5%A4%A7%E6%95%B0%E6%8D%AE%EF%BC%89"><span class="toc-text">解法二：最小堆（推荐，适合大数据）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%94%A5-%E8%A7%A3%E6%B3%95%E4%B8%89%EF%BC%9A%E5%BF%AB%E6%8E%92%E7%9A%84%E6%80%9D%E6%83%B3%EF%BC%88Top-K-%E9%97%AE%E9%A2%98%EF%BC%8C%E9%80%82%E5%90%88%E4%B8%8D%E8%A6%81%E6%B1%82%E5%AE%8C%E6%95%B4%E6%8E%92%E5%BA%8F%EF%BC%89"><span class="toc-text">🔥 解法三：快排的思想（Top-K 问题，适合不要求完整排序）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%85-%E6%80%BB%E7%BB%93%E5%AF%B9%E6%AF%94"><span class="toc-text">✅ 总结对比</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#65-%E5%A0%86%E5%92%8C%E6%A0%88%E5%9C%A8%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BA%95%E5%B1%82%E7%9A%84%E5%AE%9E%E7%8E%B0%EF%BC%9F"><span class="toc-text">65. 堆和栈在操作系统底层的实现？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A0%86%E4%B8%8E%E6%A0%88%E3%80%81%E8%BF%9B%E7%A8%8B%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E5%88%86%E5%B8%83"><span class="toc-text">堆与栈、进程虚拟内存空间分布</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%94%A5-%E6%A0%88%E5%9C%A8%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BA%95%E5%B1%82%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-text">🔥 栈在操作系统底层的实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%94%A5-%E5%A0%86%E5%9C%A8%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BA%95%E5%B1%82%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-text">🔥 堆在操作系统底层的实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%A0%88%E7%9A%84%E5%88%86%E9%85%8D%E9%80%9F%E5%BA%A6%E6%AF%94%E5%A0%86%E5%BF%AB%EF%BC%9F"><span class="toc-text">为什么栈的分配速度比堆快？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%A8%8B%E5%BA%8F%E4%B8%AD%EF%BC%8C%E5%A0%86%E5%92%8C%E6%A0%88%E5%A6%82%E4%BD%95%E9%9A%94%E7%A6%BB%EF%BC%9F"><span class="toc-text">多线程程序中，堆和栈如何隔离？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#66-C-mutable-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">66. C++ mutable 关键字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#67-%E8%AF%A6%E8%A7%A3%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90%EF%BC%88%E5%A6%82%E4%BD%95-padding%EF%BC%89%E5%8F%8A%E5%85%B6%E5%8E%9F%E5%9B%A0"><span class="toc-text">67. 详解内存对齐（如何 padding）及其原因</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#68-int-0-0-%E7%9A%84%E5%90%AB%E4%B9%89%EF%BC%9F"><span class="toc-text">68. *(int *)0 = 0 的含义？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#69-%E5%AE%8F%E5%AE%9A%E4%B9%89%E5%B1%95%E5%BC%80"><span class="toc-text">69. 宏定义展开</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#70-%E5%81%87%E8%AE%BE%E6%9C%89%E4%B8%80%E4%B8%AA%E4%BD%8D%E5%9B%BE%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9A%E4%B9%89%E4%B8%BA-uint32-t-bitmap-BSIZE-%EF%BC%8C%E8%AF%B7%E5%86%99%E5%87%BA%E7%94%A8%E4%BA%8E%E5%88%A4%E6%96%AD%E4%BD%8D%E5%9B%BE%E4%B8%AD%E7%AC%AC-bit-%E4%BD%8D%E6%98%AF%E5%90%A6%E4%B8%BA-1-%E7%9A%84%E5%A6%82%E4%B8%8B%E5%AE%8F%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-text">70. 假设有一个位图数据结构定义为 uint32_t bitmap[BSIZE];，请写出用于判断位图中第 bit 位是否为 1 的如下宏的实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#71-%E8%AF%BB%E5%86%99%E9%94%81%E4%B8%8E%E8%AF%BB%E4%BC%98%E5%85%88-%E5%86%99%E4%BC%98%E5%85%88"><span class="toc-text">71. 读写锁与读优先/写优先</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#72-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E6%98%AF%E5%A6%82%E4%BD%95%E9%80%9A%E4%BF%A1%E7%9A%84%EF%BC%9F%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E6%80%8E%E4%B9%88%E4%BA%A4%E4%BA%92%E7%9A%84%EF%BC%9F"><span class="toc-text">72. 多线程之间是如何通信的？线程之间怎么交互的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#73-%E5%85%B3%E4%BA%8E%E4%BD%BF%E7%94%A8-%E6%AF%94%E8%BE%83-double-%E7%B1%BB%E5%9E%8B"><span class="toc-text">73. 关于使用 == 比较 double 类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E7%9B%B4%E6%8E%A5%E7%94%A8-%E6%AF%94%E8%BE%83"><span class="toc-text">1. 为什么不能直接用 == 比较</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%AD%A3%E7%A1%AE%E7%9A%84%E6%B5%AE%E7%82%B9%E6%95%B0%E6%AF%94%E8%BE%83%E6%96%B9%E6%B3%95"><span class="toc-text">2. 正确的浮点数比较方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8-%E7%9B%B4%E6%8E%A5%E6%AF%94%E8%BE%83"><span class="toc-text">3. 什么时候可以使用 == 直接比较</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#74-%E5%A0%86%E4%B8%8E%E6%A0%88%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9%E6%AF%94%E8%BE%83"><span class="toc-text">74. 堆与栈的优缺点比较</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%88-Stack"><span class="toc-text">栈 - Stack</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A0%86-Heap"><span class="toc-text">堆 - Heap</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%BB%BA%E8%AE%AE"><span class="toc-text">使用建议</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#75-%E5%85%B3%E4%BA%8E-shared-ptr-%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%EF%BC%8820-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%EF%BC%89"><span class="toc-text">75. 关于 shared_ptr 的注意事项（20. 智能指针）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%B8%8D%E8%A6%81%E7%94%A8%E4%B8%80%E4%B8%AA%E8%A3%B8%E6%8C%87%E9%92%88%E5%88%9D%E5%A7%8B%E5%8C%96%E5%A4%9A%E4%B8%AA-shared-ptr%EF%BC%88%E4%BC%9A%E5%AF%BC%E8%87%B4-double-free%EF%BC%89"><span class="toc-text">1. 不要用一个裸指针初始化多个 shared_ptr（会导致 double free）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%AD%A3%E7%A1%AE%E4%BD%BF%E7%94%A8-shared-from-this-%E8%80%8C%E4%B8%8D%E6%98%AF%E7%9B%B4%E6%8E%A5%E8%BF%94%E5%9B%9E-this-%E6%8C%87%E9%92%88"><span class="toc-text">2. 正确使用 shared_from_this() 而不是直接返回 this 指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E4%BC%98%E5%85%88%E4%BD%BF%E7%94%A8-std-make-shared-%E8%80%8C%E4%B8%8D%E6%98%AF-new"><span class="toc-text">3. 优先使用 std::make_shared&lt;T&gt;() 而不是 new</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E4%B8%8D%E8%A6%81-delete-get-%E8%BF%94%E5%9B%9E%E7%9A%84%E8%A3%B8%E6%8C%87%E9%92%88"><span class="toc-text">4. 不要 delete get() 返回的裸指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E9%9D%9E-new-%E5%88%86%E9%85%8D%E7%9A%84%E5%86%85%E5%AD%98%E9%9C%80%E8%A6%81%E8%87%AA%E5%AE%9A%E4%B9%89%E5%88%A0%E9%99%A4%E5%99%A8"><span class="toc-text">5. 非 new 分配的内存需要自定义删除器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E9%81%BF%E5%85%8D%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8%E5%AF%BC%E8%87%B4%E7%9A%84%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2"><span class="toc-text">6. 避免循环引用导致的内存泄露</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#76-std-shared-ptr-%E5%8F%AF%E4%BB%A5%E9%80%9A%E8%BF%87-std-make-shared-%E5%92%8C%E7%9B%B4%E6%8E%A5%E4%BD%BF%E7%94%A8-new-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%9E%84%E9%80%A0%EF%BC%8C%E4%BA%8C%E8%80%85%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">76. std::shared_ptr 可以通过 std::make_shared 和直接使用 new 表达式构造，二者有什么区别？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E6%96%B9%E5%BC%8F"><span class="toc-text">1. 内存分配方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%80%A7%E8%83%BD%E5%B7%AE%E5%BC%82"><span class="toc-text">2. 性能差异</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%BC%82%E5%B8%B8%E5%AE%89%E5%85%A8%E6%80%A7"><span class="toc-text">3. 异常安全性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%AF%B9%E8%B1%A1%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%9A%84%E5%BD%B1%E5%93%8D"><span class="toc-text">4. 对象生命周期的影响</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E9%99%90%E5%88%B6"><span class="toc-text">5. 使用场景限制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#77-shared-ptr-%E7%9A%84%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E6%98%AF%E5%9C%A8%E6%A0%88%E8%BF%98%E6%98%AF%E5%A0%86%EF%BC%9F"><span class="toc-text">77. shared_ptr 的引用计数是在栈还是堆？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#78-%E5%9F%BA%E7%B1%BB%E7%9A%84%E8%99%9A%E5%87%BD%E6%95%B0%E5%8F%AF%E4%BB%A5%E5%A3%B0%E6%98%8E%E4%B8%BA-private-%E5%90%97"><span class="toc-text">78. 基类的虚函数可以声明为 private 吗</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95%E5%85%81%E8%AE%B8%EF%BC%8C%E4%BD%86%E8%AE%BF%E9%97%AE%E5%8F%97%E9%99%90"><span class="toc-text">语法允许，但访问受限</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E6%80%81%E8%A1%8C%E4%B8%BA%E4%BB%8D%E7%84%B6%E6%9C%89%E6%95%88"><span class="toc-text">多态行为仍然有效</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#79-%E5%A6%82%E6%9E%9C%E6%9C%89-100-%E4%B8%AA%E5%AF%B9%E8%B1%A1%EF%BC%8Cvector%E3%80%81list%E3%80%81map-%E5%93%AA%E4%B8%AA%E5%8D%A0%E7%94%A8%E5%86%85%E5%AD%98%E9%AB%98"><span class="toc-text">79. 如果有 100 个对象，vector、list、map 哪个占用内存高</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-vector"><span class="toc-text">1. vector</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-list"><span class="toc-text">2. list</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-map%EF%BC%88%E9%80%9A%E5%B8%B8%E6%98%AF%E7%BA%A2%E9%BB%91%E6%A0%91%EF%BC%89"><span class="toc-text">3. map（通常是红黑树）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E8%AE%BA%EF%BC%88%E5%86%85%E5%AD%98%E5%8D%A0%E7%94%A8%E6%AF%94%E8%BE%83%EF%BC%89"><span class="toc-text">结论（内存占用比较）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#80-%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8%E5%92%8C%E8%99%9A%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E5%AD%98%E5%82%A8%E5%9C%A8%E5%93%AA%E9%87%8C%EF%BC%9F"><span class="toc-text">80. 虚函数表和虚函数指针存储在哪里？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8%EF%BC%88vtable%EF%BC%89"><span class="toc-text">虚函数表（vtable）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%EF%BC%88vptr%EF%BC%89"><span class="toc-text">虚函数指针（vptr）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BE%E4%BE%8B%E4%B8%8E%E6%80%BB%E7%BB%93"><span class="toc-text">举例与总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#81-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E4%B8%80%E8%88%AC%E7%94%A8%E5%93%AA%E4%BA%9B%E5%BA%93%E5%87%BD%E6%95%B0%EF%BC%9F"><span class="toc-text">81. 多线程编程一般用哪些库函数？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#C-%E8%AF%AD%E8%A8%80%E5%B1%82%E9%9D%A2"><span class="toc-text">C 语言层面</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C-%E5%B1%82%E9%9D%A2"><span class="toc-text">C++ 层面</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#82-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E9%94%81%EF%BC%9F%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E9%9C%80%E8%A6%81%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%9F%E4%B8%BE%E4%B8%AA%E4%BE%8B%E5%AD%90"><span class="toc-text">82. 为什么需要锁？什么时候需要多线程？举个例子</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#83-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9C%BA%E6%99%AF%E4%B8%8B%E5%87%BA%E7%8E%B0%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E6%80%8E%E4%B9%88%E8%B0%83%E8%AF%95%E8%A7%A3%E5%86%B3%EF%BC%9F"><span class="toc-text">83. 多线程场景下出现内存泄漏怎么调试解决？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%94%A8-gdb-%E8%B0%83%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%AE%9E%E7%94%A8%E5%A5%97%E8%B7%AF"><span class="toc-text">(1) 用 gdb 调多线程的实用套路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%89%93%E6%97%A5%E5%BF%97%E2%86%92%E7%BA%BF%E4%B8%8A%E5%AE%9A%E4%BD%8D%E2%86%92%E5%A4%8D%E7%8E%B0%E5%89%AF%E6%9C%AC%E2%86%92%E7%9C%8B%E6%97%A5%E5%BF%97"><span class="toc-text">(2) 打日志→线上定位→复现副本→看日志</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#84-%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84%EF%BC%9F"><span class="toc-text">84. 程序的内存布局是怎样的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#85-delete-%E9%87%8A%E6%94%BE%E5%86%85%E5%AD%98%E7%9A%84%E6%97%B6%E5%80%99%E5%B9%B6%E4%B8%8D%E7%9F%A5%E9%81%93%E5%86%85%E5%AD%98%E5%A4%A7%E5%B0%8F%EF%BC%8C%E5%A6%82%E4%BD%95%E9%87%8A%E6%94%BE%EF%BC%9F"><span class="toc-text">85. delete 释放内存的时候并不知道内存大小，如何释放？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#86-%E4%B8%80%E4%B8%AA%E7%A9%BA%E7%B1%BB%E5%A4%A7%E5%B0%8F%E6%98%AF%E5%A4%9A%E5%B0%91%EF%BC%9F%E5%A6%82%E6%9E%9C%E6%9C%89%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E5%91%A2%EF%BC%9F%E5%A6%82%E6%9E%9C%E6%9C%89%E8%99%9A%E5%87%BD%E6%95%B0%EF%BC%9F"><span class="toc-text">86. 一个空类大小是多少？如果有构造函数和析构函数呢？如果有虚函数？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#87-%E6%8C%87%E9%92%88%E7%9A%84%E5%A4%A7%E5%B0%8F%E6%98%AF%E5%A4%9A%E5%B0%91%EF%BC%9F"><span class="toc-text">87. 指针的大小是多少？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#88-%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90%E4%BA%86%E8%A7%A3%E8%BF%87%E5%90%97%EF%BC%8C%E6%88%91%E5%A6%82%E6%9E%9C%E4%B8%8D%E6%83%B3%E5%AF%B9%E9%BD%90%EF%BC%8C%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F"><span class="toc-text">88. 内存对齐了解过吗，我如果不想对齐，怎么办？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#89-%E8%AE%B2%E8%AE%B2-unordered-map-%E5%92%8C-map-%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%92%8C%E5%8C%BA%E5%88%AB"><span class="toc-text">89. 讲讲 unordered_map 和 map 的底层实现和区别</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BA%E5%88%AB"><span class="toc-text">区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E8%AF%A6%E8%A7%A3"><span class="toc-text">底层实现详解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%EF%BC%9F"><span class="toc-text">如何选择？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#90-%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8BB%E6%A0%91-B-%E6%A0%91-%E7%BA%A2%E9%BB%91%E6%A0%91%E5%8F%8A%E5%85%B6%E5%AF%B9%E5%BA%94%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-text">90. 介绍一下B树/B+树/红黑树及其对应的应用场景有哪些</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#B-%E6%A0%91"><span class="toc-text">B 树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#B-%E6%A0%91-1"><span class="toc-text">B+ 树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%A2%E9%BB%91%E6%A0%91"><span class="toc-text">红黑树</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#91-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E7%94%B3%E8%AF%B7%E7%9A%84%E7%A9%BA%E9%97%B4%E6%98%AF%E5%9C%A8%E5%A0%86%E4%B8%8A%E8%BF%98%E6%98%AF%E5%9C%A8%E6%A0%88%E4%B8%8A%EF%BC%9F"><span class="toc-text">91. 智能指针申请的空间是在堆上还是在栈上？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#92-%E4%BB%8B%E7%BB%8D%E4%B8%8B-vector-%E5%8A%A8%E6%80%81%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6"><span class="toc-text">92. 介绍下 vector 动态扩容机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#93-vector-%E7%9A%84-push-back-%E5%92%8C-emplace-back-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">93. vector 的 push_back 和 emplace_back 的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#94-%E5%85%B3%E4%BA%8E-vector-%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%A4%B1%E6%95%88"><span class="toc-text">94. 关于 vector 迭代器失效</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%8F%92%E5%85%A5%E5%85%83%E7%B4%A0-insert-emplace-push-back-emplace-back"><span class="toc-text">1. 插入元素 (insert, emplace, push_back, emplace_back)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0-erase-pop-back"><span class="toc-text">2. 删除元素 (erase, pop_back)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%94%B9%E5%8F%98%E5%AE%B9%E9%87%8F-reserve-resize-shrink-to-fit"><span class="toc-text">3. 改变容量 (reserve, resize, shrink_to_fit)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E4%BA%A4%E6%8D%A2-swap"><span class="toc-text">4. 交换 (swap)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E6%B8%85%E7%A9%BA-clear"><span class="toc-text">5. 清空 (clear)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#95-C-%E4%B8%8D%E5%90%8C%E6%9D%83%E9%99%90%E7%BB%A7%E6%89%BF%E5%88%86%E5%88%AB%E4%BC%9A%E6%9C%89%E6%80%8E%E6%A0%B7%E7%9A%84%E8%A1%A8%E7%8E%B0%EF%BC%9F"><span class="toc-text">95. C++ 不同权限继承分别会有怎样的表现？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#96-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E6%A6%82%E5%BF%B5%E5%92%8C%E5%AE%9E%E7%8E%B0%EF%BC%9F%E6%87%92%E6%B1%89%E5%BC%8F-%E9%A5%BF%E6%B1%89%E5%BC%8F%EF%BC%9F%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%EF%BC%9F"><span class="toc-text">96. 单例模式的概念和实现？懒汉式/饿汉式？线程安全？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%87%92%E6%B1%89%E5%BC%8F%EF%BC%88%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%EF%BC%89"><span class="toc-text">懒汉式（线程安全）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A5%BF%E6%B1%89%E5%BC%8F%EF%BC%88%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%EF%BC%89"><span class="toc-text">饿汉式（线程安全）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#97-%E8%99%9A%E5%87%BD%E6%95%B0%E5%AE%9A%E4%B9%89%E4%B8%BA%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E8%83%BD%E9%81%BF%E5%85%8D%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">97. 虚函数定义为析构函数能避免内存泄露的实现原理是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#98-%E4%B8%BA%E4%BB%80%E4%B9%88%E5%93%88%E5%B8%8C%E8%A1%A8%E4%B8%8D%E9%80%82%E5%90%88%E5%81%9A%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84%EF%BC%9F"><span class="toc-text">98. 为什么哈希表不适合做索引结构？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%97%A0%E6%B3%95%E6%94%AF%E6%8C%81%E8%8C%83%E5%9B%B4%E6%9F%A5%E8%AF%A2-Range-Queries"><span class="toc-text">(1) 无法支持范围查询 (Range Queries)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%97%A0%E6%B3%95%E6%94%AF%E6%8C%81%E6%8E%92%E5%BA%8F-ORDER-BY-%E5%92%8C%E5%89%8D%E7%BC%80%E5%8C%B9%E9%85%8D-LIKE-%E2%80%98abc-%E2%80%99"><span class="toc-text">(2) 无法支持排序 (ORDER BY) 和前缀匹配 (LIKE ‘abc%’)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81%E4%B8%8E%E6%80%A7%E8%83%BD%E9%80%80%E5%8C%96"><span class="toc-text">(3) 哈希冲突与性能退化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E7%9A%84%E9%80%89%E6%8B%A9%E8%87%B3%E5%85%B3%E9%87%8D%E8%A6%81%E4%B8%94%E5%9B%B0%E9%9A%BE"><span class="toc-text">(4) 哈希函数的选择至关重要且困难</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E4%B8%8D%E6%94%AF%E6%8C%81%E9%83%A8%E5%88%86%E7%B4%A2%E5%BC%95%EF%BC%88%E6%9C%80%E5%B7%A6%E5%8C%B9%E9%85%8D%E5%8E%9F%E5%88%99%EF%BC%89"><span class="toc-text">(5) 不支持部分索引（最左匹配原则）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E5%86%85%E5%AD%98%E4%BD%BF%E7%94%A8%E6%95%88%E7%8E%87"><span class="toc-text">(6) 内存使用效率</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#99-B-Tree%E3%80%81B-Tree%E3%80%81LSM-Tree"><span class="toc-text">99. B-Tree、B+ Tree、LSM-Tree</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-B-%E6%A0%91"><span class="toc-text">1. B 树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-B-%E6%A0%91"><span class="toc-text">2. B+树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-LSM-%E6%A0%91"><span class="toc-text">3. LSM 树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%E4%B8%8E%E5%AF%B9%E6%AF%94"><span class="toc-text">总结与对比</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#100-placement-new-%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E5%8F%8A%E5%85%B6%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%BA%A6%E6%9D%9F"><span class="toc-text">100. placement new 的使用场景及其内存分配约束</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5%EF%BC%9A%E5%B0%86%E2%80%9C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E2%80%9D%E4%B8%8E%E2%80%9C%E5%AF%B9%E8%B1%A1%E6%9E%84%E9%80%A0%E2%80%9D%E5%88%86%E7%A6%BB"><span class="toc-text">核心概念：将“内存分配”与“对象构造”分离</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E8%A6%81%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">主要使用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%BA%A6%E6%9D%9F%E4%B8%8E%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%EF%BC%88%E6%9E%81%E5%85%B6%E9%87%8D%E8%A6%81%EF%BC%89"><span class="toc-text">内存分配约束与注意事项（极其重要）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-1"><span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#101-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E5%92%8C%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98"><span class="toc-text">101. 智能指针的应用场景和线程安全问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">应用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98"><span class="toc-text">线程安全问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9B%B4%E5%A4%9A%E5%86%85%E5%AE%B9%EF%BC%8C%E8%AF%B7%E5%85%B3%E6%B3%A8%E7%89%9B%E5%AE%A2%E9%9D%A2%E7%BB%8F%EF%BD%9E"><span class="toc-text">更多内容，请关注牛客面经～</span></a></li></ol></div><div class="widget-footer">

<a class="top" onclick="util.scrollTop()"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="1.5"><path d="M2 12c0-4.714 0-7.071 1.464-8.536C4.93 2 7.286 2 12 2c4.714 0 7.071 0 8.535 1.464C22 4.93 22 7.286 22 12c0 4.714 0 7.071-1.465 8.535C19.072 22 16.714 22 12 22s-7.071 0-8.536-1.465C2 19.072 2 16.714 2 12Z"></path><path stroke-linecap="round" stroke-linejoin="round" d="m9 15.5l3-3l3 3m-6-4l3-3l3 3"></path></g></svg><span>Scroll to Top</span></a><a class="buttom" onclick="util.scrollComment()"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" fill-rule="evenodd" d="M10.46 1.25h3.08c1.603 0 2.86 0 3.864.095c1.023.098 1.861.3 2.6.752a5.75 5.75 0 0 1 1.899 1.899c.452.738.654 1.577.752 2.6c.095 1.004.095 2.261.095 3.865v1.067c0 1.141 0 2.036-.05 2.759c-.05.735-.153 1.347-.388 1.913a5.75 5.75 0 0 1-3.112 3.112c-.805.334-1.721.408-2.977.43a10.81 10.81 0 0 0-.929.036c-.198.022-.275.054-.32.08c-.047.028-.112.078-.224.232c-.121.166-.258.396-.476.764l-.542.916c-.773 1.307-2.69 1.307-3.464 0l-.542-.916a10.605 10.605 0 0 0-.476-.764c-.112-.154-.177-.204-.224-.232c-.045-.026-.122-.058-.32-.08c-.212-.023-.49-.03-.93-.037c-1.255-.021-2.171-.095-2.976-.429A5.75 5.75 0 0 1 1.688 16.2c-.235-.566-.338-1.178-.389-1.913c-.049-.723-.049-1.618-.049-2.76v-1.066c0-1.604 0-2.86.095-3.865c.098-1.023.3-1.862.752-2.6a5.75 5.75 0 0 1 1.899-1.899c.738-.452 1.577-.654 2.6-.752C7.6 1.25 8.857 1.25 10.461 1.25M6.739 2.839c-.914.087-1.495.253-1.959.537A4.25 4.25 0 0 0 3.376 4.78c-.284.464-.45 1.045-.537 1.96c-.088.924-.089 2.11-.089 3.761v1c0 1.175 0 2.019.046 2.685c.045.659.131 1.089.278 1.441a4.25 4.25 0 0 0 2.3 2.3c.515.214 1.173.294 2.429.316h.031c.398.007.747.013 1.037.045c.311.035.616.104.909.274c.29.17.5.395.682.645c.169.232.342.525.538.856l.559.944a.52.52 0 0 0 .882 0l.559-.944c.196-.331.37-.624.538-.856c.182-.25.392-.476.682-.645c.293-.17.598-.24.909-.274c.29-.032.639-.038 1.037-.045h.032c1.255-.022 1.913-.102 2.428-.316a4.25 4.25 0 0 0 2.3-2.3c.147-.352.233-.782.278-1.441c.046-.666.046-1.51.046-2.685v-1c0-1.651 0-2.837-.089-3.762c-.087-.914-.253-1.495-.537-1.959a4.25 4.25 0 0 0-1.403-1.403c-.464-.284-1.045-.45-1.96-.537c-.924-.088-2.11-.089-3.761-.089h-3c-1.651 0-2.837 0-3.762.089" clip-rule="evenodd"></path><path fill="currentColor" d="M9 11a1 1 0 1 1-2 0a1 1 0 0 1 2 0m4 0a1 1 0 1 1-2 0a1 1 0 0 1 2 0m4 0a1 1 0 1 1-2 0a1 1 0 0 1 2 0"></path></svg><span>Join Discussion</span></a></div></widget>
</div></aside><div class="float-panel blur">
  <button type="button" style="display:none" class="laptop-only rightbar-toggle mobile" onclick="sidebar.rightbar()">
    <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 6h11m-11 6h11m-11 6h11M4 6h1v4m-1 0h2m0 8H4c0-1 2-2 2-3s-1-1.5-2-1"></path></svg>
  </button>
  <button type="button" style="display:none" class="mobile-only leftbar-toggle mobile" onclick="sidebar.leftbar()">
    <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="1.5"><path d="M2 11c0-3.771 0-5.657 1.172-6.828C4.343 3 6.229 3 10 3h4c3.771 0 5.657 0 6.828 1.172C22 5.343 22 7.229 22 11v2c0 3.771 0 5.657-1.172 6.828C19.657 21 17.771 21 14 21h-4c-3.771 0-5.657 0-6.828-1.172C2 18.657 2 16.771 2 13z"></path><path id="sep" stroke-linecap="round" d="M5.5 10h6m-5 4h4m4.5 7V3"></path></g></svg>
  </button>
</div>
</div><div class="scripts">
<script type="text/javascript">
  const ctx = {
    date_suffix: {
      just: `Just`,
      min: `minutes ago`,
      hour: `hours ago`,
      day: `days ago`,
    },
    root : `/`,
  };

  // required plugins (only load if needs)
  if (`local_search`) {
    ctx.search = {};
    ctx.search.service = `local_search`;
    if (ctx.search.service == 'local_search') {
      let service_obj = Object.assign({}, `{"field":"all","path":"/search.json","content":true,"sort":"-date"}`);
      ctx.search[ctx.search.service] = service_obj;
    }
  }
  const def = {
    avatar: `https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/avatar/round/3442075.svg`,
    cover: `https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/cover/76b86c0226ffd.svg`,
  };
  const deps = {
    jquery: `https://cdn.jsdelivr.net/npm/jquery@3.7.1/dist/jquery.min.js`,
    marked: `https://cdn.jsdelivr.net/npm/marked@13.0.1/lib/marked.umd.min.js`
  }
  

</script>

<script type="text/javascript">
  const utils = {
    // 懒加载 css https://github.com/filamentgroup/loadCSS
    css: (href, before, media, attributes) => {
      var doc = window.document;
      var ss = doc.createElement("link");
      var ref;
      if (before) {
        ref = before;
      } else {
        var refs = (doc.body || doc.getElementsByTagName("head")[0]).childNodes;
        ref = refs[refs.length - 1];
      }
      var sheets = doc.styleSheets;
      if (attributes) {
        for (var attributeName in attributes) {
          if (attributes.hasOwnProperty(attributeName)) {
            ss.setAttribute(attributeName, attributes[attributeName]);
          }
        }
      }
      ss.rel = "stylesheet";
      ss.href = href;
      ss.media = "only x";
      function ready(cb) {
        if (doc.body) {
          return cb();
        }
        setTimeout(function () {
          ready(cb);
        });
      }
      ready(function () {
        ref.parentNode.insertBefore(ss, before ? ref : ref.nextSibling);
      });
      var onloadcssdefined = function (cb) {
        var resolvedHref = ss.href;
        var i = sheets.length;
        while (i--) {
          if (sheets[i].href === resolvedHref) {
            return cb();
          }
        }
        setTimeout(function () {
          onloadcssdefined(cb);
        });
      };
      function loadCB() {
        if (ss.addEventListener) {
          ss.removeEventListener("load", loadCB);
        }
        ss.media = media || "all";
      }
      if (ss.addEventListener) {
        ss.addEventListener("load", loadCB);
      }
      ss.onloadcssdefined = onloadcssdefined;
      onloadcssdefined(loadCB);
      return ss;
    },

    js: (src, opt) => new Promise((resolve, reject) => {
      var script = document.createElement('script');
      if (src.startsWith('/')){
        src = ctx.root + src.substring(1);
      }
      script.src = src;
      if (opt) {
        for (let key of Object.keys(opt)) {
          script[key] = opt[key]
        }
      } else {
        // 默认异步，如果需要同步，第二个参数传入 {} 即可
        script.async = true
      }
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    }),

    jq: (fn) => {
      if (typeof jQuery === 'undefined') {
        utils.js(deps.jquery).then(fn)
      } else {
        fn()
      }
    },
    
    onLoading: (el) => {
      if (el) {
        $(el).append('<div class="loading-wrap"><svg xmlns="http://www.w3.org/2000/svg" width="2em" height="2em" preserveAspectRatio="xMidYMid meet" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-width="2"><path stroke-dasharray="60" stroke-dashoffset="60" stroke-opacity=".3" d="M12 3C16.9706 3 21 7.02944 21 12C21 16.9706 16.9706 21 12 21C7.02944 21 3 16.9706 3 12C3 7.02944 7.02944 3 12 3Z"><animate fill="freeze" attributeName="stroke-dashoffset" dur="1.3s" values="60;0"/></path><path stroke-dasharray="15" stroke-dashoffset="15" d="M12 3C16.9706 3 21 7.02944 21 12"><animate fill="freeze" attributeName="stroke-dashoffset" dur="0.3s" values="15;0"/><animateTransform attributeName="transform" dur="1.5s" repeatCount="indefinite" type="rotate" values="0 12 12;360 12 12"/></path></g></svg></div>');
      }
    },
    onLoadSuccess: (el) => {
      if (el) {
        $(el).find('.loading-wrap').remove();
      }
    },
    onLoadFailure: (el) => {
      if (el) {
        $(el).find('.loading-wrap svg').remove();
        $(el).find('.loading-wrap').append('<svg xmlns="http://www.w3.org/2000/svg" width="2em" height="2em" preserveAspectRatio="xMidYMid meet" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2"><path stroke-dasharray="60" stroke-dashoffset="60" d="M12 3L21 20H3L12 3Z"><animate fill="freeze" attributeName="stroke-dashoffset" dur="0.5s" values="60;0"/></path><path stroke-dasharray="6" stroke-dashoffset="6" d="M12 10V14"><animate fill="freeze" attributeName="stroke-dashoffset" begin="0.6s" dur="0.2s" values="6;0"/></path></g><circle cx="12" cy="17" r="1" fill="currentColor" fill-opacity="0"><animate fill="freeze" attributeName="fill-opacity" begin="0.8s" dur="0.4s" values="0;1"/></circle></svg>');
        $(el).find('.loading-wrap').addClass('error');
      }
    },
    request: (el, url, callback, onFailure) => {
      let retryTimes = 3;
      utils.onLoading(el);
      function req() {
        return new Promise((resolve, reject) => {
          let status = 0; // 0 等待 1 完成 2 超时
          let timer = setTimeout(() => {
            if (status === 0) {
              status = 2;
              timer = null;
              reject('请求超时');
              if (retryTimes == 0) {
                onFailure();
              }
            }
          }, 5000);
          fetch(url).then(function(response) {
            if (status !== 2) {
              clearTimeout(timer);
              resolve(response);
              timer = null;
              status = 1;
            }
            if (response.ok) {
              return response.json();
            }
            throw new Error('Network response was not ok.');
          }).then(function(data) {
            retryTimes = 0;
            utils.onLoadSuccess(el);
            callback(data);
          }).catch(function(error) {
            if (retryTimes > 0) {
              retryTimes -= 1;
              setTimeout(() => {
                req();
              }, 5000);
            } else {
              utils.onLoadFailure(el);
              onFailure();
            }
          });
        });
      }
      req();
    },
  };
</script>

<script>
  const sidebar = {
    leftbar: () => {
      if (l_body) {
        l_body.toggleAttribute('leftbar');
        l_body.removeAttribute('rightbar');
      }
    },
    rightbar: () => {
      if (l_body) {
        l_body.toggleAttribute('rightbar');
        l_body.removeAttribute('leftbar');
      }
    },
    dismiss: () => {
      if (l_body) {
        l_body.removeAttribute('leftbar');
        l_body.removeAttribute('rightbar');
      }
    },
    toggleTOC: () => {
      document.querySelector('#data-toc').classList.toggle('collapse');
    }
  }
</script>
<script type="text/javascript">
  (() => {
    const tagSwitchers = document.querySelectorAll('.tag-subtree.parent-tag > a > .tag-switcher-wrapper')
    for (const tagSwitcher of tagSwitchers) {
      tagSwitcher.addEventListener('click', (e) => {
        const parent = e.target.closest('.tag-subtree.parent-tag')
        parent.classList.toggle('expanded')
        e.preventDefault()
      })
    }

    // Get active tag from query string, then activate it.
    const urlParams = new URLSearchParams(window.location.search)
    const activeTag = urlParams.get('tag')
    if (activeTag) {
      let tag = document.querySelector(`.tag-subtree[data-tag="${activeTag}"]`)
      if (tag) {
        tag.querySelector('a').classList.add('active')
        
        while (tag) {
          tag.classList.add('expanded')
          tag = tag.parentElement.closest('.tag-subtree.parent-tag')
        }
      }
    }
  })()
</script>


<!-- required -->
<script src="/js/main.js?v=1.29.1" defer=""></script>

<script type="text/javascript">
  const applyTheme = (theme) => {
    if (theme === 'auto') {
      document.documentElement.removeAttribute('data-theme')
    } else {
      document.documentElement.setAttribute('data-theme', theme)
    }

    applyThemeToGiscus(theme)
  }

  const applyThemeToGiscus = (theme) => {
    theme = theme === 'auto' ? 'preferred_color_scheme' : theme

    const cmt = document.getElementById('giscus')
    if (cmt) {
      // This works before giscus load.
      cmt.setAttribute('data-theme', theme)
    }

    const iframe = document.querySelector('#comments > section.giscus > iframe')
    if (iframe) {
      // This works after giscus loaded.
      const src = iframe.src
      const newSrc = src.replace(/theme=[\w]+/, `theme=${theme}`)
      iframe.src = newSrc
    }
  }

  const switchTheme = () => {
    // light -> dark -> auto -> light -> ...
    const currentTheme = document.documentElement.getAttribute('data-theme')
    let newTheme;
    switch (currentTheme) {
      case 'light':
        newTheme = 'dark'
        break
      case 'dark':
        newTheme = 'auto'
        break
      default:
        newTheme = 'light'
    }
    applyTheme(newTheme)
    window.localStorage.setItem('Stellar.theme', newTheme)

    const messages = {
      light: `Switched to Light Mode`,
      dark: `Switched to Dark Mode`,
      auto: `Switched to Auto Mode`,
    }
    hud?.toast?.(messages[newTheme])
  }

  (() => {
    // Apply user's preferred theme, if any.
    const theme = window.localStorage.getItem('Stellar.theme')
    if (theme !== null) {
      applyTheme(theme)
    }
  })()
</script>


<!-- optional -->

  <script type="module">
  const el = document.querySelector('#comments #giscus');
  util.viewportLazyload(el, load_discus, false);

  function load_discus() {
    if (!el) return;
    try {
        el.innerHTML = '';
      } catch (error) {
        console.error(error);
      }
      const script = document.createElement('script');
      script.async = true;
      for (const key of Object.keys(el.attributes)) {
        const attr = el.attributes[key];
        if (['class', 'id'].includes(attr.name) === false) {
          script.setAttribute(attr.name, attr.value);
        }
      }
      el.appendChild(script);
  }
</script>




<script defer="">
  window.addEventListener('DOMContentLoaded', (event) => {
    ctx.services = Object.assign({}, JSON.parse(`{"mdrender":{"js":"/js/services/mdrender.js"},"siteinfo":{"js":"/js/services/siteinfo.js","api":null},"ghinfo":{"js":"/js/services/ghinfo.js"},"sites":{"js":"/js/services/sites.js"},"friends":{"js":"/js/services/friends.js"},"timeline":{"js":"/js/services/timeline.js"},"fcircle":{"js":"/js/services/fcircle.js"},"weibo":{"js":"/js/services/weibo.js"},"memos":{"js":"/js/services/memos.js"},"giscus":{"js":"/js/services/giscus_new.js"}}`));
    for (let id of Object.keys(ctx.services)) {
      const js = ctx.services[id].js;
      if (id == 'siteinfo') {
        ctx.cardlinks = document.querySelectorAll('a.link-card[cardlink]');
        if (ctx.cardlinks?.length > 0) {
          utils.js(js, { defer: true }).then(function () {
            setCardLink(ctx.cardlinks);
          });
        }
      } else {
        const els = document.getElementsByClassName(`ds-${id}`);
        if (els?.length > 0) {
          utils.jq(() => {
            if (id == 'timeline' || 'memos' || 'marked') {
              utils.js(deps.marked).then(function () {
                utils.js(js, { defer: true });
              });
            } else {
              utils.js(js, { defer: true });
            }
          });
        }
      }
    }
  });
</script>

<script>
  window.addEventListener('DOMContentLoaded', (event) => {
    ctx.search = {
      path: `/search.json`,
    }
    utils.js('/js/search/local-search.js', { defer: true });
  });
</script><script>
  window.FPConfig = {
    delay: 0,
    ignoreKeywords: [],
    maxRPS: 5,
    hoverDelay: 25
  };
</script>
<script defer="" src="https://cdn.jsdelivr.net/npm/flying-pages@2/flying-pages.min.js"></script><script defer="" src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@19.1.3/dist/lazyload.min.js"></script>
<script>
  // https://www.npmjs.com/package/vanilla-lazyload
  // Set the options globally
  // to make LazyLoad self-initialize
  window.lazyLoadOptions = {
    elements_selector: ".lazy",
  };
  // Listen to the initialization event
  // and get the instance of LazyLoad
  window.addEventListener(
    "LazyLoad::Initialized",
    function (event) {
      window.lazyLoadInstance = event.detail.instance;
    },
    false
  );
  document.addEventListener('DOMContentLoaded', function () {
    window.lazyLoadInstance?.update();
  });
</script><script>
  ctx.fancybox = {
    selector: `.timenode p>img`,
    css: `https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0/dist/fancybox/fancybox.css`,
    js: `https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0/dist/fancybox/fancybox.umd.js`
  };
  var selector = '[data-fancybox]:not(.error)';
  if (ctx.fancybox.selector) {
    selector += `, ${ctx.fancybox.selector}`
  }
  var needFancybox = document.querySelectorAll(selector).length !== 0;
  if (!needFancybox) {
    const els = document.getElementsByClassName('ds-memos');
    if (els != undefined && els.length > 0) {
      needFancybox = true;
    }
  }
  if (needFancybox) {
    utils.css(ctx.fancybox.css);
    utils.js(ctx.fancybox.js, { defer: true }).then(function () {
      Fancybox.bind(selector, {
        hideScrollbar: false,
        Thumbs: {
          autoStart: false,
        },
        caption: (fancybox, slide) => {
          return slide.triggerEl.alt || slide.triggerEl.dataset.caption || null
        }
      });
    })
  }
</script>
<script>
  window.addEventListener('DOMContentLoaded', (event) => {
    const swiper_api = document.getElementById('swiper-api');
    if (swiper_api != undefined) {
      utils.css(`https://unpkg.com/swiper@10.3.1/swiper-bundle.min.css`);
      utils.js(`https://unpkg.com/swiper@10.3.1/swiper-bundle.min.js`, { defer: true }).then(function () {
        const effect = swiper_api.getAttribute('effect') || '';
        var swiper = new Swiper('.swiper#swiper-api', {
          slidesPerView: 'auto',
          spaceBetween: 8,
          centeredSlides: true,
          effect: effect,
          rewind: true,
          pagination: {
            el: '.swiper-pagination',
            clickable: true,
          },
          navigation: {
            nextEl: '.swiper-button-next',
            prevEl: '.swiper-button-prev',
          },
        });
      })
    }
  });
</script>
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.6/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"] ],
    processEscapes: true
  }
});
MathJax.Hub.Config({
  tex2jax: {
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  }
});
MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for(i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script>
<script>
  document.addEventListener('DOMContentLoaded', function () {
    window.codeElements = document.querySelectorAll('.code');
    if (window.codeElements.length > 0) {
      ctx.copycode = {
        default_text: `Copy`,
        success_text: `Copied`,
        toast: `复制成功`,
      };
      utils.js('/js/plugins/copycode.js');
    }
  });
</script>


<!-- inject -->
</div>
</body></html><script>var posts=["post/Golang/golang-wiki/","post/C++/cpp-copy-constructor/","post/C++/effective-c++/","post/C++/from-posix-pthread-to-c++11-thread/","post/C++/when-nanoseconds-matter-ultrafas-trading-systems-in-C++/","post/C++/network-programming-and-io-multiplexing/","post/C++/cpp-wiki/","post/C++/from-double-free-to-shared_ptr/","post/小吳日寄/2025-06-11/","post/博客开发/hexo-stellar-deployment-guide/","post/C++/cpp-stl/","post/博客开发/building-a-personal-blog-from-scratch/","post/小吳日寄/2025-06-14/","post/Python/python-wiki/","post/小吳日寄/2025-06-18/","post/小吳日寄/2025-04-09/","post/小吳日寄/2025-06-28/","post/小吳日寄/2025-06-17/","post/小吳日寄/2025-07-08/","post/AI-Infra/ai-infra-vs-traditional-infra/","post/AI-Infra/animated-pictures-to-easily-understand-self-attention/","post/AI-Infra/how-does-chatgpt-handle-text-input/","post/AI-Infra/ai-infra-in-the-era-of-llm/","post/AI-Infra/recommendation-system-architecture/","post/AI-Infra/the-soul-of-chatgpt-attention-mechanism/","post/摄影日志/chengdu_2024-07-14/","post/摄影日志/camera-and-photography/","post/摄影日志/fjnu_2023-06-14/","post/摄影日志/fuzhou_2024-10-01/","post/摄影日志/guangzhou_2024-11-29/","post/摄影日志/hangzhou_2023-04-28/","post/摄影日志/fuzhou_2025-06-14/","post/摄影日志/hangzhou_2024-06-15/","post/摄影日志/dongshandao_2024-10-30/","post/摄影日志/shenzhen_2023-10-27/","post/摄影日志/quanzhou_2024-01-28/","post/摄影日志/xi'an_2024-06-24/","post/摄影日志/xiamen_2023-12-24/","post/摄影日志/wuhan_2023-04-04/","post/摄影日志/shot/","post/摄影日志/yinchuan_2024-07-27/","post/摄影日志/zhangzhou_2024-05-01/","post/数据结构与算法/binary-tree-matching/","post/数据结构与算法/constructing-binary-tree/","post/数据结构与算法/advanced-algorithms/","post/数据结构与算法/difference-array/","post/数据结构与算法/interview-add-two/","post/数据结构与算法/interview-linked-list/","post/数据结构与算法/kuaishou-merge-k-ascending-linked-lists/","post/数据结构与算法/maximum-product-of-subarray-or-subsequence/","post/数据结构与算法/modulo/","post/数据结构与算法/monotonic-stack/","post/数据结构与算法/priority_queue/","post/数据结构与算法/qpow/","post/数据结构与算法/sieve-of-prime-number/","post/数据结构与算法/sort-algorithm/","post/数据结构与算法/tackle-without-sort-library/","post/数据结构与算法/tecent-wxg-russian-doll-envelope/","post/数据结构与算法/union-search/","post/秋招指南/2025-autumn-recruitment/","post/秋招指南/2025-brainteaser/","post/秋招指南/2025-interview-hand-tear/","post/秋招指南/2025-network/","post/秋招指南/2025-scenario-questions/","post/秋招指南/20250405-meituan/","post/秋招指南/20250412-eleme/","post/秋招指南/20250424-gbits/","post/秋招指南/20250521-huawei/","post/秋招指南/20250809-netease/","post/秋招指南/20250830-jd/","post/秋招指南/26-top-talent/","post/秋招指南/cpp-acm-input-output/","post/秋招指南/2025-cpp/","post/秋招指南/internet-companies-or-state-owned-enterprises/","post/秋招指南/reverse-interview/","post/秋招指南/2025-os/","post/秋招指南/salary-negotiation/","post/科研/fast-24-term/","post/科研/fast-20-empirical-guide-of-pm/","post/科研/fast-25-gogetafs/","post/科研/osdi-23-chardonnay/","post/科研/osdi-23-smart/","post/科研/eurosys-24-volley/","post/科研/osdi-24-atlas/","post/系统与体系结构/a-study-of-linux-file-system-evolution/","post/秋招指南/job-hunting-guide-for-technical-personnel/","post/系统与体系结构/debugging-with-gdb/","post/系统与体系结构/distributed-systems-paxos.md/","post/系统与体系结构/distributed-systems-theoretical-foundations/","post/系统与体系结构/analysis-of-trace-processing/","post/系统与体系结构/distributed-systems-raft/","post/系统与体系结构/duckdb's-adaptive-radix-tree-source-code/","post/系统与体系结构/how-to-ensure-crash-consistency-in-distributed-systems/","post/系统与体系结构/linux-disk-automatic-mounting/","post/系统与体系结构/linux-kernel-io-path/","post/系统与体系结构/madam-for-all-flash-array/","post/系统与体系结构/linux-partition/","post/系统与体系结构/mmap-vs-read-write/","post/系统与体系结构/nvm-top-lab/","post/系统与体系结构/persistent-memory-research-report/","post/系统与体系结构/pmdk-programming-guidelines/","post/藏书阁/siddhartha/","post/未来世界的幸存者/choose-one-sentence/","post/未来世界的幸存者/don't-limit-your-future-imagination-with-your-current-abilities/","post/未来世界的幸存者/how-can-undergraduates-enter-bat/","post/未来世界的幸存者/technical-writing-experience/","post/未来世界的幸存者/the-future-world/","post/开发工具/docker-and-k8s/","post/开发工具/docker-intro/","post/开发工具/git-undo/","post/开发工具/git-workflow/","post/开发工具/markdown-mathjax-basic-tutorial-and-quick-reference/","post/开发工具/nat/","post/开发工具/tips-for-precise-search-on-github/","post/开发工具/understanding-.git-folder/","post/计算机网络/does-restarting-mean-shutting-down-and-power-on/","post/计算机网络/reverse-proxy/","post/计算机网络/network-ip/"];function toRandomPost(){ var randomPath = posts[Math.floor(Math.random()*posts.length)]; var encodedPath = encodeURIComponent(randomPath); window.open('/' + encodedPath, "_self"); };</script>