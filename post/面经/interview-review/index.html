<!DOCTYPE html><html lang="zh-CN"><head>
  <meta charset="utf-8">
  <meta name="hexo-theme" content="https://github.com/Wu-yikun/wu-yikun.github.io//tree/1.29.1" theme-name="Stellar" theme-version="1.29.1">
  
  <meta name="generator" content="Hexo 7.3.0">
  <meta http-equiv="x-dns-prefetch-control" content="on">
  
  <meta name="renderer" content="webkit">
  <meta name="force-rendering" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  <meta name="HandheldFriendly" content="True">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="theme-color" media="(prefers-color-scheme: dark)" content="#000">
  <meta name="theme-color" content="#f9fafb">
  
  <title>暑期实习面经 - Yikun Wu</title>

  
    <meta name="description" content="陆续一个月了，腾讯、阿里云、淘天、高德、拼多多、字节、美团… 能投的都投了。 建议：多刷面经，可以快速积累场景题、设计题、多线程题，而且能快速 get 到高频八股，比如 oom、cpu 使用率高、慢查询治理… 找暑期哪有不疯的，运气也是非常重要。 最后祝各位早日 oc（也祝我能 oc），无需过度焦虑，才四月初，正是发力期，过段时间一堆鸽穿的。">
<meta property="og:type" content="article">
<meta property="og:title" content="暑期实习面经">
<meta property="og:url" content="https://wu-yikun.github.io/post/%E9%9D%A2%E7%BB%8F/interview-review/index.html">
<meta property="og:site_name" content="Yikun Wu">
<meta property="og:description" content="陆续一个月了，腾讯、阿里云、淘天、高德、拼多多、字节、美团… 能投的都投了。 建议：多刷面经，可以快速积累场景题、设计题、多线程题，而且能快速 get 到高频八股，比如 oom、cpu 使用率高、慢查询治理… 找暑期哪有不疯的，运气也是非常重要。 最后祝各位早日 oc（也祝我能 oc），无需过度焦虑，才四月初，正是发力期，过段时间一堆鸽穿的。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Wu-yikun/OSS/PicGo/202503042258443.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Wu-yikun/OSS/PicGo/202503050028968.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Wu-yikun/OSS/PicGo/202503042259465.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Wu-yikun/OSS/PicGo/202503070248915.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Wu-yikun/OSS/PicGo/202503071625344.jpeg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Wu-yikun/OSS/PicGo/202503071630713.jpeg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Wu-yikun/OSS/PicGo/202503282159068.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Wu-yikun/OSS/PicGo/202503290041746.png">
<meta property="article:published_time" content="2025-04-12T16:00:00.000Z">
<meta property="article:modified_time" content="2025-06-10T08:34:27.020Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="C++">
<meta property="article:tag" content="面经">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/Wu-yikun/OSS/PicGo/202503042258443.jpg">
  
  
  
  <meta name="keywords" content="C++,面经">

  <!-- feed -->
  

  <link rel="stylesheet" href="/css/main.css?v=1.29.1">

  
    <link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/Wu-yikun/OSS/PicGo/202505140357298.svg">
  

  

  
</head>
<body>

<div class="l_body s:aa content tech" id="start" layout="post"><aside class="l_left"><div class="leftbar-container">


<header class="header"><div class="logo-wrap"><a class="avatar" href="/"><div class="bg" style="opacity:0;background-image:url(https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/avatar/round/rainbow64@3x.webp);"></div><img no-lazy="" class="avatar lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/Wu-yikun/OSS/PicGo/202412091622716.jpg"></a><a class="title" href="/about/"><div class="main" ff="title">Yikun Wu</div><div class="sub normal cap">无限进步</div><div class="sub hover cap" style="opacity:0"> 無限進步</div></a></div></header>

<div class="nav-area">
<div class="search-wrapper" id="search-wrapper"><form class="search-form"><a class="search-button" onclick="document.getElementById(&quot;search-input&quot;).focus();"><svg t="1705074644177" viewBox="0 0 1025 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1560" width="200" height="200"><path d="M1008.839137 935.96571L792.364903 719.491476a56.783488 56.783488 0 0 0-80.152866 0 358.53545 358.53545 0 1 1 100.857314-335.166073 362.840335 362.840335 0 0 1-3.689902 170.145468 51.248635 51.248635 0 1 0 99.217358 26.444296 462.057693 462.057693 0 1 0-158.255785 242.303546l185.930047 185.725053a51.248635 51.248635 0 0 0 72.568068 0 51.248635 51.248635 0 0 0 0-72.978056z" p-id="1561"></path><path d="M616.479587 615.969233a50.428657 50.428657 0 0 0-61.498362-5.534852 174.655348 174.655348 0 0 1-177.525271 3.484907 49.403684 49.403684 0 0 0-58.833433 6.76482l-3.074918 2.869923a49.403684 49.403684 0 0 0 8.609771 78.10292 277.767601 277.767601 0 0 0 286.992355-5.739847 49.403684 49.403684 0 0 0 8.404776-76.667958z" p-id="1562"></path></svg></a><input type="text" class="search-input" id="search-input" placeholder="站内搜索"></form><div id="search-result"></div><div class="search-no-result">没有找到内容！</div></div>


<nav class="menu dis-select"></nav>
</div>
<div class="widgets">
    <widget class="widget-wrapper categories-widget"><div class="widget-header categories-header dis-select"><span class="name">分类索引</span></div><div class="widget-body"><div class="category "><svg class="category-icon" xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round">
                <path d="M18 10h-5" opacity=".5"></path>
                <path d="M10 3h6.5c.464 0 .697 0 .892.026a3 3 0 0 1 2.582 2.582c.026.195.026.428.026.892" opacity=".5"></path>
                <path d="M2 6.95c0-.883 0-1.324.07-1.692A4 4 0 0 1 5.257 2.07C5.626 2 6.068 2 6.95 2c.386 0 .58 0 .766.017a4 4 0 0 1 2.18.904c.144.119.28.255.554.529L11 4c.816.816 1.224 1.224 1.712 1.495a4 4 0 0 0 .848.352C14.098 6 14.675 6 15.828 6h.374c2.632 0 3.949 0 4.804.77c.079.07.154.145.224.224c.77.855.77 2.172.77 4.804V14c0 3.771 0 5.657-1.172 6.828C19.657 22 17.771 22 14 22h-4c-3.771 0-5.657 0-6.828-1.172C2 19.657 2 17.771 2 14z"></path>
            </svg><a href="/categories/AI-Infra/">AI Infra (4)</a></div><div class="category "><svg class="category-icon" xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round">
                <path d="M18 10h-5" opacity=".5"></path>
                <path d="M10 3h6.5c.464 0 .697 0 .892.026a3 3 0 0 1 2.582 2.582c.026.195.026.428.026.892" opacity=".5"></path>
                <path d="M2 6.95c0-.883 0-1.324.07-1.692A4 4 0 0 1 5.257 2.07C5.626 2 6.068 2 6.95 2c.386 0 .58 0 .766.017a4 4 0 0 1 2.18.904c.144.119.28.255.554.529L11 4c.816.816 1.224 1.224 1.712 1.495a4 4 0 0 0 .848.352C14.098 6 14.675 6 15.828 6h.374c2.632 0 3.949 0 4.804.77c.079.07.154.145.224.224c.77.855.77 2.172.77 4.804V14c0 3.771 0 5.657-1.172 6.828C19.657 22 17.771 22 14 22h-4c-3.771 0-5.657 0-6.828-1.172C2 19.657 2 17.771 2 14z"></path>
            </svg><a href="/categories/Golang/">Golang (1)</a></div><div class="category "><svg class="category-icon" xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round">
                <path d="M18 10h-5" opacity=".5"></path>
                <path d="M10 3h6.5c.464 0 .697 0 .892.026a3 3 0 0 1 2.582 2.582c.026.195.026.428.026.892" opacity=".5"></path>
                <path d="M2 6.95c0-.883 0-1.324.07-1.692A4 4 0 0 1 5.257 2.07C5.626 2 6.068 2 6.95 2c.386 0 .58 0 .766.017a4 4 0 0 1 2.18.904c.144.119.28.255.554.529L11 4c.816.816 1.224 1.224 1.712 1.495a4 4 0 0 0 .848.352C14.098 6 14.675 6 15.828 6h.374c2.632 0 3.949 0 4.804.77c.079.07.154.145.224.224c.77.855.77 2.172.77 4.804V14c0 3.771 0 5.657-1.172 6.828C19.657 22 17.771 22 14 22h-4c-3.771 0-5.657 0-6.828-1.172C2 19.657 2 17.771 2 14z"></path>
            </svg><a href="/categories/Python/">Python (1)</a></div><div class="category "><svg class="category-icon" xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round">
                <path d="M18 10h-5" opacity=".5"></path>
                <path d="M10 3h6.5c.464 0 .697 0 .892.026a3 3 0 0 1 2.582 2.582c.026.195.026.428.026.892" opacity=".5"></path>
                <path d="M2 6.95c0-.883 0-1.324.07-1.692A4 4 0 0 1 5.257 2.07C5.626 2 6.068 2 6.95 2c.386 0 .58 0 .766.017a4 4 0 0 1 2.18.904c.144.119.28.255.554.529L11 4c.816.816 1.224 1.224 1.712 1.495a4 4 0 0 0 .848.352C14.098 6 14.675 6 15.828 6h.374c2.632 0 3.949 0 4.804.77c.079.07.154.145.224.224c.77.855.77 2.172.77 4.804V14c0 3.771 0 5.657-1.172 6.828C19.657 22 17.771 22 14 22h-4c-3.771 0-5.657 0-6.828-1.172C2 19.657 2 17.771 2 14z"></path>
            </svg><a href="/categories/%E5%8D%9A%E5%AE%A2%E5%BC%80%E5%8F%91/">博客开发 (2)</a></div><div class="category "><svg class="category-icon" xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round">
                <path d="M18 10h-5" opacity=".5"></path>
                <path d="M10 3h6.5c.464 0 .697 0 .892.026a3 3 0 0 1 2.582 2.582c.026.195.026.428.026.892" opacity=".5"></path>
                <path d="M2 6.95c0-.883 0-1.324.07-1.692A4 4 0 0 1 5.257 2.07C5.626 2 6.068 2 6.95 2c.386 0 .58 0 .766.017a4 4 0 0 1 2.18.904c.144.119.28.255.554.529L11 4c.816.816 1.224 1.224 1.712 1.495a4 4 0 0 0 .848.352C14.098 6 14.675 6 15.828 6h.374c2.632 0 3.949 0 4.804.77c.079.07.154.145.224.224c.77.855.77 2.172.77 4.804V14c0 3.771 0 5.657-1.172 6.828C19.657 22 17.771 22 14 22h-4c-3.771 0-5.657 0-6.828-1.172C2 19.657 2 17.771 2 14z"></path>
            </svg><a href="/categories/C/">C++ (6)</a></div><div class="category "><svg class="category-icon" xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round">
                <path d="M18 10h-5" opacity=".5"></path>
                <path d="M10 3h6.5c.464 0 .697 0 .892.026a3 3 0 0 1 2.582 2.582c.026.195.026.428.026.892" opacity=".5"></path>
                <path d="M2 6.95c0-.883 0-1.324.07-1.692A4 4 0 0 1 5.257 2.07C5.626 2 6.068 2 6.95 2c.386 0 .58 0 .766.017a4 4 0 0 1 2.18.904c.144.119.28.255.554.529L11 4c.816.816 1.224 1.224 1.712 1.495a4 4 0 0 0 .848.352C14.098 6 14.675 6 15.828 6h.374c2.632 0 3.949 0 4.804.77c.079.07.154.145.224.224c.77.855.77 2.172.77 4.804V14c0 3.771 0 5.657-1.172 6.828C19.657 22 17.771 22 14 22h-4c-3.771 0-5.657 0-6.828-1.172C2 19.657 2 17.771 2 14z"></path>
            </svg><a href="/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/">开发工具 (8)</a></div><div class="category "><svg class="category-icon" xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round">
                <path d="M18 10h-5" opacity=".5"></path>
                <path d="M10 3h6.5c.464 0 .697 0 .892.026a3 3 0 0 1 2.582 2.582c.026.195.026.428.026.892" opacity=".5"></path>
                <path d="M2 6.95c0-.883 0-1.324.07-1.692A4 4 0 0 1 5.257 2.07C5.626 2 6.068 2 6.95 2c.386 0 .58 0 .766.017a4 4 0 0 1 2.18.904c.144.119.28.255.554.529L11 4c.816.816 1.224 1.224 1.712 1.495a4 4 0 0 0 .848.352C14.098 6 14.675 6 15.828 6h.374c2.632 0 3.949 0 4.804.77c.079.07.154.145.224.224c.77.855.77 2.172.77 4.804V14c0 3.771 0 5.657-1.172 6.828C19.657 22 17.771 22 14 22h-4c-3.771 0-5.657 0-6.828-1.172C2 19.657 2 17.771 2 14z"></path>
            </svg><a href="/categories/%E5%B0%8F%E5%90%B3%E6%97%A5%E5%AF%84/">小吳日寄 (1)</a></div><div class="category "><svg class="category-icon" xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round">
                <path d="M18 10h-5" opacity=".5"></path>
                <path d="M10 3h6.5c.464 0 .697 0 .892.026a3 3 0 0 1 2.582 2.582c.026.195.026.428.026.892" opacity=".5"></path>
                <path d="M2 6.95c0-.883 0-1.324.07-1.692A4 4 0 0 1 5.257 2.07C5.626 2 6.068 2 6.95 2c.386 0 .58 0 .766.017a4 4 0 0 1 2.18.904c.144.119.28.255.554.529L11 4c.816.816 1.224 1.224 1.712 1.495a4 4 0 0 0 .848.352C14.098 6 14.675 6 15.828 6h.374c2.632 0 3.949 0 4.804.77c.079.07.154.145.224.224c.77.855.77 2.172.77 4.804V14c0 3.771 0 5.657-1.172 6.828C19.657 22 17.771 22 14 22h-4c-3.771 0-5.657 0-6.828-1.172C2 19.657 2 17.771 2 14z"></path>
            </svg><a href="/categories/%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/">年终总结 (4)</a></div><div class="category "><svg class="category-icon" xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round">
                <path d="M18 10h-5" opacity=".5"></path>
                <path d="M10 3h6.5c.464 0 .697 0 .892.026a3 3 0 0 1 2.582 2.582c.026.195.026.428.026.892" opacity=".5"></path>
                <path d="M2 6.95c0-.883 0-1.324.07-1.692A4 4 0 0 1 5.257 2.07C5.626 2 6.068 2 6.95 2c.386 0 .58 0 .766.017a4 4 0 0 1 2.18.904c.144.119.28.255.554.529L11 4c.816.816 1.224 1.224 1.712 1.495a4 4 0 0 0 .848.352C14.098 6 14.675 6 15.828 6h.374c2.632 0 3.949 0 4.804.77c.079.07.154.145.224.224c.77.855.77 2.172.77 4.804V14c0 3.771 0 5.657-1.172 6.828C19.657 22 17.771 22 14 22h-4c-3.771 0-5.657 0-6.828-1.172C2 19.657 2 17.771 2 14z"></path>
            </svg><a href="/categories/%E6%91%84%E5%BD%B1%E6%97%A5%E5%BF%97/">摄影日志 (3)</a></div><div class="category "><svg class="category-icon" xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round">
                <path d="M18 10h-5" opacity=".5"></path>
                <path d="M10 3h6.5c.464 0 .697 0 .892.026a3 3 0 0 1 2.582 2.582c.026.195.026.428.026.892" opacity=".5"></path>
                <path d="M2 6.95c0-.883 0-1.324.07-1.692A4 4 0 0 1 5.257 2.07C5.626 2 6.068 2 6.95 2c.386 0 .58 0 .766.017a4 4 0 0 1 2.18.904c.144.119.28.255.554.529L11 4c.816.816 1.224 1.224 1.712 1.495a4 4 0 0 0 .848.352C14.098 6 14.675 6 15.828 6h.374c2.632 0 3.949 0 4.804.77c.079.07.154.145.224.224c.77.855.77 2.172.77 4.804V14c0 3.771 0 5.657-1.172 6.828C19.657 22 17.771 22 14 22h-4c-3.771 0-5.657 0-6.828-1.172C2 19.657 2 17.771 2 14z"></path>
            </svg><a href="/categories/%E6%9C%AA%E6%9D%A5%E4%B8%96%E7%95%8C%E7%9A%84%E5%B9%B8%E5%AD%98%E8%80%85/">未来世界的幸存者 (6)</a></div><div class="category "><svg class="category-icon" xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round">
                <path d="M18 10h-5" opacity=".5"></path>
                <path d="M10 3h6.5c.464 0 .697 0 .892.026a3 3 0 0 1 2.582 2.582c.026.195.026.428.026.892" opacity=".5"></path>
                <path d="M2 6.95c0-.883 0-1.324.07-1.692A4 4 0 0 1 5.257 2.07C5.626 2 6.068 2 6.95 2c.386 0 .58 0 .766.017a4 4 0 0 1 2.18.904c.144.119.28.255.554.529L11 4c.816.816 1.224 1.224 1.712 1.495a4 4 0 0 0 .848.352C14.098 6 14.675 6 15.828 6h.374c2.632 0 3.949 0 4.804.77c.079.07.154.145.224.224c.77.855.77 2.172.77 4.804V14c0 3.771 0 5.657-1.172 6.828C19.657 22 17.771 22 14 22h-4c-3.771 0-5.657 0-6.828-1.172C2 19.657 2 17.771 2 14z"></path>
            </svg><a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法 (17)</a></div><div class="category "><svg class="category-icon" xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round">
                <path d="M18 10h-5" opacity=".5"></path>
                <path d="M10 3h6.5c.464 0 .697 0 .892.026a3 3 0 0 1 2.582 2.582c.026.195.026.428.026.892" opacity=".5"></path>
                <path d="M2 6.95c0-.883 0-1.324.07-1.692A4 4 0 0 1 5.257 2.07C5.626 2 6.068 2 6.95 2c.386 0 .58 0 .766.017a4 4 0 0 1 2.18.904c.144.119.28.255.554.529L11 4c.816.816 1.224 1.224 1.712 1.495a4 4 0 0 0 .848.352C14.098 6 14.675 6 15.828 6h.374c2.632 0 3.949 0 4.804.77c.079.07.154.145.224.224c.77.855.77 2.172.77 4.804V14c0 3.771 0 5.657-1.172 6.828C19.657 22 17.771 22 14 22h-4c-3.771 0-5.657 0-6.828-1.172C2 19.657 2 17.771 2 14z"></path>
            </svg><a href="/categories/%E8%97%8F%E4%B9%A6%E9%98%81/">藏书阁 (1)</a></div><div class="category "><svg class="category-icon" xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round">
                <path d="M18 10h-5" opacity=".5"></path>
                <path d="M10 3h6.5c.464 0 .697 0 .892.026a3 3 0 0 1 2.582 2.582c.026.195.026.428.026.892" opacity=".5"></path>
                <path d="M2 6.95c0-.883 0-1.324.07-1.692A4 4 0 0 1 5.257 2.07C5.626 2 6.068 2 6.95 2c.386 0 .58 0 .766.017a4 4 0 0 1 2.18.904c.144.119.28.255.554.529L11 4c.816.816 1.224 1.224 1.712 1.495a4 4 0 0 0 .848.352C14.098 6 14.675 6 15.828 6h.374c2.632 0 3.949 0 4.804.77c.079.07.154.145.224.224c.77.855.77 2.172.77 4.804V14c0 3.771 0 5.657-1.172 6.828C19.657 22 17.771 22 14 22h-4c-3.771 0-5.657 0-6.828-1.172C2 19.657 2 17.771 2 14z"></path>
            </svg><a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络 (3)</a></div><div class="category "><svg class="category-icon" xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round">
                <path d="M18 10h-5" opacity=".5"></path>
                <path d="M10 3h6.5c.464 0 .697 0 .892.026a3 3 0 0 1 2.582 2.582c.026.195.026.428.026.892" opacity=".5"></path>
                <path d="M2 6.95c0-.883 0-1.324.07-1.692A4 4 0 0 1 5.257 2.07C5.626 2 6.068 2 6.95 2c.386 0 .58 0 .766.017a4 4 0 0 1 2.18.904c.144.119.28.255.554.529L11 4c.816.816 1.224 1.224 1.712 1.495a4 4 0 0 0 .848.352C14.098 6 14.675 6 15.828 6h.374c2.632 0 3.949 0 4.804.77c.079.07.154.145.224.224c.77.855.77 2.172.77 4.804V14c0 3.771 0 5.657-1.172 6.828C19.657 22 17.771 22 14 22h-4c-3.771 0-5.657 0-6.828-1.172C2 19.657 2 17.771 2 14z"></path>
            </svg><a href="/categories/%E9%9D%A2%E7%BB%8F/">面经 (4)</a></div><div class="category "><svg class="category-icon" xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round">
                <path d="M18 10h-5" opacity=".5"></path>
                <path d="M10 3h6.5c.464 0 .697 0 .892.026a3 3 0 0 1 2.582 2.582c.026.195.026.428.026.892" opacity=".5"></path>
                <path d="M2 6.95c0-.883 0-1.324.07-1.692A4 4 0 0 1 5.257 2.07C5.626 2 6.068 2 6.95 2c.386 0 .58 0 .766.017a4 4 0 0 1 2.18.904c.144.119.28.255.554.529L11 4c.816.816 1.224 1.224 1.712 1.495a4 4 0 0 0 .848.352C14.098 6 14.675 6 15.828 6h.374c2.632 0 3.949 0 4.804.77c.079.07.154.145.224.224c.77.855.77 2.172.77 4.804V14c0 3.771 0 5.657-1.172 6.828C19.657 22 17.771 22 14 22h-4c-3.771 0-5.657 0-6.828-1.172C2 19.657 2 17.771 2 14z"></path>
            </svg><a href="/categories/%E7%B3%BB%E7%BB%9F%E4%B8%8E%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/">系统与体系结构 (16)</a></div></div></widget>

<widget class="widget-wrapper timeline"><div class="widget-header dis-select"><span class="name">最新评论</span></div><div class="widget-body fs14"><div class="tag-plugin timeline ds-giscus" api="https://recent-comment-gnmy.vercel.app/" limit="5"></div></div></widget>
</div>
<footer class="footer dis-select"><div class="social-wrap"><a class="social" href="https://github.com/Wu-yikun" target="_blank" rel="external nofollow noopener noreferrer"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/Wu-yikun/OSS/PicGo/202505140418811.svg"></a><a class="social" href="https://leetcode.cn/u/wu-yikun/" target="_blank" rel="external nofollow noopener noreferrer"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/Wu-yikun/OSS/PicGo/202505140419535.svg"></a><a class="social" href="https://juejin.cn/user/1654082381026734" target="_blank" rel="external nofollow noopener noreferrer"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/Wu-yikun/OSS/PicGo/202505140419245.svg"></a><a class="social" href="https://www.zhihu.com/people/JayChou" target="_blank" rel="external nofollow noopener noreferrer"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/Wu-yikun/OSS/PicGo/202505140419020.svg"></a><a class="social" href="https://music.163.com/#/user/home?id=1479129382" target="_blank" rel="external nofollow noopener noreferrer"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/Wu-yikun/OSS/PicGo/202505140419025.svg"></a><a class="social" href="https://space.bilibili.com/441384986?spm_id_from=333.1007.0.0" target="_blank" rel="external nofollow noopener noreferrer"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/Wu-yikun/OSS/PicGo/202505140418494.svg"></a></div></footer>
</div></aside><div class="l_main" id="main">





<div class="article banner top"><img class="bg lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/Wu-yikun/OSS/PicGo/202504132348287.jpg">
  <div class="content">
    <div class="top bread-nav footnote"><div class="left"><div class="flex-row" id="breadcrumb"><a class="cap breadcrumb" href="/">主页</a>
<span class="sep"></span><a class="cap breadcrumb" href="/">文章</a><span class="sep"></span><a class="cap breadcrumb-link" href="/categories/%E9%9D%A2%E7%BB%8F/">面经</a></div><div id="tag"> <span>&nbsp;标签：</span><a class="cap breadcrumb-link" href="/tags/C/">C++</a>&nbsp; <a class="cap breadcrumb-link" href="/tags/%E9%9D%A2%E7%BB%8F/">面经</a>&nbsp;</div>
<div class="flex-row" id="post-meta"><span class="text created">发布于：<time datetime="2025-04-12T16:00:00.000Z">2025-04-13</time></span><span class="sep updated"></span><span class="text updated">更新于：<time datetime="2025-06-10T08:34:27.020Z">2025-06-10</time></span></div></div></div>
    
    <div class="bottom only-title">
      
      <div class="text-area">
        <h1 class="text title"><span>暑期实习面经</span></h1>
        
      </div>
    </div>
    
  </div>
  </div><article class="md-text content"><p>陆续一个月了，腾讯、阿里云、淘天、高德、拼多多、字节、美团… 能投的都投了。</p>
<p>建议：多刷面经，可以快速积累场景题、设计题、多线程题，而且能快速 get 到高频八股，比如 oom、cpu 使用率高、慢查询治理…</p>
<p>找暑期哪有不疯的，运气也是非常重要。</p>
<p>最后祝各位早日 oc（也祝我能 oc），无需过度焦虑，才四月初，正是发力期，过段时间一堆鸽穿的。</p>
<span id="more"></span>

<h2 id="腾讯-CDG-金融科技｜后台开发"><a href="#腾讯-CDG-金融科技｜后台开发" class="headerlink" title="腾讯 CDG 金融科技｜后台开发"></a>腾讯 CDG 金融科技｜后台开发</h2><h3 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h3><h4 id="算法题"><a href="#算法题" class="headerlink" title="算法题"></a>算法题</h4><h5 id="2-两数相加（从头开始加）｜ACM-模式"><a href="#2-两数相加（从头开始加）｜ACM-模式" class="headerlink" title="2. 两数相加（从头开始加）｜ACM 模式"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/add-two-numbers/">2. 两数相加 <span style="white-space: nowrap;"><svg width=".7em" height=".7em" viewBox="0 0 21 21" xmlns="http://www.w3.org/2000/svg"><path d="m13 3l3.293 3.293l-7 7l1.414 1.414l7-7L21 11V3z" fill="currentColor"></path><path d="M19 19H5V5h7l-2-2H5c-1.103 0-2 .897-2 2v14c0 1.103.897 2 2 2h14c1.103 0 2-.897 2-2v-5l-2-2v7z" fill="currentColor"></path></svg></span></a>（从头开始加）｜ACM 模式</h5><p>给你两个 <strong>非空</strong> 的链表，表示两个非负的整数。它们每位数字都是按照 <strong>逆序</strong> 的方式存储的，并且每个节点只能存储 <strong>一位</strong> 数字。</p>
<p>请你将两个数相加，并以相同形式返回一个表示和的链表。</p>
<p>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p>
<p><strong>示例 1：</strong></p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/Wu-yikun/OSS/PicGo/202503042258443.jpg" alt="img"></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：l1 = [<span class="number">2</span>,<span class="number">4</span>,<span class="number">3</span>], l2 = [<span class="number">5</span>,<span class="number">6</span>,<span class="number">4</span>]</span><br><span class="line">输出：[<span class="number">7</span>,<span class="number">0</span>,<span class="number">8</span>]</span><br><span class="line">解释：<span class="number">342</span> + <span class="number">465</span> = <span class="number">807.</span></span><br></pre></td></tr></tbody></table></figure>

<p>1️⃣ 迭代：先按照链表访问顺序逐个累加（类似大数之和），有进位就加到下一个节点。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ListNode</span> {</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    ListNode* next;</span><br><span class="line">    <span class="built_in">ListNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">next</span>(<span class="literal">nullptr</span>) {}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>{</span><br><span class="line">    ListNode dummy;</span><br><span class="line">    ListNode* cur = &amp;dummy;</span><br><span class="line">    <span class="type">int</span> carry = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (l1 || l2 || carry) {</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (l1) {</span><br><span class="line">            res += l1-&gt;val;</span><br><span class="line">            l1 = l1-&gt;next;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (l2) {</span><br><span class="line">            res += l2-&gt;val;</span><br><span class="line">            l2 = l2-&gt;next;</span><br><span class="line">        }</span><br><span class="line">        res += carry;</span><br><span class="line">        carry = res / <span class="number">10</span>;</span><br><span class="line">        cur = cur-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(res % <span class="number">10</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 辅助函数：创建链表（支持逐个输入）</span></span><br><span class="line"><span class="function">ListNode* <span class="title">createList</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="function">ListNode <span class="title">dummy</span><span class="params">(<span class="number">0</span>)</span>, *tail </span>= &amp;dummy;</span><br><span class="line">    <span class="comment">// cin.peek(): 检测换行，确保能正确读取链表数据</span></span><br><span class="line">    <span class="keyword">while</span> (cin.<span class="built_in">peek</span>() != <span class="string">'\n'</span> &amp;&amp; cin &gt;&gt; val) {</span><br><span class="line">        tail = tail-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(val);</span><br><span class="line">    }</span><br><span class="line">    cin.<span class="built_in">ignore</span>(); <span class="comment">// 忽略换行符</span></span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 辅助函数：打印链表</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printList</span><span class="params">(ListNode* head)</span> </span>{</span><br><span class="line">    <span class="keyword">while</span> (head) {</span><br><span class="line">        cout &lt;&lt; head-&gt;val &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="comment">// cin.eof() 是 (cin) 的一个方法，用于检查 输入流是否到达文件结束（EOF, End Of File）。</span></span><br><span class="line">    <span class="comment">// cin.eof() 只有在尝试读取失败后才会变 true, 所以最好改为 while(cin)</span></span><br><span class="line">    <span class="comment">// while (!cin.eof()) {</span></span><br><span class="line">    <span class="comment">//     ListNode* l1 = createList();</span></span><br><span class="line">    <span class="comment">//     ListNode* l2 = createList();</span></span><br><span class="line">    <span class="comment">//     ListNode* result = addTwoNumbers(l1, l2);</span></span><br><span class="line">    <span class="comment">//    printList(result);</span></span><br><span class="line">    <span class="comment">// }</span></span><br><span class="line">    <span class="keyword">while</span> (cin) { <span class="comment">// 这样可以避免额外的空行</span></span><br><span class="line">        ListNode* l1 = <span class="built_in">createList</span>();</span><br><span class="line">        ListNode* l2 = <span class="built_in">createList</span>();</span><br><span class="line">        ListNode* result = <span class="built_in">addTwoNumbers</span>(l1, l2);</span><br><span class="line">        <span class="built_in">printList</span>(result);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>另一种调用输入输出方式：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 输入:</span></span><br><span class="line"><span class="comment">// 	243</span></span><br><span class="line"><span class="comment">// 	564</span></span><br><span class="line"><span class="comment">// 输出:</span></span><br><span class="line"><span class="comment">// 	708</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 辅助函数：创建链表（支持整数输入）</span></span><br><span class="line"><span class="function">ListNode* <span class="title">createList</span><span class="params">(<span class="type">const</span> string&amp; num)</span> </span>{</span><br><span class="line">    <span class="function">ListNode <span class="title">dummy</span><span class="params">(<span class="number">0</span>)</span>, *tail </span>= &amp;dummy;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> c : num) {</span><br><span class="line">        tail-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(c - <span class="string">'0'</span>);</span><br><span class="line">        tail = tail-&gt;next;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 辅助函数：打印链表</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printList</span><span class="params">(ListNode* head)</span> </span>{</span><br><span class="line">    <span class="keyword">while</span> (head) {</span><br><span class="line">        cout &lt;&lt; head-&gt;val;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    string num1, num2;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; num1 &gt;&gt; num2) {</span><br><span class="line">        ListNode* l1 = <span class="built_in">createList</span>(num1);</span><br><span class="line">        ListNode* l2 = <span class="built_in">createList</span>(num2);</span><br><span class="line">        ListNode* result = <span class="built_in">addTwoNumbers</span>(l1, l2);</span><br><span class="line">        <span class="built_in">printList</span>(result);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>如果输入末尾有空格：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">␣ 表示空格</span><br><span class="line">1 2 3␣</span><br><span class="line">1 2 3␣</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法一</span></span><br><span class="line"><span class="function">ListNode* <span class="title">createList</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="function">ListNode <span class="title">dummy</span><span class="params">(<span class="number">0</span>)</span>, *tail </span>= &amp;dummy;</span><br><span class="line">	<span class="comment">// cin &gt;&gt; 会自动跳过所有空格</span></span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; val) { <span class="comment">// 读取整数</span></span><br><span class="line">        tail-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(val);</span><br><span class="line">        tail = tail-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (cin.<span class="built_in">peek</span>() == <span class="string">'\n'</span>) <span class="keyword">break</span>; <span class="comment">// 如果下一个字符是换行符，就停止</span></span><br><span class="line">    }</span><br><span class="line">    cin.<span class="built_in">ignore</span>(); <span class="comment">// 忽略换行符</span></span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法二</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="function">ListNode* <span class="title">createList</span><span class="params">()</span> </span>{</span><br><span class="line">    string line;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">getline</span>(cin, line) || line.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="literal">nullptr</span>; <span class="comment">// 读取一整行，如果为空则返回</span></span><br><span class="line"></span><br><span class="line">    <span class="function">stringstream <span class="title">ss</span><span class="params">(line)</span></span>;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="function">ListNode <span class="title">dummy</span><span class="params">(<span class="number">0</span>)</span>, *tail </span>= &amp;dummy;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// getline() 读取整行，stringstream 解析数字，自动跳过多余空格！</span></span><br><span class="line">    <span class="keyword">while</span> (ss &gt;&gt; val) { <span class="comment">// 解析一行中的所有整数</span></span><br><span class="line">        tail-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(val);</span><br><span class="line">        tail = tail-&gt;next;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>2️⃣ 递归：直接在 L1 链表上改（L2 比 L1 长则交换 <code>swap</code> 节点），看似递归，实则迭代，本质递归的只有头节点。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/Wu-yikun/OSS/PicGo/202503050028968.png" alt="image-20250305002830190"></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ListNode</span> {</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    ListNode* next;</span><br><span class="line">    <span class="built_in">ListNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">next</span>(<span class="literal">nullptr</span>) {}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2, <span class="type">int</span> carry = <span class="number">0</span>)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (!l1 &amp;&amp; !l2) {</span><br><span class="line">        <span class="keyword">return</span> carry ? <span class="keyword">new</span> <span class="built_in">ListNode</span>(carry) : <span class="literal">nullptr</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (!l1) {</span><br><span class="line">        <span class="built_in">swap</span>(l1, l2);</span><br><span class="line">    }</span><br><span class="line">    <span class="type">int</span> sum = carry + l1-&gt;val + (l2 ? l2-&gt;val : <span class="number">0</span>);</span><br><span class="line">    l1-&gt;val = sum % <span class="number">10</span>;</span><br><span class="line">    l1-&gt;next = <span class="built_in">addTwoNumbers</span>(l1-&gt;next, (l2 ? l2-&gt;next : <span class="literal">nullptr</span>), sum / <span class="number">10</span>);</span><br><span class="line">    <span class="keyword">return</span> l1;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">createList</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">	<span class="function">ListNode <span class="title">dummy</span><span class="params">(<span class="number">0</span>)</span>, *tail </span>= &amp;dummy;</span><br><span class="line">    <span class="keyword">while</span>(cin.<span class="built_in">peek</span>() != <span class="string">'\n'</span> &amp;&amp; cin &gt;&gt; val) {</span><br><span class="line">        tail-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(val);</span><br><span class="line">        tail = tail-&gt;next;</span><br><span class="line">    }</span><br><span class="line">    cin.<span class="built_in">ignore</span>();</span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printList</span><span class="params">(ListNode* head)</span> </span>{</span><br><span class="line">    <span class="keyword">while</span>(head) {</span><br><span class="line">        cout &lt;&lt; head-&gt;val &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin::<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(cin) {</span><br><span class="line">        ListNode* l1 = <span class="built_in">createList</span>();</span><br><span class="line">        ListNode* l2 = <span class="built_in">createList</span>();</span><br><span class="line">        ListNode* head = <span class="built_in">addTwoNumbers</span>(l1, l2);</span><br><span class="line">        <span class="built_in">printList</span>(head);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>思考</strong>：本题的链表是从数字的最低位开始的，如果改成从最高位开始，要怎么做呢？</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-linked-list/">206. 反转链表 <span style="white-space: nowrap;"><svg width=".7em" height=".7em" viewBox="0 0 21 21" xmlns="http://www.w3.org/2000/svg"><path d="m13 3l3.293 3.293l-7 7l1.414 1.414l7-7L21 11V3z" fill="currentColor"></path><path d="M19 19H5V5h7l-2-2H5c-1.103 0-2 .897-2 2v14c0 1.103.897 2 2 2h14c1.103 0 2-.897 2-2v-5l-2-2v7z" fill="currentColor"></path></svg></span></a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/add-two-numbers-ii/">445. 两数相加 II <span style="white-space: nowrap;"><svg width=".7em" height=".7em" viewBox="0 0 21 21" xmlns="http://www.w3.org/2000/svg"><path d="m13 3l3.293 3.293l-7 7l1.414 1.414l7-7L21 11V3z" fill="currentColor"></path><path d="M19 19H5V5h7l-2-2H5c-1.103 0-2 .897-2 2v14c0 1.103.897 2 2 2h14c1.103 0 2-.897 2-2v-5l-2-2v7z" fill="currentColor"></path></svg></span></a></li>
</ul>
<h5 id="445-两数相加-II（从尾开始加）"><a href="#445-两数相加-II（从尾开始加）" class="headerlink" title="445. 两数相加 II（从尾开始加）"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/add-two-numbers-ii/">445. 两数相加 II <span style="white-space: nowrap;"><svg width=".7em" height=".7em" viewBox="0 0 21 21" xmlns="http://www.w3.org/2000/svg"><path d="m13 3l3.293 3.293l-7 7l1.414 1.414l7-7L21 11V3z" fill="currentColor"></path><path d="M19 19H5V5h7l-2-2H5c-1.103 0-2 .897-2 2v14c0 1.103.897 2 2 2h14c1.103 0 2-.897 2-2v-5l-2-2v7z" fill="currentColor"></path></svg></span></a>（从尾开始加）</h5><p>给你两个 <strong>非空</strong> 链表来代表两个非负整数。数字最高位位于链表开始位置。它们的每个节点只存储一位数字。将这两数相加会返回一个新的链表。</p>
<p>你可以假设除了数字 0 之外，这两个数字都不会以零开头。</p>
<p><strong>示例1：</strong></p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/Wu-yikun/OSS/PicGo/202503042259465.png" alt="img"></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：l1 = [<span class="number">7</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">3</span>], l2 = [<span class="number">5</span>,<span class="number">6</span>,<span class="number">4</span>]</span><br><span class="line">输出：[<span class="number">7</span>,<span class="number">8</span>,<span class="number">0</span>,<span class="number">7</span>]</span><br></pre></td></tr></tbody></table></figure>

<p>1️⃣ 迭代：本题等价于「206. 反转链表（迭代写法）」+「2. 两数相加（迭代写法）」</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>{</span><br><span class="line">        ListNode* pre = <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* cur = head;</span><br><span class="line">        <span class="keyword">while</span> (cur) {</span><br><span class="line">            ListNode* nxt = cur-&gt;next;</span><br><span class="line">            cur-&gt;next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = nxt;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>{</span><br><span class="line">        l1 = <span class="built_in">reverseList</span>(l1);</span><br><span class="line">        l2 = <span class="built_in">reverseList</span>(l2);</span><br><span class="line">        ListNode dummy;</span><br><span class="line">        ListNode* cur = &amp;dummy;</span><br><span class="line">        <span class="type">int</span> carry = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (l1 || l2 || carry) {</span><br><span class="line">            <span class="type">int</span> res = carry;</span><br><span class="line">            <span class="keyword">if</span> (l1) {</span><br><span class="line">                res += l1-&gt;val;</span><br><span class="line">                l1 = l1-&gt;next;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (l2) {</span><br><span class="line">                res += l2-&gt;val;</span><br><span class="line">                l2 = l2-&gt;next;</span><br><span class="line">            }</span><br><span class="line">            carry = res / <span class="number">10</span>;</span><br><span class="line">            cur = cur-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(res % <span class="number">10</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">reverseList</span>(dummy.next);</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<p>2️⃣ 递归：本题等价于「206. 反转链表（递归写法）」+「2. 两数相加（递归写法）」</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (!head || !head-&gt;next) {</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        }</span><br><span class="line">        ListNode* new_head = <span class="built_in">reverseList</span>(head-&gt;next);</span><br><span class="line">        head-&gt;next-&gt;next = head;</span><br><span class="line">        head-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> new_head;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwo</span><span class="params">(ListNode* l1, ListNode* l2, <span class="type">int</span> carry = <span class="number">0</span>)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (!l1 &amp;&amp; !l2) {</span><br><span class="line">            <span class="keyword">return</span> carry ? <span class="keyword">new</span> <span class="built_in">ListNode</span>(carry) : <span class="literal">nullptr</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (!l1) {</span><br><span class="line">            <span class="built_in">swap</span>(l1, l2);</span><br><span class="line">        }</span><br><span class="line">        <span class="type">int</span> sum = carry + l1-&gt;val + (l2 ? l2-&gt;val : <span class="number">0</span>);</span><br><span class="line">        l1-&gt;val = sum % <span class="number">10</span>;</span><br><span class="line">        l1-&gt;next = <span class="built_in">addTwo</span>(l1-&gt;next, (l2 ? l2-&gt;next : <span class="literal">nullptr</span>), sum / <span class="number">10</span>);</span><br><span class="line">        <span class="keyword">return</span> l1;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>{</span><br><span class="line">        l1 = <span class="built_in">reverseList</span>(l1);</span><br><span class="line">        l2 = <span class="built_in">reverseList</span>(l2);</span><br><span class="line">        ListNode* head = <span class="built_in">addTwo</span>(l1, l2, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">reverseList</span>(head);</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<p>3️⃣ 栈：对两个链表分别入栈 s1 和 s2</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>{</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; s1, s2;</span><br><span class="line">        <span class="keyword">while</span> (l1) {</span><br><span class="line">            s<span class="number">1.</span><span class="built_in">push</span>(l1-&gt;val);</span><br><span class="line">            l1 = l1-&gt;next;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">while</span> (l2) {</span><br><span class="line">            s<span class="number">2.</span><span class="built_in">push</span>(l2-&gt;val);</span><br><span class="line">            l2 = l2-&gt;next;</span><br><span class="line">        }</span><br><span class="line">        <span class="type">int</span> carry = <span class="number">0</span>;</span><br><span class="line">        ListNode* nxt = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span> (!s<span class="number">1.</span><span class="built_in">empty</span>() || !s<span class="number">2.</span><span class="built_in">empty</span>() || carry) {</span><br><span class="line">            <span class="type">int</span> sum = carry;</span><br><span class="line">            <span class="keyword">if</span> (!s<span class="number">1.</span><span class="built_in">empty</span>()) {</span><br><span class="line">                sum += s<span class="number">1.</span><span class="built_in">top</span>();</span><br><span class="line">                s<span class="number">1.</span><span class="built_in">pop</span>();</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (!s<span class="number">2.</span><span class="built_in">empty</span>()) {</span><br><span class="line">                sum += s<span class="number">2.</span><span class="built_in">top</span>();</span><br><span class="line">                s<span class="number">2.</span><span class="built_in">pop</span>();</span><br><span class="line">            }</span><br><span class="line">            carry = sum / <span class="number">10</span>;</span><br><span class="line">            ListNode* node = <span class="keyword">new</span> <span class="built_in">ListNode</span>(sum % <span class="number">10</span>, nxt);</span><br><span class="line">            nxt = node;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> nxt;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<h5 id="72-编辑距离｜ACM-模式"><a href="#72-编辑距离｜ACM-模式" class="headerlink" title="72. 编辑距离｜ACM 模式"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/edit-distance/">72. 编辑距离 <span style="white-space: nowrap;"><svg width=".7em" height=".7em" viewBox="0 0 21 21" xmlns="http://www.w3.org/2000/svg"><path d="m13 3l3.293 3.293l-7 7l1.414 1.414l7-7L21 11V3z" fill="currentColor"></path><path d="M19 19H5V5h7l-2-2H5c-1.103 0-2 .897-2 2v14c0 1.103.897 2 2 2h14c1.103 0 2-.897 2-2v-5l-2-2v7z" fill="currentColor"></path></svg></span></a>｜ACM 模式</h5><p>给你两个单词 <code>word1</code> 和 <code>word2</code>， 请返回将 <code>word1</code> 转换成 <code>word2</code> 所使用的最少操作数 。</p>
<p>你可以对一个单词进行如下三种操作：</p>
<ul>
<li>插入一个字符</li>
<li>删除一个字符</li>
<li>替换一个字符</li>
</ul>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：word1 = "horse", word2 = "ros"</span><br><span class="line">输出：3</span><br><span class="line">解释：</span><br><span class="line">horse -&gt; rorse (将 'h' 替换为 'r')</span><br><span class="line">rorse -&gt; rose (删除 'r')</span><br><span class="line">rose -&gt; ros (删除 'e')</span><br></pre></td></tr></tbody></table></figure>

<p>1️⃣ 递推 · 动态规划｜ACM 模式代码：我初始化的时候只初始化 <code>dp[0][0] = 0</code> 😭</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">editDistance</span><span class="params">(<span class="type">const</span> string &amp;s1, <span class="type">const</span> string &amp;s2)</span> </span>{</span><br><span class="line">    <span class="type">int</span> m = s<span class="number">1.</span><span class="built_in">size</span>(), n = s<span class="number">2.</span><span class="built_in">size</span>();</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(m + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="comment">// 初始化值需要注意</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= m; ++i)</span><br><span class="line">        dp[i][<span class="number">0</span>] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= n; ++j)</span><br><span class="line">        dp[<span class="number">0</span>][j] = j;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) {</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) {</span><br><span class="line">            <span class="keyword">if</span> (s1[i - <span class="number">1</span>] == s2[j - <span class="number">1</span>]) {</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                dp[i][j] = <span class="built_in">min</span>({dp[i - <span class="number">1</span>][j] + <span class="number">1</span>, dp[i][j - <span class="number">1</span>] + <span class="number">1</span>, dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>});</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> dp[m][n];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	</span><br><span class="line">    string s1, s2;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; s1 &gt;&gt; s2) {</span><br><span class="line">        cout &lt;&lt; <span class="built_in">editDistance</span>(s1, s2) &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="自我介绍｜面试官"><a href="#自我介绍｜面试官" class="headerlink" title="自我介绍｜面试官"></a>自我介绍｜面试官</h4><p>我们这边主要做信用卡分期和信用卡还款这一块的业务（微信信用卡还款、分期之类的业务），聚焦金融，所以对事务性开发比较重视。</p>
<p>介绍面试流程：</p>
<ul>
<li>让你做自我介绍，然后简单聊一聊</li>
<li>两题笔试题 40 分钟，做完针对笔试聊一聊</li>
<li>针对简历内容和基础知识面谈</li>
</ul>
<h4 id="笔试题"><a href="#笔试题" class="headerlink" title="笔试题"></a>笔试题</h4><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/add-two-numbers-ii/">445. 两数相加 II <span style="white-space: nowrap;"><svg width=".7em" height=".7em" viewBox="0 0 21 21" xmlns="http://www.w3.org/2000/svg"><path d="m13 3l3.293 3.293l-7 7l1.414 1.414l7-7L21 11V3z" fill="currentColor"></path><path d="M19 19H5V5h7l-2-2H5c-1.103 0-2 .897-2 2v14c0 1.103.897 2 2 2h14c1.103 0 2-.897 2-2v-5l-2-2v7z" fill="currentColor"></path></svg></span></a></p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/edit-distance/">72. 编辑距离 <span style="white-space: nowrap;"><svg width=".7em" height=".7em" viewBox="0 0 21 21" xmlns="http://www.w3.org/2000/svg"><path d="m13 3l3.293 3.293l-7 7l1.414 1.414l7-7L21 11V3z" fill="currentColor"></path><path d="M19 19H5V5h7l-2-2H5c-1.103 0-2 .897-2 2v14c0 1.103.897 2 2 2h14c1.103 0 2-.897 2-2v-5l-2-2v7z" fill="currentColor"></path></svg></span></a></p>
<h4 id="八股文"><a href="#八股文" class="headerlink" title="八股文"></a>八股文</h4><blockquote>
<p>如何高效地将字符串/<code>char[]</code>进行追加，假设 <code>char[]</code> 开辟了很大的空间：<code>memcpy</code> 处理底层会比较快</p>
</blockquote>
<h5 id="1-C-虚函数实现机制"><a href="#1-C-虚函数实现机制" class="headerlink" title="1. C++ 虚函数实现机制"></a>1. C++ 虚函数实现机制</h5><p>C++ 虚函数用于实现多态，它的核心机制依赖于虚函数表 vtable 和虚指针 vptr，当一个类中包含虚函数时：</p>
<ul>
<li>编译器会为该类生成一个虚函数表，其中存储了该类所有虚函数的指针</li>
<li>每个对象都会包含一个虚指针，它指向该类的虚函数表</li>
<li>通过虚指针 + 虚函数表，可以在运行时调用正确的函数，实现动态绑定</li>
</ul>
<blockquote>
<p>没有虚函数的普通继承｜静态绑定，编译时绑定</p>
</blockquote>
<ul>
<li>由于 <code>show()</code> <strong>不是虚函数</strong>，调用 <code>obj-&gt;show()</code> <strong>在编译时已决定</strong> 调用 <code>Base::show()</code>，不会检查 <code>Derived</code> 是否有 <code>show()</code>。</li>
</ul>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>{ std::cout &lt;&lt; <span class="string">"Base::show()"</span> &lt;&lt; std::endl; }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>{ std::cout &lt;&lt; <span class="string">"Derived::show()"</span> &lt;&lt; std::endl; }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    Base* obj = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line">    obj-&gt;<span class="built_in">show</span>();  <span class="comment">// ❌ 调用 Base::show()（静态绑定）</span></span><br><span class="line">    <span class="keyword">delete</span> obj;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>使用虚函数｜动态绑定，运行时绑定</p>
</blockquote>
<ul>
<li><code>show()</code> 是 <strong>虚函数（virtual）</strong>，因此 <code>Base* obj</code> 在运行时会调用 <strong>Derived::show()</strong>。</li>
<li>这个过程是 <strong>通过虚指针（vptr） 和 虚函数表（vtable）实现的</strong>。</li>
</ul>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>{ std::cout &lt;&lt; <span class="string">"Base::show()"</span> &lt;&lt; std::endl; }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> <span class="keyword">override</span> </span>{ std::cout &lt;&lt; <span class="string">"Derived::show()"</span> &lt;&lt; std::endl; }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    Base* obj = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line">    obj-&gt;<span class="built_in">show</span>();  <span class="comment">// ✅ 调用 Derived::show()（动态绑定）</span></span><br><span class="line">    <span class="keyword">delete</span> obj;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<hr>
<p>举个例子：代码结构如下</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="type">int</span> moreData;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<p>虚函数表的内存分布：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Base 对象：</span><br><span class="line">┌────────────┐</span><br><span class="line">│ vptr 指针  │ ---&gt; 指向 Base 的 vtable</span><br><span class="line">├────────────┤</span><br><span class="line">│ <span class="keyword">data</span>       │</span><br><span class="line">└────────────┘</span><br><span class="line"></span><br><span class="line">Derived 对象：</span><br><span class="line">┌────────────┐</span><br><span class="line">│ vptr 指针  │ ---&gt; 指向 Derived 的 vtable</span><br><span class="line">├────────────┤</span><br><span class="line">│ <span class="keyword">data</span>       │</span><br><span class="line">├────────────┤</span><br><span class="line">│ moreData   │</span><br><span class="line">└────────────┘</span><br></pre></td></tr></tbody></table></figure>

<p>虚函数表 vtable：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Base vtable:</span><br><span class="line">┌────────────────────┐</span><br><span class="line">│ &amp;Base::<span class="built_in">show</span>()      │</span><br><span class="line">└────────────────────┘</span><br><span class="line"></span><br><span class="line">Derived vtable:</span><br><span class="line">┌────────────────────┐</span><br><span class="line">│ &amp;Derived::<span class="built_in">show</span>()   │ （覆盖 Base::<span class="built_in">show</span>()）</span><br><span class="line">└────────────────────┘</span><br></pre></td></tr></tbody></table></figure>

<hr>
<p>如果是多继承下的虚函数，当一个类继承多个基类时，每个基类都有自己的 vptr</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">showA</span><span class="params">()</span> </span>{ std::cout &lt;&lt; <span class="string">"A::showA()"</span> &lt;&lt; std::endl; }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">showB</span><span class="params">()</span> </span>{ std::cout &lt;&lt; <span class="string">"B::showB()"</span> &lt;&lt; std::endl; }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> A, <span class="keyword">public</span> B {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showA</span><span class="params">()</span> <span class="keyword">override</span> </span>{ std::cout &lt;&lt; <span class="string">"Derived::showA()"</span> &lt;&lt; std::endl; }</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showB</span><span class="params">()</span> <span class="keyword">override</span> </span>{ std::cout &lt;&lt; <span class="string">"Derived::showB()"</span> &lt;&lt; std::endl; }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    Derived d;</span><br><span class="line">    A* pa = &amp;d;</span><br><span class="line">    B* pb = &amp;d;</span><br><span class="line"></span><br><span class="line">    pa-&gt;<span class="built_in">showA</span>();  <span class="comment">// ✅ 调用 Derived::showA()</span></span><br><span class="line">    pb-&gt;<span class="built_in">showB</span>();  <span class="comment">// ✅ 调用 Derived::showB()</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>由于 <code>Derived</code> 继承了 <code>A</code> 和 <code>B</code>，其<strong>内存布局</strong>如下：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Derived 对象：</span><br><span class="line">┌────────────┐</span><br><span class="line">│ vptr_A 指针 │ ---&gt; 指向 Derived 继承 A 的 vtable</span><br><span class="line">├────────────┤</span><br><span class="line">│ A 的成员变量  │</span><br><span class="line">├────────────┤</span><br><span class="line">│ vptr_B 指针 │ ---&gt; 指向 Derived 继承 B 的 vtable</span><br><span class="line">├────────────┤</span><br><span class="line">│ B 的成员变量  │</span><br><span class="line">├────────────┤</span><br><span class="line">│ Derived 的成员变量 │</span><br><span class="line">└────────────┘</span><br></pre></td></tr></tbody></table></figure>

<h5 id="2-虚函数外的成员函数会放在虚函数表中吗？还是其他什么地方？"><a href="#2-虚函数外的成员函数会放在虚函数表中吗？还是其他什么地方？" class="headerlink" title="2. 虚函数外的成员函数会放在虚函数表中吗？还是其他什么地方？"></a>2. 虚函数外的成员函数会放在虚函数表中吗？还是其他什么地方？</h5><p>在 C++ 中，<strong>虚函数以外的普通成员函数</strong> 并不存储在对象的内存中，而是存储在<strong>代码段（text segment）</strong>。这是因为：</p>
<ol>
<li><strong>成员函数是代码，而不是数据</strong>，成员变量（数据成员）存储在对象本身的内存中，而成员函数属于程序代码，并不会在每个对象中占据额外空间。</li>
<li><strong>所有对象共享同一份成员函数</strong>：由于非虚函数的调用是静态绑定的（编译时确定），同一类的所有对象都共用相同的成员函数。</li>
<li><strong>函数地址不会存储在对象中</strong>：调用普通成员函数时，编译器直接用 <strong>函数地址</strong> 进行调用，不需要在对象中存储额外的信息。</li>
</ol>
<p>普通成员函数和静态成员函数都是存储在「代码区」，虚函数本身存储在「代码区」，但如果有虚函数，每个对象会包含一个虚表指针 <code>vptr</code> 用于指向虚函数表 <code>vtable</code>，而虚函数表通常存储在「静态存储区」。</p>
<h5 id="3-一个派生类继承两个父类，这两个父类同时有一个共同基类，如果你去调用两个父类的基类对象函数，会有问题吗？"><a href="#3-一个派生类继承两个父类，这两个父类同时有一个共同基类，如果你去调用两个父类的基类对象函数，会有问题吗？" class="headerlink" title="3. 一个派生类继承两个父类，这两个父类同时有一个共同基类，如果你去调用两个父类的基类对象函数，会有问题吗？"></a>3. 一个派生类继承两个父类，这两个父类同时有一个共同基类，如果你去调用两个父类的基类对象函数，会有问题吗？</h5><blockquote>
<p>注：在 Java 中，<strong>由于 Java 不支持多重继承，所以菱形继承问题也不存在</strong>。 Java 使用接口来替代多重继承，接口只定义了一些抽象的方法，而没有具体的实现。</p>
</blockquote>
<p>这是 C++ 多重继承造成的菱形继承问题，如果一个派生类继承了两个拥有相同基类的父类，<strong>那么基类的成员会被继承两次，这会导致 “二义性问题” 和 “冗余存储”</strong>。</p>
<p>❌ 编译错误！</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>{ std::cout &lt;&lt; <span class="string">"Base::show()"</span> &lt;&lt; std::endl; }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Parent1</span> : <span class="keyword">public</span> Base {};  <span class="comment">// 继承自 Base</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Parent2</span> : <span class="keyword">public</span> Base {};  <span class="comment">// 继承自 Base</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 多重继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Parent1, <span class="keyword">public</span> Parent2 {};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    Derived d;</span><br><span class="line">    d.<span class="built_in">show</span>();  <span class="comment">// ⚠️ 编译错误：二义性</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h5 id="4-出现二义性问题，在-C-中怎么解决这种菱形继承问题？-虚基类-Base｜class-Derived-virtual-public-Base"><a href="#4-出现二义性问题，在-C-中怎么解决这种菱形继承问题？-虚基类-Base｜class-Derived-virtual-public-Base" class="headerlink" title="4. 出现二义性问题，在 C++ 中怎么解决这种菱形继承问题？==> 虚基类 Base｜class Derived : virtual public Base"></a>4. 出现二义性问题，在 C++ 中怎么解决这种菱形继承问题？==&gt; 虚基类 <code>Base</code>｜<code>class Derived : virtual public Base</code></h5><p>1️⃣ 解决方案一：使用作用域解析符</p>
<p><strong>缺点</strong>：<code>Derived</code> 仍然包含 <strong>两个 <code>Base</code> 实例</strong>，<strong>数据冗余</strong>，而且每次调用 <code>show()</code> 需要手动指定作用域，不优雅。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    Derived d;</span><br><span class="line">    d.Parent1::<span class="built_in">show</span>();  <span class="comment">// 访问 Parent1 继承的 Base</span></span><br><span class="line">    d.Parent2::<span class="built_in">show</span>();  <span class="comment">// 访问 Parent2 继承的 Base</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>2️⃣ 使用虚继承｜最佳方案 ✅ </p>
<blockquote>
<p>虚继承是为了让某个类做出声明，承诺愿意共享它的基类，这个被共享的基类就是虚基类</p>
</blockquote>
<p>多继承除了造成命名冲突，还有数据冗余等问题，为了解决这些问题，C++ 引进了「<strong>虚继承</strong>」</p>
<p>这样能够保证 <code>Derived</code> 只含有一个唯一的 Base 实例。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>{ std::cout &lt;&lt; <span class="string">"Base::show()"</span> &lt;&lt; std::endl; }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 让 Parent1 和 Parent2 进行虚继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Parent1</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> Base {};</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Parent2</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> Base {};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承 Parent1 和 Parent2</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Parent1, <span class="keyword">public</span> Parent2 {};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    Derived d;</span><br><span class="line">    d.<span class="built_in">show</span>();  <span class="comment">// ✅ 现在可以直接调用，不会有二义性</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>不使用 <code>virtual</code> 时</strong></p>
<ul>
<li><code>Derived</code> <strong>会有两个 <code>Base</code> 对象</strong>，导致二义性问题。</li>
<li><strong>内存浪费</strong>（两个 <code>Base</code> 子对象的冗余）。</li>
</ul>
<p><strong>使用 <code>virtual</code> 继承</strong></p>
<ul>
<li><code>Parent1</code> 和 <code>Parent2</code> <strong>不会各自包含 <code>Base</code> 的副本</strong>，而是<strong>共享同一个 <code>Base</code> 实例</strong>。</li>
<li><strong><code>Derived</code> 只会有一个 <code>Base</code> 实例</strong>，所以调用 <code>show()</code> 时不会有二义性。</li>
</ul>
<hr>
<p>再看个虚继承的例子：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base0</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> var0;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">fun0</span><span class="params">()</span> </span>{ cout &lt;&lt; <span class="string">"Member of Base0"</span> &lt;&lt; endl; }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base1</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> Base0 {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> var1;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base2</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> Base0 {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> var2;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base1, <span class="keyword">public</span> Base2 {</span><br><span class="line">	<span class="comment">//定义派生类Derived </span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> var;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">()</span> </span>{</span><br><span class="line">		cout &lt;&lt; <span class="string">"Member of Derived"</span> &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">	Derived d;</span><br><span class="line">	d.var0 = <span class="number">2</span>; <span class="comment">//直接访问虚基类的数据成员</span></span><br><span class="line">	d.<span class="built_in">fun0</span>();   <span class="comment">//直接访问虚基类的函数成员</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>将 Base0 类作为它的直接派生类 Base1 和 Base2 的<strong>虚基类</strong>，即 Base1 虚继承 Base0，Base2 虚继承 Base0。之后 Derived 再继承 Base1 和 Base2，<strong>在 Derived 对象里面就不会存在 Base0 类的双份的成员</strong>。</p>
<p>Derived 对象包含着从 Base1 继承的成员和从 Base2 继承的成员，<strong>但是从 Base1 继承的 Base0 成员实际上这个地方放了一个指针，这个指针指向真正的 Base0 成员，Base2 的也是</strong>。所以实质上从最远的基类继承过来的成员，在最远派生类中只有一份。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/Wu-yikun/OSS/PicGo/202503070248915.png" alt="image-20250307024809735"></p>
<h5 id="5-STL-库中-vector、list、map-实现的底层原理和应用场景？"><a href="#5-STL-库中-vector、list、map-实现的底层原理和应用场景？" class="headerlink" title="5. STL 库中 vector、list、map 实现的底层原理和应用场景？"></a>5. STL 库中 vector、list、map 实现的底层原理和应用场景？</h5><p>关于 STL 库中所有的结构的底层实现原理：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/542115773">https://zhuanlan.zhihu.com/p/542115773 <span style="white-space: nowrap;"><svg width=".7em" height=".7em" viewBox="0 0 21 21" xmlns="http://www.w3.org/2000/svg"><path d="m13 3l3.293 3.293l-7 7l1.414 1.414l7-7L21 11V3z" fill="currentColor"></path><path d="M19 19H5V5h7l-2-2H5c-1.103 0-2 .897-2 2v14c0 1.103.897 2 2 2h14c1.103 0 2-.897 2-2v-5l-2-2v7z" fill="currentColor"></path></svg></span></a></p>
<blockquote>
<p>顺带了解了 set、map、unordered_map、unordered_set 之间区别：</p>
<ul>
<li><code>set</code>、<code>map</code>：底层使用红黑树实现，有序，插入、查找、删除的时间复杂度为 $O(logn)$<ul>
<li>优点：有序性，内部实现红黑树使得很多操作都在 $O(logn)$ 时间复杂度下完成</li>
<li>缺点：空间占用率高，需要额外保存父节点、孩子节点和红/黑性质</li>
</ul>
</li>
<li><code>unordered_set</code>、<code>unordered_map</code>：底层使用哈希表实现，无序，查找的时间复杂度为 $O(1)$<ul>
<li>优点：因为内部实现了哈希表，因此其查找速度非常的快</li>
<li>缺点：哈希表的建立比较费时</li>
</ul>
</li>
</ul>
</blockquote>
<p>1️⃣ vector 动态数组</p>
<ul>
<li><code>vector</code> 底层是动态数组，元素连续存储在堆上</li>
<li>自动扩容机制：<ul>
<li>vector 采用几何增长策略（通常是 2 倍扩容）</li>
<li>当 <code>size() == capacity()</code> 时，会申请更大的内存空间，然后拷贝旧数据到新空间</li>
<li>由于 realloc 可能导致数据搬移，<code>push_back()</code> 的均摊时间复杂度为 $O(1)$，但最坏情况 $O(n)$（扩容时）</li>
</ul>
</li>
<li>❓所以有可能 vector 的<strong>插入操作可能导致迭代器失效</strong>：因为 vector 动态增加大小时，并不是在原空间后增加新空间，而是以原大小两倍在开辟另外一片较大空间，然后将内容拷贝过来，并释放原有空间，所以迭代器失效。</li>
</ul>
<p>适用场景：</p>
<p>✅ 高效的随机访问（<code>O(1)</code>）。<br>✅ 批量尾部插入/删除（<code>push_back()</code>）。<br>❌ 不适合频繁插入/删除中间元素（<code>O(n)</code>）。<br>❌ 扩容会导致数据搬移（不适合超大数据集）。</p>
<p>2️⃣ list 双向链表</p>
<ul>
<li><code>list</code> 底层是双向链表，每个节点存储数据和两个指针</li>
<li>插入和删除操作非常高效，不影响其他元素</li>
<li>不支持随机访问，必须顺序遍历才能找到某个元素 $O(n)$</li>
<li>不会发生扩容问题，适合频繁插入/删除的场景</li>
</ul>
<p>适用场景：</p>
<p>✅ 高效插入/删除（<code>O(1)</code>，特别是中间位置）。<br>✅ 不关心随机访问，仅需遍历。<br>❌ 不适合频繁随机访问（<code>O(n)</code>）。<br>❌ 额外的指针开销（内存占用比 <code>vector</code> 高）。</p>
<p>3️⃣ map 平衡二叉搜索树——红黑树</p>
<ul>
<li><code>map</code> 底层实现是红黑树（Red-Black Tree），一种自平衡二叉搜索树</li>
<li>key 是有序的</li>
<li>插入、删除、查找 $O(logn)$，因为树的高度是 $O(logn)$</li>
<li>迭代遍历按照 key 顺序进行</li>
</ul>
<table>
<thead>
<tr>
<th>操作</th>
<th>时间复杂度</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>插入 <code>insert()</code></td>
<td>$O(log n)$</td>
<td>需要维护红黑树平衡</td>
</tr>
<tr>
<td>删除 <code>erase()</code></td>
<td>$O(log n)$</td>
<td>删除节点后可能需要旋转</td>
</tr>
<tr>
<td>查找 <code>find()</code></td>
<td>$O(log n)$</td>
<td>通过 BST 进行搜索</td>
</tr>
</tbody></table>
<p>适用场景：</p>
<p>✅ 需要有序存储的数据结构（默认按照 key 递增）。<br>✅ 需要高效查找、插入、删除（<code>O(log n)</code>）。<br>❌ 不适合频繁变更 key（因为 key 作为 BST 节点的一部分）。<br>❌ 遍历效率比 <code>unordered_map</code> 低（有序存储开销大）。</p>
<h5 id="6-红黑树有了解吗？红黑树的查找、插入、删除的时间复杂度？"><a href="#6-红黑树有了解吗？红黑树的查找、插入、删除的时间复杂度？" class="headerlink" title="6. 红黑树有了解吗？红黑树的查找、插入、删除的时间复杂度？"></a>6. 红黑树有了解吗？红黑树的查找、插入、删除的时间复杂度？</h5><p>红黑树是一种自平衡二叉搜索树（BST），广泛应用于 <strong>C++ STL 的 <code>map</code>、<code>set</code>、<code>multimap</code>、<code>multiset</code></strong> 以及 <strong>Linux 进程调度、内核数据结构</strong>等场景。</p>
<p>红黑树在每个节点上存储一个<strong>额外的颜色位（红/黑）</strong>，并满足以下<strong>五条性质</strong>：</p>
<ol>
<li><strong>每个节点是红色或黑色</strong>。</li>
<li><strong>根节点必须是黑色</strong>。</li>
<li><strong>所有叶子节点（NIL）是黑色</strong>（有些实现省略 NIL）。</li>
<li><strong>红色节点不能连续出现（红色节点的子节点必须是黑色）</strong>。</li>
<li><strong>任意节点到其所有叶子节点的路径上，黑色节点的数量相同</strong>。</li>
</ol>
<p>这些性质确保了红黑树的近似平衡特性，使得最长路径不超过最短路径的 2 倍。</p>
<p>红黑树的插入、删除、查找的时间复杂度都在 $O(logn)$</p>
<p>红黑树的应用：</p>
<ul>
<li><p>C++ STL <code>map</code> 和 <code>set</code></p>
</li>
<li><p>Linux 内核任务调度（完全公平调度 CFS）：采用红黑树作为调度队列的数据结构，用于管理所有可运行的进程，并确保进程公平分配 CPU 时间</p>
<ul>
<li>每个可运行进程存储在红黑树中，按照 <code>vruntime</code>（虚拟运行时间）排序。<ul>
<li><code>vruntime</code> 是进程实际运行时间的加权值，<code>nice</code> 值（进程优先级）影响 <code>vruntime</code> 的增长速度。</li>
</ul>
</li>
<li>调度器总是选择 <code>vruntime</code> 最小的进程运行（即红黑树的最左节点）。</li>
<li>进程执行后，<code>vruntime</code> 增长，然后被重新插入红黑树中，确保所有进程轮流执行。</li>
</ul>
</li>
<li><p>文件系统（Ext3 / Ext4）</p>
<ul>
<li><p>Ext3 是 Ext2 的升级版，支持日志，增强数据一致性。</p>
<ul>
<li><p>数据结构：</p>
<ul>
<li><p>基于 inode 和目录索引（采用 <code>h-tree</code>，即 B+ 树变种）。</p>
</li>
<li><p>日志模式：数据日志模式、元数据日志模式、无日志模式。</p>
</li>
</ul>
</li>
<li><p>缺点：大文件性能不佳，目录性能有限。</p>
</li>
</ul>
</li>
<li><p>Ext4 是 Linux 默认文件系统，在 Ext3 基础上做了多项优化：</p>
<ul>
<li><p>延迟分配：优化写入性能。</p>
</li>
<li><p>多块分配：减少磁盘碎片。</p>
</li>
<li><p>HTree 索引目录：加速大目录的查找，采用红黑树进行元数据管理。</p>
</li>
<li><p>日志优化：降低磁盘 IO，提高数据一致性。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>Redis 有序集合（ZSet）</p>
<ul>
<li>ZSet（Sorted Set） 是 Redis 中的一种数据结构，支持有序存储，每个元素带有一个 score 值（排序依据）</li>
<li>ZSet 的底层数据结构：<ul>
<li>跳表（Skip List）：默认用于有序集合，支持 <code>O(log n)</code> 级别的插入、删除、查找。</li>
<li>哈希表（Hash Table）：用于快速定位元素（score → key）。</li>
<li>红黑树（可能被用作持久化存储结构）。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="7-MySQL-的聚集索引和非聚集索引的区别？"><a href="#7-MySQL-的聚集索引和非聚集索引的区别？" class="headerlink" title="7. MySQL 的聚集索引和非聚集索引的区别？"></a>7. MySQL 的聚集索引和非聚集索引的区别？</h5><blockquote>
<p>好文：<a target="_blank" rel="noopener" href="https://blog.csdn.net/white_ice/article/details/115478367">https://blog.csdn.net/white_ice/article/details/115478367 <span style="white-space: nowrap;"><svg width=".7em" height=".7em" viewBox="0 0 21 21" xmlns="http://www.w3.org/2000/svg"><path d="m13 3l3.293 3.293l-7 7l1.414 1.414l7-7L21 11V3z" fill="currentColor"></path><path d="M19 19H5V5h7l-2-2H5c-1.103 0-2 .897-2 2v14c0 1.103.897 2 2 2h14c1.103 0 2-.897 2-2v-5l-2-2v7z" fill="currentColor"></path></svg></span></a></p>
</blockquote>
<blockquote>
<p>二叉查找树 —— 平衡二叉树 —— B 树</p>
<p><strong>因为内存的易失性。一般情况下，我们都会选择将 user 表中的数据和索引存储在磁盘这种外围设备中</strong>。但是和内存相比，从磁盘中读取数据的速度会慢上百倍千倍甚至万倍，所以，我们应当尽量减少从磁盘中读取数据的次数。另外，从磁盘中读取数据时，都是按照磁盘块来读取的，并不是一条一条的读。如果我们能把尽量多的数据放进磁盘块中，那一次磁盘读取操作就会读取更多数据，那我们查找数据的时间也会大幅度降低。如果我们用树这种数据结构作为索引的数据结构，那我们每查找一次数据就需要从磁盘中读取一个节点，也就是我们说的一个磁盘块。我们都知道平衡二叉树可是每个节点只存储一个键值和数据的。那说明什么？说明每个磁盘块仅仅存储一个键值和数据！那如果我们要存储海量的数据呢？</p>
<p>可以想象到二叉树的节点将会非常多，高度也会极其高，我们查找数据时也会进行很多次磁盘 IO，我们查找数据的效率将会极低！</p>
<blockquote>
<p><strong>B 树</strong></p>
<p>图中的 p 节点为指向子节点的指针，二叉查找树和平衡二叉树其实也有，因为图的美观性，被省略了。</p>
<p>图中的每个节点称为页，页就是我们上面说的磁盘块，在 MySQL 中数据读取的基本单位都是页，所以我们这里叫做页更符合 MySQL 中索引的底层数据结构。</p>
<p>从下图可以看出，B 树相对于平衡二叉树，每个节点存储了更多的键值（key）和数据（data），并且每个节点拥有更多的子节点，子节点的个数一般称为阶，下图中的 B 树为 3 阶 B 树，高度也会很低。基于这个特性，B 树查找数据读取磁盘的次数将会很少，数据的查找效率也会比平衡二叉树高很多。</p>
</blockquote>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/Wu-yikun/OSS/PicGo/202503071625344.jpeg" alt="5"></p>
<blockquote>
<p><strong>B+ 树</strong></p>
</blockquote>
<p>B+ 树是对 B 树的进一步优化。让我们先来看下 B+ 树的结构图：</p>
<p>根据下图我们来看下 B+ 树和 B 树有什么不同：</p>
<p>1️⃣ <strong>B+ 树非叶子节点上是不存储数据的，仅存储键值，而 B 树节点中不仅存储键值，也会存储数据</strong>。</p>
<p>之所以这么做是因为在数据库中页的大小是固定的，InnoDB 中页的默认大小是 16KB。</p>
<p>如果不存储数据，那么就会存储更多的键值，相应的树的阶数（节点的子节点树）就会更大，树就会更矮更胖，如此一来我们查找数据进行磁盘的 I/O 次数又会再次减少，数据查询的效率也会更快。</p>
<p>另外，B+ 树的阶数是等于键值的数量的，如果我们的 B+ 树一个节点可以存储 1000 个键值，那么 3 层 B+ 树可以存储 1000×1000×1000=10 亿个数据。<strong>一般根节点是常驻内存的，所以一般我们查找 10 亿数据，只需要 2 次磁盘 IO</strong>。</p>
<p>2️⃣ 因为 B+ 树索引的所有数据均存储在叶子节点，而且数据是按照顺序排列的。</p>
<p>那么 B+ 树使得范围查找、排序查找、分组查找以及去重查找变得异常简单。而 B 树因为数据分散在各个节点，要实现这一点是很不容易的。</p>
<p>有心的读者可能还发现下图 <strong>B+ 树中各个页之间是通过双向链表连接的</strong>，叶子节点中的数据是通过单向链表连接的。</p>
<p>其实上面的 B 树我们也可以对各个节点加上链表。这些不是它们之前的区别，是因为在 MySQL 的 InnoDB 存储引擎中，索引就是这样存储的。</p>
<p>也就是说下图中的 B+ 树索引就是 InnoDB 中 B+ 树索引真正的实现方式，准确的说应该是聚集索引（聚集索引和非聚集索引下面会讲到）。</p>
<p>通过下图可以看到，在 InnoDB 中，我们通过数据页之间通过双向链表连接以及叶子节点中数据之间通过单向链表连接的方式可以找到表中所有的数据。</p>
<p>MyISAM（MySQL 另一存储引擎）中的 B+ 树索引实现与 InnoDB 中的略有不同。在 MyISAM 中，B+ 树索引的叶子节点并不存储数据，而是存储数据的文件地址。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/Wu-yikun/OSS/PicGo/202503071630713.jpeg" alt="6"></p>
</blockquote>
<p>在 MySQL InnoDB 存储引擎中，索引分为聚集索引（Clustered Index） 和 非聚集索引（Secondary Index），二者的区别主要在于数据存储方式和查询性能。</p>
<ul>
<li>聚集索引表示表中存储的数据按照索引的顺序存储，检索效率比非聚集索引高，但对数据更新影响较大；非聚集索引表示数据存储在一个地方，索引存储在另一个地方，索引带有指针指向数据的存储位置。非聚集索引检索效率比聚集索引低，但对数据更新影响较小。</li>
<li>聚集索引一个表只能有一个；而非聚集索引一个表可以存在多个。聚集索引存储记录是物理上连续存在；而非聚集索引是逻辑上的连续，物理存储并不连续。</li>
</ul>
<p>1️⃣ 什么是聚集索引（Clustered Index）？</p>
<ul>
<li>聚集索引 = 数据与索引存储在一起</li>
<li><strong>B+ 树索引的叶子节点存储了整行数据</strong></li>
<li>每张表只能有一个聚集索引（因为数据只能有一种物理存储顺序）</li>
<li>主键（PRIMARY KEY）默认是聚集索引，如果没有定义主键，InnoDB 会自动选取一个 <code>UNIQUE</code> 索引或创建一个隐式主键</li>
</ul>
<blockquote>
<p>示例</p>
</blockquote>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE users (</span><br><span class="line">    id INT PRIMARY KEY,  -- 主键自动成为聚集索引</span><br><span class="line">    name VARCHAR(50),</span><br><span class="line">    age INT</span><br><span class="line">) ENGINE=InnoDB;</span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p><code>id</code> 是聚集索引，B+ 树的叶子节点存储整个行数据</p>
</blockquote>
<blockquote>
<p>存储结构</p>
</blockquote>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">聚集索引 B+ 树（按 id 组织）</span><br><span class="line">----------------------------------</span><br><span class="line">|  1  |  Alice   |  25  |</span><br><span class="line">|  2  |  Bob     |  30  |</span><br><span class="line">|  3  |  Charlie |  22  |</span><br><span class="line">----------------------------------</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>叶子节点存储完整行数据</li>
<li>查询 <code>id=2</code> 时，B+ 树直接找到整行数据，速度快</li>
</ul>
<blockquote>
<p>特点：</p>
</blockquote>
<p>✅ 查询主键时效率高（索引 + 数据一起存储，减少磁盘 I/O）<br>✅ 范围查询快（数据按主键顺序存储，连续读取）<br>❌ 插入时如果 <code>id</code> 不是自增，会导致频繁调整 B+ 树，影响性能<br>❌ 更新主键会导致数据移动，影响性能</p>
<p>2️⃣ 什么是非聚集索引（Secondary Index）？</p>
<ul>
<li>非聚集索引（非主键索引）= 索引和数据分开存储</li>
<li>B+ 树的叶子节点存储的是<strong>主键</strong>，而不是数据本身</li>
<li>查询时，需要先查索引，再回表查询数据（回表查询，Extra: Using index）<ul>
<li>比如查询 <code>name='Bob'</code> 时，需要先找到 <code>id=2</code>，再去主键索引查整行数据</li>
</ul>
</li>
<li>一张表可以有多个非聚集索引</li>
</ul>
<blockquote>
<p>示例</p>
</blockquote>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE users (</span><br><span class="line">    id INT PRIMARY KEY,  </span><br><span class="line">    name VARCHAR(50),</span><br><span class="line">    age INT,</span><br><span class="line">    INDEX idx_name(name)  -- 创建 name 非聚集索引</span><br><span class="line">) ENGINE=InnoDB;</span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p><code>name</code> 是非聚集索引，叶子节点存储的是 <code>id</code> 而不是整行数据。</p>
</blockquote>
<blockquote>
<p>存储结构</p>
</blockquote>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">非聚集索引 B+ 树（按 name 组织）</span><br><span class="line">--------------------------------</span><br><span class="line">| Alice   |  1  |</span><br><span class="line">| Bob     |  2  |</span><br><span class="line">| Charlie |  3  |</span><br><span class="line">--------------------------------</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>叶子节点存储的是 <code>id</code>（主键）</li>
<li>查询 <code>name='Bob'</code> 时，需要先找到 <code>id=2</code>，再去主键索引查整行数据</li>
</ul>
<blockquote>
<p>特点</p>
</blockquote>
<p>✅ 可以加速非主键字段的查询（如 <code>name</code>）。<br>✅ 一个表可以有多个非聚集索引（<code>name</code>、<code>age</code> 等）。<br>❌ 查询时可能需要“回表”查询完整数据，性能较低。<br>❌ 更新索引字段时，需要维护额外的索引，影响写性能。</p>
<p>创建索引时，你需要确保该索引是应用在 SQL 查询语句的条件(一般作为 WHERE 子句的条件)。</p>
<p>实际上，索引也是一张表，该表保存了主键与索引字段，并指向实体表的记录。</p>
<p>索引虽然能够提高查询性能，但也需要注意以下几点：</p>
<ul>
<li>索引需要占用额外的存储空间。</li>
<li>对表进行插入、更新和删除操作时，索引需要维护，可能会影响性能。</li>
<li>过多或不合理的索引可能会导致性能下降，因此需要谨慎选择和规划索引。</li>
</ul>
<p>3️⃣ 聚集索引 vs. 非聚集索引 对比</p>
<table>
<thead>
<tr>
<th>对比项</th>
<th>聚集索引（Clustered Index）</th>
<th>非聚集索引（Secondary Index）</th>
</tr>
</thead>
<tbody><tr>
<td>存储结构</td>
<td>索引叶子节点存储整行数据</td>
<td>索引叶子节点存储主键</td>
</tr>
<tr>
<td>查询性能</td>
<td>主键查询快（不需要回表）</td>
<td>需要回表查询完整数据</td>
</tr>
<tr>
<td>索引大小</td>
<td>整个表的大小</td>
<td>比聚集索引小（只存索引 + 主键）</td>
</tr>
<tr>
<td>插入性能</td>
<td>主键顺序插入快（如自增 ID）</td>
<td>插入影响较小</td>
</tr>
<tr>
<td>更新性能</td>
<td>更新主键影响大（数据移动）</td>
<td>更新索引字段影响较大</td>
</tr>
<tr>
<td>排序性能</td>
<td>按照主键存储，查询范围快</td>
<td>查询非主键字段排序时，可能用索引覆盖</td>
</tr>
<tr>
<td>适用场景</td>
<td>主键查询、范围查询、高效分页</td>
<td>辅助查询，如 <code>WHERE name='Bob'</code></td>
</tr>
</tbody></table>
<p>5️⃣ 什么时候选择聚集索引 &amp; 非聚集索引？</p>
<p>✅ 适合用聚集索引（PRIMARY KEY）</p>
<ul>
<li>查询主键： <code>SELECT * FROM users WHERE id = 10;</code></li>
<li>范围查询： <code>SELECT * FROM users WHERE id BETWEEN 1 AND 100;</code></li>
<li>分页查询（ORDER BY 主键）： <code>ORDER BY id LIMIT 10;</code></li>
<li>高效数据存储（自增主键 INSERT 快）</li>
</ul>
<p>✅ 适合用非聚集索引（Secondary Index）</p>
<ul>
<li>非主键查询： <code>SELECT * FROM users WHERE name = 'Alice';</code></li>
<li>模糊匹配（LIKE）： <code>SELECT * FROM users WHERE name LIKE 'A%';</code></li>
<li>组合索引： <code>INDEX (name, age)</code> 可优化 <code>WHERE name='Alice' AND age=25</code></li>
</ul>
<p>❌ 避免使用非聚集索引的场景</p>
<ul>
<li>频繁更新索引列（影响性能）</li>
<li><strong>非主键大范围查询，可能导致大量回表</strong></li>
</ul>
<h5 id="8-谈谈你对-redis-的了解？"><a href="#8-谈谈你对-redis-的了解？" class="headerlink" title="8. 谈谈你对 redis 的了解？"></a>8. 谈谈你对 redis 的了解？</h5><blockquote>
<p>Redis 面试题：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/427496556">https://zhuanlan.zhihu.com/p/427496556 <span style="white-space: nowrap;"><svg width=".7em" height=".7em" viewBox="0 0 21 21" xmlns="http://www.w3.org/2000/svg"><path d="m13 3l3.293 3.293l-7 7l1.414 1.414l7-7L21 11V3z" fill="currentColor"></path><path d="M19 19H5V5h7l-2-2H5c-1.103 0-2 .897-2 2v14c0 1.103.897 2 2 2h14c1.103 0 2-.897 2-2v-5l-2-2v7z" fill="currentColor"></path></svg></span></a></p>
<p>范围太广了。</p>
</blockquote>
<p>Redis（Remote Dictionary Server） 是一个高性能的 Key-Value 存储 NoSQL 数据库之一，用于<strong>缓存、持久化、分布式锁、消息队列等场景</strong>。<strong>基于内存存储</strong>（In-Memory），访问速度远快于磁盘数据库。单线程模型（IO 多路复用），并发性能极高。</p>
<p>支持多种数据结构（String, Hash, List, Set, Sorted Set, HyperLogLog, Bitmap, GeoSpatial）。</p>
<blockquote>
<p>数据类型；说明；应用场景</p>
</blockquote>
<ul>
<li>String：最基础数据类型；缓存字符串、计数器、分布式锁</li>
<li>List：双向链表；消息队列、文章列表</li>
<li>Set：无序集合、去重；标签、用户好友关系、抽奖系统</li>
<li>Hash：存储对象、节省内存；用户信息存储</li>
<li>Sorted Set (ZSet)：有序集合、可排序；排行榜、延时任务队列</li>
</ul>
<blockquote>
<p>Redis 与 Memcached 的区别</p>
</blockquote>
<table>
<thead>
<tr>
<th>特性</th>
<th>Redis</th>
<th>Memcached</th>
</tr>
</thead>
<tbody><tr>
<td>数据结构</td>
<td>多种（String、List、Set、Hash、ZSet）</td>
<td>仅支持 Key-Value</td>
</tr>
<tr>
<td>持久化</td>
<td><strong>RDB、AOF</strong></td>
<td>无持久化</td>
</tr>
<tr>
<td>分布式</td>
<td>支持主从复制、哨兵、集群</td>
<td>需要额外支持</td>
</tr>
<tr>
<td>线程模型</td>
<td>单线程（IO 多路复用）</td>
<td>多线程</td>
</tr>
<tr>
<td>过期策略</td>
<td>可配置（LRU、LFU）</td>
<td>FIFO/LRU</td>
</tr>
</tbody></table>
<p>Redis 持久化策略：</p>
<ul>
<li>RDB (Redis Database Snapshot)<ul>
<li>快照存储，定期将数据存储到磁盘</li>
<li>触发方式：<ul>
<li><code>save</code>：同步保存，影响性能</li>
<li><code>bgsave</code>：后台异步保存</li>
</ul>
</li>
<li>优点：适合灾难恢复（冷启动）；备份文件体积小，加载快</li>
<li>缺点：可能丢失最近的写入数据（触发快照前的写入）</li>
</ul>
</li>
<li>AOF (Append-Only File)<ul>
<li>记录所有写操作，类似 MySQL binlog</li>
<li>写模式：<ul>
<li>always：每次写入后 fsync，最安全但慢</li>
<li>everysec：每秒 fsync，默认</li>
<li>no：由 OS 决定</li>
</ul>
</li>
<li>优点：最高的数据安全性，可用于数据恢复</li>
<li>缺点：日志体积大，写入速度较慢</li>
</ul>
</li>
<li>✅ <strong>最佳实践</strong>：<ul>
<li><strong>两者结合使用</strong>（AOF 提高数据安全性，RDB 提高启动速度）。</li>
<li><code>appendonly yes</code> + <code>save 900 1</code>（开启 AOF + RDB 定期备份）。</li>
</ul>
</li>
</ul>
<p>Redis 过期策略：</p>
<ul>
<li>定期删除：Redis <strong>每秒扫描一部分 key</strong>，删除已过期的 key（减少开销）。</li>
<li>惰性删除：访问 key 时，若已过期则删除。</li>
</ul>
<p>Redis 淘汰策略：</p>
<ul>
<li><p>noeviction：不删除，返回错误</p>
</li>
<li><p>volatile-lru：LRU 淘汰（仅对有 TTL 的 key）</p>
</li>
<li><p>allkeys-lru：淘汰最近最少使用（LRU）key</p>
</li>
<li><p>volatile-random：随机删除 TTL 设定的 key</p>
</li>
<li><p>allkeys-random：随机删除任意 key</p>
</li>
<li><p>volatile-ttl：删除最近过期的 key</p>
</li>
</ul>
<p>Redis 主从复制 &amp; 哨兵 &amp; 集群：</p>
<ul>
<li>主从复制（Master-Slave）<ul>
<li><code>slaveof &lt;master-ip&gt; &lt;port&gt;</code> 配置从节点</li>
<li>主从同步<ul>
<li><strong>全量复制</strong>（初次同步）</li>
<li><strong>增量复制</strong>（接收后续写操作）</li>
</ul>
</li>
<li>读写分离，提高性能；备份数据，<strong>防止单点故障</strong></li>
</ul>
</li>
<li>哨兵（Sentinel）<ul>
<li>作用：负责自动故障转移<ul>
<li><strong>监控 Master 节点的健康状态</strong></li>
<li><strong>主节点宕机后，自动提升 Slave 为 Master</strong></li>
</ul>
</li>
<li>高可用 Redis 方案</li>
</ul>
</li>
<li>集群（Cluster）<ul>
<li>Redis Cluster 实现数据分片<ul>
<li>数据存储在多个节点</li>
<li>客户端直连节点（无中心节点）</li>
</ul>
</li>
<li>适用于大规模分布式场景（高并发、高数据量）</li>
</ul>
</li>
</ul>
<p>Redis 并发控制 &amp; 事务：</p>
<ul>
<li>事务<ul>
<li>MULTI / EXEC / DISCARD 事务机制</li>
<li>不支持回滚（失败不会撤销之前的命令）</li>
</ul>
</li>
<li>Redis 分布式锁<ul>
<li>使用 <code>SETNX</code>（SET if Not Exists）</li>
<li>避免并发超卖、分布式任务调度</li>
</ul>
</li>
</ul>
<p>Redis 面试高频问题总结：</p>
<ul>
<li>Redis 为什么快：基于内存 + 单线程 IO 多路复用</li>
<li>持久化方式：RDB（快照）+ AOF（日志）</li>
<li>淘汰策略：LRU、LFU、TTL</li>
<li>集群模式：主从复制、哨兵、集群</li>
<li><strong>如何防止缓存穿透</strong>：布隆过滤器、NULL 缓存</li>
<li><strong>如何防止缓存雪崩</strong>：设置不同 TTL、分布式缓存</li>
</ul>
<blockquote>
<p><strong>缓存穿透</strong>指的是查询一个数据库中不存在的数据，导致：</p>
<ul>
<li>缓存中没有命中</li>
<li>请求直接落到数据库，增加数据库负担</li>
<li>大规模恶意请求可能导致数据库崩溃（如 DDoS 攻击）</li>
</ul>
<p>如何防止缓存穿透：</p>
<ul>
<li>方法一：使用布隆过滤器（位数组 + 多个哈希函数）快速判断某个 key 是否可能存在，判定不存在则直接返回，不查询数据库（存在假阳性）</li>
<li>方法二：使用 NULL 缓存，对于查询后发现不存在的数据，在 Redis 缓存一个短时间的 NULL 值，下次相同请求，直接返回 NULL，避免数据库压力</li>
</ul>
<hr>
<p><strong>缓存雪崩</strong>指的是大量缓存同时失效，导致：</p>
<ul>
<li>短时间内大量请求落到数据库</li>
<li>数据库压力剧增甚至崩溃</li>
<li>可能由于 Redis 故障、集群宕机或缓存过期时间相同导致</li>
</ul>
<p>如何防止缓存雪崩：</p>
<ul>
<li>方法一：设置不同 TTL，避免所有 Key 同时失效（随机过期时间）</li>
<li>方法二：分布式缓存（多级缓存），使用多个 Redis 实例进行分片存储，引入本地缓存减少 Redis 依赖，结合 CDN 缓存缓解高并发访问压力</li>
</ul>
</blockquote>
<h5 id="9-谈谈你对-ceph-的了解？"><a href="#9-谈谈你对-ceph-的了解？" class="headerlink" title="9. 谈谈你对 ceph 的了解？"></a>9. 谈谈你对 ceph 的了解？</h5><p><a target="_blank" rel="noopener" href="https://docs.ceph.com/en/latest/architecture/">ceph.io <span style="white-space: nowrap;"><svg width=".7em" height=".7em" viewBox="0 0 21 21" xmlns="http://www.w3.org/2000/svg"><path d="m13 3l3.293 3.293l-7 7l1.414 1.414l7-7L21 11V3z" fill="currentColor"></path><path d="M19 19H5V5h7l-2-2H5c-1.103 0-2 .897-2 2v14c0 1.103.897 2 2 2h14c1.103 0 2-.897 2-2v-5l-2-2v7z" fill="currentColor"></path></svg></span></a></p>
<h5 id="10-分布式容灾有哪些方法？"><a href="#10-分布式容灾有哪些方法？" class="headerlink" title="10. 分布式容灾有哪些方法？"></a>10. 分布式容灾有哪些方法？</h5><h6 id="1-数据库主从复制（Master-Slave-Replication）"><a href="#1-数据库主从复制（Master-Slave-Replication）" class="headerlink" title="1. 数据库主从复制（Master-Slave Replication）"></a>1. 数据库主从复制（Master-Slave Replication）</h6><ul>
<li><strong>原理</strong>：主库写入数据后，同步到从库。</li>
<li><strong>场景</strong>：MySQL、PostgreSQL、Redis、MongoDB。</li>
<li>容灾策略：<ul>
<li>主库故障时，从库自动切换为主库。</li>
<li>数据实时同步或异步同步。</li>
</ul>
</li>
</ul>
<h6 id="2-多副本（Replication）"><a href="#2-多副本（Replication）" class="headerlink" title="2. 多副本（Replication）"></a>2. 多副本（Replication）</h6><ul>
<li>数据复制成多份，存储在不同的机器或地域中。</li>
<li>典型方案：<ul>
<li><strong>3 副本机制</strong>：如 HDFS、HDFS 等。</li>
<li>数据损坏时自动从其他副本恢复。</li>
</ul>
</li>
</ul>
<h6 id="3-数据分片（Sharding）"><a href="#3-数据分片（Sharding）" class="headerlink" title="3. 数据分片（Sharding）"></a>3. 数据分片（Sharding）</h6><ul>
<li>数据分散到多个节点，单节点故障影响有限。</li>
<li>常用于 Cassandra、HBase、Redis Cluster。</li>
<li>容灾策略：<ul>
<li>节点故障后自动迁移数据。</li>
<li>数据重平衡（Rebalance）。</li>
</ul>
</li>
</ul>
<h6 id="4-冷备、热备、同城-异地容灾"><a href="#4-冷备、热备、同城-异地容灾" class="headerlink" title="4. 冷备、热备、同城/异地容灾"></a>4. 冷备、热备、同城/异地容灾</h6><ul>
<li>冷备（Cold Backup）：数据定期备份到远程磁盘，灾难时手动恢复。</li>
<li>热备（Active/Standby）：实时同步，故障发生立即切换备机。</li>
<li>温备（Warm Backup）：备份节点正常运行但不处理用户请求，发生故障快速激活。</li>
</ul>
<h6 id="5-多活数据中心（多地容灾）"><a href="#5-多活数据中心（多地容灾）" class="headerlink" title="5. 多活数据中心（多地容灾）"></a>5. 多活数据中心（多地容灾）</h6><ul>
<li>部署在多个地理位置的数据中心，彼此实时或异步同步。</li>
<li>一旦某个数据中心发生故障，流量自动切换到其他数据中心。</li>
<li>常见策略：<ul>
<li>同城双活：两个数据中心同时提供服务。</li>
<li>异地容灾：跨城市或国家部署数据中心，抵御灾难性事故（如地震、火灾）。</li>
</ul>
</li>
</ul>
<h6 id="6-故障转移（Failover）"><a href="#6-故障转移（Failover）" class="headerlink" title="6. 故障转移（Failover）"></a>6. 故障转移（Failover）</h6><ul>
<li>服务宕机时自动转移到备份服务节点。</li>
<li>常用技术：<ul>
<li>DNS 切换</li>
<li>虚 IP（VIP）漂移（如 Keepalived）</li>
<li>心跳检测（Heartbeat）</li>
</ul>
</li>
</ul>
<h6 id="7-降级和限流"><a href="#7-降级和限流" class="headerlink" title="7. 降级和限流"></a>7. 降级和限流</h6><ul>
<li><strong>降级</strong>：当部分节点故障时，降低服务质量或关闭非核心服务。</li>
<li><strong>限流</strong>：限流可防止故障扩散，避免雪崩效应。</li>
</ul>
<h6 id="8-数据快照（Snapshot）和备份（Backup）"><a href="#8-数据快照（Snapshot）和备份（Backup）" class="headerlink" title="8. 数据快照（Snapshot）和备份（Backup）"></a>8. 数据快照（Snapshot）和备份（Backup）</h6><ul>
<li>快照：短时间内完整复制数据状态。</li>
<li>备份：定期保存数据，用于数据恢复。</li>
</ul>
<h6 id="9-服务熔断与限流"><a href="#9-服务熔断与限流" class="headerlink" title="9. 服务熔断与限流"></a>9. 服务熔断与限流</h6><ul>
<li>熔断：当服务响应变慢或故障率较高，自动熔断请求，防止故障蔓延。</li>
<li>限流：控制请求量，避免超载。</li>
</ul>
<h6 id="10-灾难演练和混沌工程"><a href="#10-灾难演练和混沌工程" class="headerlink" title="10. 灾难演练和混沌工程"></a>10. 灾难演练和混沌工程</h6><ul>
<li>通过人工或自动化工具进行<strong>故障注入</strong>，验证系统容灾能力。</li>
<li>如：Chaos Engineering 工具（ChaosBlade、Chaos Mesh、Gremlin）</li>
</ul>
<h5 id="11-你理解的设计模式？为什么会有设计模式？你觉得设计一个软件怎么应用这些设计模式？以及你在开发方面的一些心得？"><a href="#11-你理解的设计模式？为什么会有设计模式？你觉得设计一个软件怎么应用这些设计模式？以及你在开发方面的一些心得？" class="headerlink" title="11. 你理解的设计模式？为什么会有设计模式？你觉得设计一个软件怎么应用这些设计模式？以及你在开发方面的一些心得？"></a>11. 你理解的设计模式？为什么会有设计模式？你觉得设计一个软件怎么应用这些设计模式？以及你在开发方面的一些心得？</h5><blockquote>
<p>❓主要是面试官看到了我的个人博客，我回复提到了「设计模式」，所以面试官就接着话题往下问了。</p>
</blockquote>
<p>设计模式是一系列在软件设计过程中经过反复实践、总结、优化的通用解决方案或经验总结。设计模式体现了一种思想和经验，而不是具体的代码。它是面向对象软件开发过程中的最佳实践，常见的设计模式分为三大类：</p>
<ol>
<li><strong>创建型模式</strong>：关注对象的创建，例如工厂方法、抽象工厂、单例、建造者、原型模式等。</li>
<li><strong>结构型模式</strong>：处理类或对象的组合，例如适配器、装饰器、代理、桥接、组合、外观、享元模式等。</li>
<li><strong>行为型模式</strong>：描述对象之间的通信和职责划分，例如观察者、策略、命令、模板方法、状态、责任链、迭代器模式等。</li>
</ol>
<blockquote>
<p>为什么会有设计模式？</p>
</blockquote>
<ul>
<li><strong>提高复用性</strong>：设计模式是经验的总结，能被反复地重用，减少设计过程的试错成本。</li>
<li><strong>提供通用解决方案</strong>：很多开发中的问题和场景都是重复的，设计模式给出了通用的、经过验证的解决方案。</li>
<li><strong>提升代码可维护性和可读性</strong>：设计模式使得开发人员之间有一种共同语言，团队更易于交流和协作，有助于提高代码的易读性和易维护性。</li>
<li><strong>提高设计的灵活性和扩展性</strong>：合理使用设计模式能降低代码耦合度，增强系统扩展性，应对需求变更和演化。</li>
</ul>
<blockquote>
<p>如何应用设计模式？</p>
</blockquote>
<p>在实际项目中，并非一定要强行使用设计模式，而应根据实际需求、规模、复杂性等选择合适的模式，遵循以下原则：</p>
<ol>
<li><p>分析和识别需求场景：设计模式不是盲目套用的工具，而是用来解决具体问题的。因此需要仔细理解业务需求，识别是否存在典型场景。</p>
</li>
<li><p>选取合适模式：根据具体场景选择最适合的模式。比如：</p>
<ul>
<li><p>当需要统一对象创建方式时，使用<strong>工厂模式</strong>。</p>
</li>
<li><p>当多个对象需要监听同一事件变化时，使用<strong>观察者模式</strong>。</p>
</li>
<li><p>需要动态给对象添加额外的职责时，选择<strong>装饰器模式</strong>。</p>
</li>
</ul>
</li>
<li><p>注意适度原则：设计模式的滥用可能带来过度抽象，使简单的问题复杂化。因此必须注意“适度”和“恰当”，不应过度设计。</p>
</li>
<li><p>实践经验总结</p>
<ul>
<li><p>先设计，再编码。设计模式应当在设计阶段思考和确定，不是为了模式而模式。</p>
</li>
<li><p>多结合实际项目实践进行总结，只有这样，才能准确把握设计模式的精髓。</p>
</li>
</ul>
</li>
</ol>
<blockquote>
<p>开发方面的心得</p>
</blockquote>
<ol>
<li>重视基础，少做炫技：软件开发本质是为了解决问题，而不是为了炫耀技术。很多时候用最简单的方案解决问题远好过追求模式、框架的复杂应用。</li>
<li>敏捷迭代，避免过度设计：很多时候，我们都无法精确预知项目未来变化，因此初始设计应当足够灵活，避免盲目追求复杂架构。</li>
<li>关注代码可读性和维护性：优秀的开发者不仅考虑代码是否运行，更考虑代码是否易于维护和扩展，设计模式在提升代码可读性和维护性上帮助极大。</li>
<li>保持开放、持续学习：技术在不断演进，开发人员必须保持开放心态，持续学习新模式、新技术，但同时谨记避免盲目跟风。</li>
</ol>
<h5 id="12-一份代码里面写了很多设计模式，这好不好？"><a href="#12-一份代码里面写了很多设计模式，这好不好？" class="headerlink" title="12. 一份代码里面写了很多设计模式，这好不好？"></a>12. 一份代码里面写了很多设计模式，这好不好？</h5><p>不一定是好事，虽然一定程度上提高了代码的可维护性和可扩展性，降低代码耦合。</p>
<p>但是过度设计会造成</p>
<ul>
<li>代码复杂、冗长、难以理解，增加了维护成本；</li>
<li>同时影响代码性能</li>
<li>滥用设计模式也会导致开发效率降低，比如一个简单的 <code>if-else</code> 选择逻辑，如果强行用 <strong>策略模式</strong>，会导致代码可读性下降</li>
</ul>
<h4 id="简历拷打"><a href="#简历拷打" class="headerlink" title="简历拷打"></a>简历拷打</h4><ol>
<li><p>项目应用在哪些场景？</p>
</li>
<li><p><strong>在内存中设计为索引前缀树，那在非易失性存储介质中呢</strong>？也是索引前缀树，还是全表查找？</p>
<ol>
<li>ART：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/645064049">https://zhuanlan.zhihu.com/p/645064049 <span style="white-space: nowrap;"><svg width=".7em" height=".7em" viewBox="0 0 21 21" xmlns="http://www.w3.org/2000/svg"><path d="m13 3l3.293 3.293l-7 7l1.414 1.414l7-7L21 11V3z" fill="currentColor"></path><path d="M19 19H5V5h7l-2-2H5c-1.103 0-2 .897-2 2v14c0 1.103.897 2 2 2h14c1.103 0 2-.897 2-2v-5l-2-2v7z" fill="currentColor"></path></svg></span></a></li>
</ol>
</li>
<li><p>LearnedTLB 是为什么能达到降低 CPU 访存次数？</p>
</li>
<li><p>LearnedTLB 在哪些场景下适用/比较好？</p>
</li>
<li><p>你们模拟的故障注入场景有哪些？怎么注入故障？</p>
</li>
<li><p>如果系统故障注入后，如何进行恢复？</p>
</li>
<li><p><strong>故障注入的报告是什么内容</strong>？</p>
</li>
<li><p>博客之类的文章我上去看了一些，有没有让你比较深刻学到很多的内容可以分享一下？</p>
</li>
</ol>
<h4 id="反问环节"><a href="#反问环节" class="headerlink" title="反问环节"></a>反问环节</h4><p>Q1：金融是不是对安全要求比较高？</p>
<p>A1：金融这块有几个核心的业务点：</p>
<ol>
<li>安全性：数据安全、法律合规、权限管理（数据存储、通信链路、日志打印）</li>
<li>可用性：金融对可用性要求比较高，就比如刚刚为什么我问了很多分布式容灾的一些相关内容，因为你有做过故障这方面的模拟和注入经验，我觉得是一些很可贵的经验。金融对故障演习、故障注入、自动化报表、业务恢复情况比较重视。</li>
<li>资金流的状态机：金融会从订单整体状态机的严谨性，流程对账，资金流水的日志方便审计</li>
<li>注意 To B 的合作：金融这一行肯定是和国企打交道，所以 to B 的属性比较重，每个银行都有很多特性，特性的多样化你怎么在你的业务上整合起来，不可能给每个银行写一套代码</li>
</ol>
<blockquote>
<p>随心 talk</p>
</blockquote>
<p>你刚刚说对老师周五开组会，一般是上午还是下午，要多久。</p>
<p>那比如说你下午在公司订个会议室，你自己跟导师聊一聊也 OK 吧，你自己周五也能来公司吧？一定要去线下参加吗？</p>
<p>如果说你到时候来参加实习，周五就线上参与？</p>
<p>这个不是问题，如果线上的话，我理解也没啥问题。</p>
<p>最后一个问题，你对 Linux 熟悉吗？</p>
<p>如果过了一面，下次面试应该是 3-5 天，或者一周左右。</p>
<p>结果我没办法自己拍，要跟领导沟通一下。</p>
<h3 id="二面（挂）"><a href="#二面（挂）" class="headerlink" title="二面（挂）"></a>二面（挂）</h3><blockquote>
<p>提前准备</p>
</blockquote>
<p>0️⃣ 自我介绍：首先说自己是厦门大学研二在读</p>
<ul>
<li>本科：java、前端、服务器-域名、linux、golang</li>
<li>研究生（大四）：提前来实验室、C++、杭州实习、西安实习、中科院实习、系统与体系结构</li>
</ul>
<p>1️⃣ 主要表现对这一块业务感兴趣。</p>
<ol>
<li>聊一聊自己对金融这块业务的理解，问一问某些部分你们都是怎么优化的？然后说一说我的思考？多请教。</li>
<li>假设问最近有关注什么事吗 ==&gt; deepseek 5 天开源的内容 (3FS)</li>
<li><strong>关于 ceph 这块，实验室刚接了一个国重项目，我想问问您对这块了解吗，关于 ceph 内的故障恢复机制，我个人挺感兴趣的，而且对你们这个业务和方向也感兴趣，感觉自己研究生的一些研究方向和你们业务也相匹配。</strong></li>
<li><strong>因为金融业务需要保证高度的可用性，所以我想请教下你们架构上是怎么做分布式容灾的呢？</strong></li>
<li><strong>当前团队在研发的金融业务，有哪些主要的技术难点或者挑战？</strong></li>
<li>能否介绍一下当前部门使用的主要技术栈和工具链？</li>
<li>腾讯金融科技部门日常技术挑战中，最常遇到的难点或技术瓶颈有哪些？</li>
<li>金融领域的数据安全和合规管理，你们是怎么保障和实现的？</li>
<li><strong>在高并发、高可用、容灾方面，你们具体用了哪些方案或技术？</strong></li>
</ol>
<p>2️⃣ LeetCode Hot 100</p>
<p>3️⃣ 夯实简历中科院实习的故障注入的内容</p>
<p>4️⃣ 八股文背熟</p>
<ul>
<li>多注重分布式存储、容灾、安全这一块的问题</li>
<li>注意事务相关的问题</li>
<li>MySQL 得看看</li>
<li>快排如何把空间复杂度降到 $O(1)$：还是降低不到 O(1)，递归调用会带来 $O(logn)～O(n)$ 的栈空间消耗（取决于划分的平衡性），可以通过尾递归优化减少栈空间消耗：<strong>每次递归选择较短的子数组进行递归</strong>，<strong>而较长的子数组用循环来代替递推</strong>。</li>
</ul>
<h4 id="1-转账业务"><a href="#1-转账业务" class="headerlink" title="1. 转账业务"></a>1. 转账业务</h4><ul>
<li>从你的银行账户里转 1 块钱到我的银行账户里，具体流程？</li>
<li>先减还是先增？—— 减</li>
<li>根据日志回滚？但是日志也不一定是正确的？</li>
</ul>
<h4 id="2-rand7-实现-rand10"><a href="#2-rand7-实现-rand10" class="headerlink" title="2. rand7() 实现 rand10()"></a>2. rand7() 实现 rand10()</h4><blockquote>
<p>⚠️ 腾讯、字节常考的面试题！</p>
<p>本题重点是<strong>相等概率</strong>！</p>
</blockquote>
<p>本质：就是将 7 进制数转为 10 进制数，即 <code>rand7() * 7 + rand7()</code>，范围为 <code>[14, 56]</code>，取模 <code>%10</code>，剔除范围外的数字即可。</p>
<blockquote>
<p>面试的时候回答两个 Rand7() 相乘，被腾讯面试官问比如 13 这种数就没办法生成怎么办？</p>
<p>由面试官一步步引导回答出来，不过还是建议用 <code>(rand7() - 1) * 7 + rand7()</code></p>
</blockquote>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="built_in">rand7</span>() * <span class="number">7</span> + <span class="built_in">rand7</span>() =&gt; [<span class="number">14</span>, <span class="number">56</span>]</span><br><span class="line"><span class="number">2.</span> [<span class="number">14</span>, <span class="number">56</span>] % <span class="number">10</span> + <span class="number">1</span></span><br></pre></td></tr></tbody></table></figure>

<h5 id="解法-1"><a href="#解法-1" class="headerlink" title="解法 1"></a>解法 1</h5><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The rand7() API is already defined for you.</span></span><br><span class="line"><span class="comment">// int rand7();</span></span><br><span class="line"><span class="comment">// @return a random integer in the range 1 to 7</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rand10</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> (<span class="built_in">rand7</span>() + <span class="built_in">rand7</span>() + <span class="built_in">rand7</span>() + <span class="built_in">rand7</span>() + <span class="built_in">rand7</span>()) % <span class="number">10</span> + <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<h5 id="🔥-解法-2"><a href="#🔥-解法-2" class="headerlink" title="🔥 解法 2"></a>🔥 解法 2</h5><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The rand7() API is already defined for you.</span></span><br><span class="line"><span class="comment">// int rand7();</span></span><br><span class="line"><span class="comment">// @return a random integer in the range 1 to 7</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rand10</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) {</span><br><span class="line">            <span class="comment">// res =&gt; 等概率 [1, 49]</span></span><br><span class="line">            <span class="type">int</span> res = (<span class="built_in">rand7</span>() - <span class="number">1</span>) * <span class="number">7</span> + <span class="built_in">rand7</span>();</span><br><span class="line">            <span class="keyword">if</span> (res &gt;= <span class="number">1</span> &amp;&amp; res &lt;= <span class="number">40</span>)</span><br><span class="line">                <span class="keyword">return</span> res % <span class="number">10</span> + <span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<h2 id="腾讯-PCG-QQ｜后台开发"><a href="#腾讯-PCG-QQ｜后台开发" class="headerlink" title="腾讯 PCG QQ｜后台开发"></a>腾讯 PCG QQ｜后台开发</h2><h3 id="一面（挂）"><a href="#一面（挂）" class="headerlink" title="一面（挂）"></a>一面（挂）</h3><ul>
<li>unordered_map 与 map 的区别</li>
<li>C++ 多态怎么实现的</li>
<li>C++ 异常处理机制</li>
<li><strong>Redis</strong></li>
<li>自旋锁</li>
<li><strong>计算机网络 socket 编程</strong></li>
<li><strong>linux 内存分配机制</strong></li>
<li>进程和线程的区别</li>
<li>进程间通信方式</li>
<li><strong>协程</strong></li>
<li>智能指针</li>
<li><strong>mysql 的 SQL 注入问题</strong></li>
<li><strong>mysql MVCC</strong></li>
<li><strong>https 与 http</strong></li>
<li><strong>怎么查看线程堆栈大小？正常大小为多少？</strong></li>
<li>Linux 用户态与内核态的区别？</li>
<li>如何理解 Linux 一切皆文件？</li>
</ul>
<p>x. 项目</p>
<p>x. 两数之和 + 64匹马8赛道最少几轮决前4 —— 11轮/10轮 都可</p>
<h4 id="1-C-多态实现"><a href="#1-C-多态实现" class="headerlink" title="1. C++ 多态实现"></a>1. C++ 多态实现</h4><p>多态主要分为：</p>
<ul>
<li><strong>静态多态</strong>（编译期实现）：如函数重载、模板。</li>
<li><strong>动态多态</strong>（运行时实现）：通过虚函数（virtual）来实现，常用于继承关系中。</li>
</ul>
<p>针对动态多态具体来说，编译器会为每个含有虚函数的类创建一个<strong>虚函数表（<code>vtable</code>）</strong>，表中存放该类所有虚函数的地址。每个该类对象内部也会额外存储一个指向虚函数表的指针（<code>vptr</code>）。</p>
<p>当调用虚函数时，编译器在底层会通过以下方式实现：</p>
<ul>
<li>首先，通过对象内部的虚指针找到对应的虚函数表；</li>
<li>然后，根据调用的虚函数在表中的位置，找到函数指针；</li>
<li>最终，调用这个函数指针指向的实际函数。</li>
</ul>
<p>⚠️ 注意：</p>
<ul>
<li>每个类对象会多占用一个指针大小（通常8字节或4字节，取决于平台），存储虚指针。</li>
<li>每个类只会存在<strong>一个虚函数表</strong>实例，无论创建多少个对象，都只共享一个虚函数表。</li>
<li>虚函数调用相较于普通函数调用会增加一次间接寻址的开销，但开销非常小，通常不会造成明显性能问题。</li>
<li>若基类的析构函数不是虚函数，则在用基类指针删除派生类对象时会出现未定义行为，故通常建议将基类析构函数定义为虚函数。</li>
</ul>
<h4 id="2-C-异常处理机制"><a href="#2-C-异常处理机制" class="headerlink" title="2. C++ 异常处理机制"></a>2. C++ 异常处理机制</h4><p>C++ 的异常处理是通过 <code>try</code>、<code>catch</code>、<code>throw</code> 三个关键字实现的，具体机制如下：</p>
<ol>
<li><p><strong>抛出异常（<code>throw</code>）</strong></p>
<ul>
<li><p>当程序中出现错误或异常情况时，可以使用 <code>throw</code> 抛出一个异常对象。</p>
  <figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (denominator == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">"除数不能为0"</span>);</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
</li>
<li><p><strong>捕获异常（<code>try-catch</code>）</strong></p>
<ul>
<li><p>异常被抛出后，程序控制权会自动转移到相应的 <code>catch</code> 块，前提是异常抛出位置位于对应的 <code>try</code> 块内。</p>
  <figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> {</span><br><span class="line">    <span class="type">int</span> result = <span class="built_in">divide</span>(x, y);</span><br><span class="line">} <span class="built_in">catch</span> (<span class="type">const</span> std::runtime_error&amp; e) {</span><br><span class="line">    std::cerr &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
</li>
<li><p><strong>异常传播与栈展开</strong></p>
<ul>
<li>当异常被抛出后，程序会逐级向上查找匹配的 <code>catch</code> 语句，如果找到匹配，则进入相应的处理逻辑；若没有对应的处理，则异常继续向调用栈的上层传播。</li>
<li>如果直到 <code>main()</code> 函数都未捕获异常，程序会调用 <code>std::terminate()</code> 终止。</li>
</ul>
</li>
<li><p><strong>异常对象</strong></p>
<ul>
<li><p>异常对象通常以值的方式抛出，以引用方式捕获，以避免拷贝开销。</p>
  <figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">catch</span> (<span class="type">const</span> ExceptionType&amp; e) { ... }</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
</li>
<li><p><strong>栈展开（stack unwinding）</strong></p>
<ul>
<li>当异常抛出后，程序会从抛出点开始逐层向上退出栈帧（函数调用），直到捕获异常为止。</li>
<li>在栈展开过程中，局部对象会按顺序调用析构函数释放资源，这保证了资源的正确释放（RAII 机制）。</li>
</ul>
</li>
</ol>
<p>注意：异常中断了程序的正常流程，从而可能导致对象处于无效或未完成的状态，或者资源没有正常释放等问题。那些在异常发生期间正确执行了“清理”工作的程序被称作异常安全的代码（编写困难）。</p>
<h4 id="3-自旋锁"><a href="#3-自旋锁" class="headerlink" title="3. 自旋锁"></a>3. 自旋锁</h4><p>自旋锁（Spinlock）是一种用于实现并发控制的同步机制。它的原理非常简单：当线程试图获取锁时，如果锁已被其他线程占用，则该线程不会进入睡眠，而是持续地循环（自旋）检查锁的状态，直到锁被释放为止。</p>
<ul>
<li><p>优点：</p>
<ul>
<li>避免线程切换（上下文切换）的开销，减少线程调度成本。</li>
<li>在锁被占用时间非常短暂的场景中效率高，比如对共享变量做简单操作（原子操作）。</li>
</ul>
</li>
<li><p>缺点：</p>
<ul>
<li>长时间占用CPU，造成资源浪费。</li>
<li>如果锁持有时间过长，自旋等待将极大降低系统性能。</li>
</ul>
</li>
<li><p>适用场景：</p>
<ul>
<li>临界区代码执行非常短，线程争用的情况不频繁。</li>
<li>多核环境下效果更好，尤其是锁争用时间非常短的时候。</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>自旋锁（Spinlock）</th>
<th>互斥锁（Mutex）</th>
</tr>
</thead>
<tbody><tr>
<td>等待方式</td>
<td>忙等待（Busy Waiting）</td>
<td>线程睡眠（Sleep）</td>
</tr>
<tr>
<td>CPU资源占用</td>
<td>较高（不停地检查锁状态）</td>
<td>较低（线程阻塞时不占CPU资源）</td>
</tr>
<tr>
<td>适用场景</td>
<td>临界区短、小规模并发</td>
<td>临界区较长的场景</td>
</tr>
</tbody></table>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">std::atomic_flag lock = ATOMIC_FLAG_INIT;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">lock</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">while</span> (lock.<span class="built_in">test_and_set</span>(std::memory_order_acquire)) {</span><br><span class="line">        ; <span class="comment">// 忙等待</span></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">unlock</span><span class="params">()</span> </span>{</span><br><span class="line">    lock.<span class="built_in">clear</span>(std::memory_order_release);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>解释：</p>
<ul>
<li>当锁已被其他线程占用时，当前线程会反复检测锁状态，直到锁被释放。</li>
<li>自旋锁的核心就是“自旋等待”，并不会切换到其他线程，或调用系统 API 进入睡眠状态。</li>
</ul>
<h4 id="4-计算机网络｜Socket-编程"><a href="#4-计算机网络｜Socket-编程" class="headerlink" title="4. 计算机网络｜Socket 编程"></a>4. 计算机网络｜Socket 编程</h4><p>计算机网络中的 <strong>Socket 编程</strong> 是一种通过网络进行通信的软件开发技术。</p>
<ul>
<li>Socket（套接字）是应用层与传输层之间的<strong>编程接口</strong>。</li>
<li>它本质上是对 TCP/IP 协议栈的一种封装，允许开发者实现网络中进程之间的通信。</li>
</ul>
<h5 id="Socket-分类"><a href="#Socket-分类" class="headerlink" title="Socket 分类"></a>Socket 分类</h5><p>通常有两种类型：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>描述</th>
<th>常见应用协议</th>
</tr>
</thead>
<tbody><tr>
<td><strong>流式套接字（SOCK_STREAM）</strong></td>
<td>提供面向连接、可靠的传输，基于TCP协议</td>
<td>HTTP、FTP、SMTP等</td>
</tr>
<tr>
<td><strong>数据报套接字（SOCK_DGRAM）</strong></td>
<td>提供无连接、不保证可靠传输，基于UDP协议</td>
<td>DNS、DHCP 等</td>
</tr>
</tbody></table>
<h5 id="Socket-编程步骤"><a href="#Socket-编程步骤" class="headerlink" title="Socket 编程步骤"></a>Socket 编程步骤</h5><p>Socket 编程的一般步骤如下：</p>
<h5 id="服务端流程："><a href="#服务端流程：" class="headerlink" title="服务端流程："></a>服务端流程：</h5><ol>
<li>创建套接字 (<code>socket()</code>)</li>
<li>绑定地址和端口 (<code>bind()</code>)</li>
<li>监听连接请求 (<code>listen()</code>)</li>
<li>接受连接请求，返回一个新的套接字 (<code>accept()</code>)</li>
<li>通过新套接字进行通信 (<code>recv()</code>/<code>send()</code>)</li>
<li>关闭套接字 (<code>close()</code>)</li>
</ol>
<h5 id="服务端代码示例"><a href="#服务端代码示例" class="headerlink" title="服务端代码示例"></a>服务端代码示例</h5><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="type">int</span> server_fd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    sockaddr_in server_addr{};</span><br><span class="line">    server_addr.sin_family = AF_INET;</span><br><span class="line">    server_addr.sin_addr.s_addr = INADDR_ANY; <span class="comment">// 监听所有地址</span></span><br><span class="line">    server_addr.sin_port = <span class="built_in">htons</span>(<span class="number">8080</span>);       <span class="comment">// 端口8080</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">bind</span>(server_fd, (<span class="keyword">struct</span> sockaddr*)&amp;server_addr, <span class="built_in">sizeof</span>(server_addr));</span><br><span class="line">    <span class="built_in">listen</span>(server_fd, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    sockaddr_in client_addr{};</span><br><span class="line">    <span class="type">socklen_t</span> addr_len = <span class="built_in">sizeof</span>(client_addr);</span><br><span class="line">    <span class="type">int</span> client_fd = <span class="built_in">accept</span>(server_fd, (<span class="keyword">struct</span> sockaddr*)&amp;server_addr, &amp;addr_len);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">1024</span>]{};</span><br><span class="line">    <span class="built_in">recv</span>(client_fd, buffer, <span class="built_in">sizeof</span>(buffer), <span class="number">0</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">"接收到消息: "</span> &lt;&lt; buffer &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* msg = <span class="string">"收到！"</span>;</span><br><span class="line">    <span class="built_in">send</span>(client_fd, msg, <span class="built_in">strlen</span>(msg), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(client_fd);</span><br><span class="line">    <span class="built_in">close</span>(server_fd);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h5 id="客户端流程（TCP）"><a href="#客户端流程（TCP）" class="headerlink" title="客户端流程（TCP）"></a>客户端流程（TCP）</h5><ol>
<li>创建套接字 (<code>socket()</code>)</li>
<li>发起连接请求 (<code>connect()</code>)</li>
<li>发送与接收数据 (<code>send()</code>/<code>recv()</code>)</li>
<li>关闭套接字 (<code>close()</code>)</li>
</ol>
<h5 id="客户端示例代码"><a href="#客户端示例代码" class="headerlink" title="客户端示例代码"></a>客户端示例代码</h5><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="type">int</span> sock_fd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    sockaddr_in serv_addr{};</span><br><span class="line">    serv_addr.sin_family = AF_INET;</span><br><span class="line">    serv_addr.sin_port = <span class="built_in">htons</span>(<span class="number">8080</span>);</span><br><span class="line">    serv_addr.sin_addr.s_addr = <span class="built_in">inet_addr</span>(<span class="string">"127.0.0.1"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">connect</span>(sock_fd, (<span class="keyword">struct</span> sockaddr*)&amp;serv_addr, <span class="built_in">sizeof</span>(serv_addr));</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* msg = <span class="string">"你好，服务端！"</span>;</span><br><span class="line">    <span class="built_in">send</span>(sock_fd, msg, <span class="built_in">strlen</span>(msg), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">1024</span>]{};</span><br><span class="line">    <span class="built_in">recv</span>(sock_fd, buffer, <span class="built_in">sizeof</span>(buffer), <span class="number">0</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">"服务器回复："</span> &lt;&lt; buffer &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(sock_fd);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h5 id="常用-API-函数"><a href="#常用-API-函数" class="headerlink" title="常用 API 函数"></a>常用 API 函数</h5><table>
<thead>
<tr>
<th>函数名</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td><code>socket()</code></td>
<td>创建套接字描述符</td>
</tr>
<tr>
<td><code>bind()</code></td>
<td>绑定IP地址和端口</td>
</tr>
<tr>
<td><code>listen()</code></td>
<td>监听传入连接请求</td>
</tr>
<tr>
<td><code>accept()</code></td>
<td>接受新的连接，创建通信socket</td>
</tr>
<tr>
<td><code>connect()</code></td>
<td>客户端连接服务端</td>
</tr>
<tr>
<td><code>send()</code></td>
<td>发送数据</td>
</tr>
<tr>
<td><code>recv()</code></td>
<td>接收数据</td>
</tr>
<tr>
<td><code>close()</code></td>
<td>关闭socket</td>
</tr>
</tbody></table>
<h5 id="Socket-编程注意事项："><a href="#Socket-编程注意事项：" class="headerlink" title="Socket 编程注意事项："></a>Socket 编程注意事项：</h5><ul>
<li>TCP是面向连接的，需明确服务端和客户端角色。</li>
<li>网络字节序（大端、小端）问题，通常用<code>htons()</code>和<code>htonl()</code>处理。</li>
<li>Socket操作可能发生阻塞，需关注阻塞与非阻塞模式。</li>
<li>注意处理边界情况（数据发送和接收可能分多次完成）。</li>
</ul>
<h4 id="5-Linux-内存分配"><a href="#5-Linux-内存分配" class="headerlink" title="5. Linux 内存分配"></a>5. Linux 内存分配</h4><blockquote>
<p>参考链接：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/73468738">https://zhuanlan.zhihu.com/p/73468738 <span style="white-space: nowrap;"><svg width=".7em" height=".7em" viewBox="0 0 21 21" xmlns="http://www.w3.org/2000/svg"><path d="m13 3l3.293 3.293l-7 7l1.414 1.414l7-7L21 11V3z" fill="currentColor"></path><path d="M19 19H5V5h7l-2-2H5c-1.103 0-2 .897-2 2v14c0 1.103.897 2 2 2h14c1.103 0 2-.897 2-2v-5l-2-2v7z" fill="currentColor"></path></svg></span></a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/149581303">https://zhuanlan.zhihu.com/p/149581303 <span style="white-space: nowrap;"><svg width=".7em" height=".7em" viewBox="0 0 21 21" xmlns="http://www.w3.org/2000/svg"><path d="m13 3l3.293 3.293l-7 7l1.414 1.414l7-7L21 11V3z" fill="currentColor"></path><path d="M19 19H5V5h7l-2-2H5c-1.103 0-2 .897-2 2v14c0 1.103.897 2 2 2h14c1.103 0 2-.897 2-2v-5l-2-2v7z" fill="currentColor"></path></svg></span></a></p>
<p>阿秀网站</p>
</blockquote>
<h4 id="6-SQL-注入是什么？如何防范？"><a href="#6-SQL-注入是什么？如何防范？" class="headerlink" title="6. SQL 注入是什么？如何防范？"></a>6. SQL 注入是什么？如何防范？</h4><p><strong>SQL 注入</strong>是一种常见的安全漏洞，攻击者利用应用程序未对用户输入进行严格过滤，向数据库注入恶意SQL语句，从而获取、篡改甚至删除数据。</p>
<p><strong>常见示例：</strong></p>
<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> name <span class="operator">=</span> <span class="string">'$name'</span>;</span><br></pre></td></tr></tbody></table></figure>

<p>攻击者可能输入：</p>
<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">' OR '</span><span class="number">1</span><span class="string">'='</span><span class="number">1</span></span><br></pre></td></tr></tbody></table></figure>

<p>导致SQL语句变成：</p>
<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> name <span class="operator">=</span> <span class="string">''</span> <span class="keyword">OR</span> <span class="string">'1'</span><span class="operator">=</span><span class="string">'1'</span>;</span><br></pre></td></tr></tbody></table></figure>

<p>直接绕过认证，返回所有用户。</p>
<p><strong>预防SQL注入的措施：</strong></p>
<ul>
<li>使用<strong>预编译语句（Prepared Statement）</strong>，参数化绑定输入。</li>
<li>对输入进行严格校验与转义，避免SQL拼接。</li>
<li>数据库权限严格控制，避免高权限SQL执行。</li>
</ul>
<h4 id="7-MySQL-MVCC-机制"><a href="#7-MySQL-MVCC-机制" class="headerlink" title="7. MySQL MVCC 机制"></a>7. MySQL MVCC 机制</h4><blockquote>
<p>⚠️ 供学习：<a target="_blank" rel="noopener" href="https://tangdh.life/posts/database/duckdb-mvcc/">DuckDB —— MVCC 和增删改查 <span style="white-space: nowrap;"><svg width=".7em" height=".7em" viewBox="0 0 21 21" xmlns="http://www.w3.org/2000/svg"><path d="m13 3l3.293 3.293l-7 7l1.414 1.414l7-7L21 11V3z" fill="currentColor"></path><path d="M19 19H5V5h7l-2-2H5c-1.103 0-2 .897-2 2v14c0 1.103.897 2 2 2h14c1.103 0 2-.897 2-2v-5l-2-2v7z" fill="currentColor"></path></svg></span></a></p>
</blockquote>
<p>MVCC（多版本并发控制）是 MySQL InnoDB 引擎用于<strong>控制事务并发的一种机制</strong>，其核心思想是：</p>
<ul>
<li>每个事务读到的数据版本可能不同，事务之间无需加锁即可实现并发读取。</li>
<li>在事务修改数据时，并不会立刻删除旧数据，而是创建一个新的数据版本，旧版本的数据暂时保留，从而避免读写冲突。</li>
</ul>
<p><strong>MVCC 依赖的核心技术：</strong></p>
<ul>
<li><code>undo log</code>（回滚日志），用于版本链维护。</li>
<li>每行数据有隐藏字段（如事务 ID）记录版本信息。</li>
</ul>
<p><strong>快照读（Snapshot Read）：</strong></p>
<ul>
<li>读取的是事务开始时数据的版本快照，不会被其他事务干扰。</li>
<li>如 <code>SELECT</code> 非锁定读。</li>
</ul>
<p><strong>当前读（Current Read）：</strong></p>
<ul>
<li>会读最新版本，并锁定行，防止并发修改（如 <code>SELECT FOR UPDATE</code>）。</li>
</ul>
<h4 id="8-HTTP-和-HTTPS-区别"><a href="#8-HTTP-和-HTTPS-区别" class="headerlink" title="8. HTTP 和 HTTPS 区别"></a>8. HTTP 和 HTTPS 区别</h4><p>HTTP 和 HTTPS 的核心区别在于通信是否加密：</p>
<table>
<thead>
<tr>
<th>区别点</th>
<th>HTTP</th>
<th>HTTPS</th>
</tr>
</thead>
<tbody><tr>
<td>安全性</td>
<td>明文传输，不安全</td>
<td>使用 SSL/TLS 协议，加密传输，更安全</td>
</tr>
<tr>
<td>默认端口</td>
<td>80</td>
<td>443</td>
</tr>
<tr>
<td>身份认证</td>
<td>无认证机制</td>
<td>使用证书认证，防止中间人攻击</td>
</tr>
<tr>
<td>性能</td>
<td>快（无加密开销）</td>
<td>较慢（握手与加密开销）</td>
</tr>
<tr>
<td>应用场景</td>
<td>普通网站，不敏感数据</td>
<td>涉及登录、支付、敏感信息场景</td>
</tr>
</tbody></table>
<p><strong>HTTPS 通信过程简单描述：</strong></p>
<ol>
<li>客户端请求服务器，服务器返回公钥证书。</li>
<li>客户端校验证书有效性，生成会话密钥，用公钥加密并返回给服务器。</li>
<li>服务器解密获得会话密钥，双方以会话密钥通信。</li>
</ol>
<h4 id="9-如何查看线程堆栈（Stack）信息"><a href="#9-如何查看线程堆栈（Stack）信息" class="headerlink" title="9. 如何查看线程堆栈（Stack）信息"></a>9. 如何查看线程堆栈（Stack）信息</h4><p>在 Linux 中，有几种常用方法查看线程堆栈信息：</p>
<h5 id="方法一：使用-gdb-调试工具"><a href="#方法一：使用-gdb-调试工具" class="headerlink" title="方法一：使用 gdb 调试工具"></a>方法一：使用 gdb 调试工具</h5><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gdb -p &lt;进程ID&gt;</span><br><span class="line">thread apply all bt</span><br></pre></td></tr></tbody></table></figure>

<h5 id="方法二：使用-Linux-系统工具（pstack）"><a href="#方法二：使用-Linux-系统工具（pstack）" class="headerlink" title="方法二：使用 Linux 系统工具（pstack）"></a>方法二：使用 Linux 系统工具（pstack）</h5><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pstack &lt;进程ID&gt;</span><br></pre></td></tr></tbody></table></figure>

<h5 id="方法三：程序中主动打印堆栈"><a href="#方法三：程序中主动打印堆栈" class="headerlink" title="方法三：程序中主动打印堆栈"></a>方法三：程序中主动打印堆栈</h5><ul>
<li>如使用 <code>backtrace()</code> 系列函数。</li>
</ul>
<h5 id="常见线程堆栈大小查看"><a href="#常见线程堆栈大小查看" class="headerlink" title="常见线程堆栈大小查看"></a>常见线程堆栈大小查看</h5><p>默认情况下，线程栈大小为 8 MB，可以<strong>通过 <code>ulimit -s</code> 命令查看</strong>。</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ulimit -s  # 默认线程栈大小</span><br></pre></td></tr></tbody></table></figure>

<p>或在程序内：</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pthread_attr_t</span> attr;</span><br><span class="line"><span class="type">size_t</span> stacksize;</span><br><span class="line">pthread_attr_init(&amp;attr);</span><br><span class="line">pthread_attr_getstacksize(&amp;attr, &amp;stacksize);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"线程堆栈大小: %zu 字节\n"</span>, stacksize);</span><br></pre></td></tr></tbody></table></figure>

<p><strong>注意</strong>：线程堆栈默认大小通常为<code>8MB</code>（Linux环境），但具体依系统、配置可能有所不同。</p>
<h4 id="10-Linux-中的内核态和用户态有什么区别？"><a href="#10-Linux-中的内核态和用户态有什么区别？" class="headerlink" title="10. Linux 中的内核态和用户态有什么区别？"></a>10. Linux 中的内核态和用户态有什么区别？</h4><p>在 Linux 操作系统中，进程运行分为两个模式，即<strong>内核态（Kernel Mode）</strong> 和 <strong>用户态（User Mode）</strong>：</p>
<table>
<thead>
<tr>
<th>区别维度</th>
<th>用户态 (User Mode)</th>
<th>内核态 (Kernel Mode)</th>
</tr>
</thead>
<tbody><tr>
<td>权限级别</td>
<td>权限受限，仅能访问有限资源</td>
<td>权限最高，可访问所有资源和硬件设备</td>
</tr>
<tr>
<td>可执行指令</td>
<td>受限指令不能执行，如直接I/O操作</td>
<td>所有CPU指令均可执行，包括硬件控制指令</td>
</tr>
<tr>
<td>内存访问</td>
<td>有虚拟地址空间隔离，不能直接访问物理内存</td>
<td>可直接管理物理内存和地址空间映射</td>
</tr>
<tr>
<td>CPU 模式</td>
<td>CPU运行在非特权模式</td>
<td>CPU运行在特权模式（Ring 0）</td>
</tr>
<tr>
<td>进入方式</td>
<td>默认状态，程序启动后即为用户态</td>
<td>系统调用、异常、中断等事件进入内核态</td>
</tr>
<tr>
<td>稳定性影响</td>
<td>用户态程序崩溃不影响系统稳定性</td>
<td>内核态崩溃通常会导致系统崩溃</td>
</tr>
</tbody></table>
<h5 id="状态切换的场景"><a href="#状态切换的场景" class="headerlink" title="状态切换的场景"></a>状态切换的场景</h5><ul>
<li><strong>用户态 → 内核态：</strong><ul>
<li>程序执行<strong>系统调用</strong>（如文件读写、网络请求等）</li>
<li>发生<strong>中断</strong>或<strong>异常</strong>时也会进入内核态</li>
</ul>
</li>
<li><strong>内核态 → 用户态</strong>：<ul>
<li>系统调用处理完成，返回用户程序；</li>
<li>中断处理完成，返回被中断进程继续执行。</li>
</ul>
</li>
</ul>
<h5 id="为什么区分内核态与用户态？"><a href="#为什么区分内核态与用户态？" class="headerlink" title="为什么区分内核态与用户态？"></a>为什么区分内核态与用户态？</h5><p>这种区分主要是基于以下考虑：</p>
<ul>
<li><strong>安全性：</strong> 避免普通用户程序直接访问硬件设备或重要的内核数据，防止用户程序破坏系统。</li>
<li><strong>稳定性</strong>：用户程序崩溃不影响内核，保护整个系统稳定运行。</li>
<li><strong>权限隔离</strong>：防止恶意程序或错误程序直接损坏核心系统。</li>
</ul>
<h4 id="11-如何理解-Linux-一切皆文件｜VFS？"><a href="#11-如何理解-Linux-一切皆文件｜VFS？" class="headerlink" title="11. 如何理解 Linux 一切皆文件｜VFS？"></a>11. 如何理解 Linux 一切皆文件｜VFS？</h4><p>在 Linux 系统中，“一切皆文件” 是一个核心设计哲学，它意味着系统中的几乎所有内容都可以被看作是文件，包括常规文件、目录、设备、进程间通信等。这个设计理念有助于保持系统的一致性和灵活性，使不同类型的资源可以用相同的方式进行访问和操作。</p>
<h5 id="1-VFS-的作用"><a href="#1-VFS-的作用" class="headerlink" title="1. VFS 的作用"></a>1. VFS 的作用</h5><p>VFS 主要提供了一套通用的文件系统接口，使得用户可以无感知地操作不同类型的文件系统和设备。例如，应用程序不需要关心底层存储介质使用的是 ext4 还是 XFS，而是通过相同的系统调用（如 <code>open</code>、<code>read</code>、<code>write</code>）来访问文件。</p>
<p>VFS 的主要作用包括：</p>
<ul>
<li><strong>文件系统抽象</strong>：支持不同的物理文件系统（如 ext4、NTFS、FAT）。</li>
<li><strong>文件对象抽象</strong>：无论是普通文件、设备文件，还是管道、套接字，VFS 都用相似的方式处理。</li>
<li><strong>统一接口</strong>：提供一致的 <code>open()</code>、<code>read()</code>、<code>write()</code> 方式，使用户不需要关心底层实现。</li>
</ul>
<h5 id="2-VFS-结构"><a href="#2-VFS-结构" class="headerlink" title="2. VFS 结构"></a>2. VFS 结构</h5><p>VFS 由多个核心数据结构组成：</p>
<ul>
<li><strong>super_block</strong>：表示挂载的文件系统信息，如磁盘类型、大小等。</li>
<li><strong>inode</strong>：存储文件的元数据（如权限、大小、时间戳）。</li>
<li><strong>dentry（目录项）</strong>：表示目录和文件的路径关系，加速文件查找。</li>
<li><strong>file</strong>：表示打开的文件，包含文件描述符等信息。</li>
</ul>
<h5 id="3-VFS-如何支持“一切皆文件”"><a href="#3-VFS-如何支持“一切皆文件”" class="headerlink" title="3. VFS 如何支持“一切皆文件”"></a>3. VFS 如何支持“一切皆文件”</h5><table>
<thead>
<tr>
<th><strong>文件类型</strong></th>
<th><strong>VFS 视角</strong></th>
<th><strong>示例路径</strong></th>
</tr>
</thead>
<tbody><tr>
<td>普通文件</td>
<td><code>inode + dentry + file</code></td>
<td><code>/home/user/file.txt</code></td>
</tr>
<tr>
<td>目录</td>
<td><code>inode + dentry</code></td>
<td><code>/home/user/</code></td>
</tr>
<tr>
<td>设备文件</td>
<td>设备驱动注册为文件</td>
<td><code>/dev/sda</code>（磁盘），<code>/dev/tty</code>（终端）</td>
</tr>
<tr>
<td>进程信息</td>
<td>伪文件系统 <code>/proc</code></td>
<td><code>/proc/1234/cmdline</code></td>
</tr>
<tr>
<td>内核参数</td>
<td>伪文件系统 <code>/sys</code></td>
<td><code>/sys/class/net/eth0/</code></td>
</tr>
<tr>
<td>套接字</td>
<td>文件接口</td>
<td><code>/var/run/docker.sock</code></td>
</tr>
<tr>
<td>管道</td>
<td>通过 VFS 管理</td>
<td><code>/tmp/mypipe</code></td>
</tr>
</tbody></table>
<p>VFS 允许不同类型的文件系统（如 ext4、NFS、tmpfs）在 Linux 内核中无缝协作，同时也将设备、网络等资源抽象为文件。</p>
<h4 id="算法题-1"><a href="#算法题-1" class="headerlink" title="算法题"></a>算法题</h4><p>[1] 两数之和</p>
<h4 id="思维题"><a href="#思维题" class="headerlink" title="思维题"></a>思维题</h4><p>❓问题：一共有 64 匹马，一次只能跑 8 匹（8 个赛道），没有计时器，只能通过比赛判断相对名次。目标是选出最快的前 4 匹马，问至少需要几轮？</p>
<p>1️⃣ 第一步：分组初赛</p>
<p>首先，将 64 匹马分成 8 组，每组 8 匹。<br> 每组各进行一次比赛，一共需要 <strong>8 轮</strong> 比赛。</p>
<ul>
<li>进行到这里一共用了 8 轮。</li>
<li>每组排名确定了，但组与组之间的实力还无法确定。</li>
</ul>
<p>2️⃣ 第二步：小组冠军对决</p>
<p>将第一轮8个小组赛中的第1名放在一起，再跑一轮，共计 <strong>1轮</strong>。</p>
<ul>
<li>到此累计轮数：8轮（初赛）+ 1轮 = <strong>9轮</strong>。</li>
<li>此时确定：<ul>
<li>第9轮比赛的第1名，就是全局最快的马。</li>
<li>第9轮的结果，可以帮我们明确排除掉一些马：<ul>
<li>比如第9轮中第8名所在小组，其余7匹马都不可能进前4，因为这组冠军本身就在冠军赛中排倒数第1。</li>
<li>同理，第9轮的第7名的原始小组，其余马也不可能进入前4。</li>
<li>依此类推，还能继续排除。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>3️⃣ 第三步：确定剩余竞争马匹</p>
<p>现在仔细分析剩余可能进入前4的马匹有哪些：</p>
<ul>
<li>假设第9轮的前四名分别为：A组第1名，B组第1名，C组第1名，D组第1名（按成绩从好到差排列）。</li>
<li>第9轮比赛中：<ul>
<li><strong>第1名所在小组（A组）：A组原来的第2名、第3名、第4名都可能进入前四；</strong></li>
<li><strong>第2名所在小组（B组）：B组原来的第2名、第3名可能进入前四；</strong></li>
<li><strong>第3名所在小组（C组）：C组原来的第2名也可能进入前四；</strong></li>
<li><strong>第4名所在小组（D组）：只有冠军可能进前四，其他名次马匹绝无可能。</strong></li>
</ul>
</li>
<li>其余小组（第9轮的第5至8名所在组），其余所有马匹都不可能进前4，完全排除。</li>
</ul>
<p>因此，目前仍有可能进入前4名的马匹数量：</p>
<ul>
<li>第9轮的前四名：A1, B1, C1, D1 共4匹</li>
<li>A组的2,3,4名：3匹</li>
<li>B组的2,3名：2匹</li>
<li>C组的2名：1匹</li>
<li>D组的2-8名：0匹</li>
<li>其他组全部排除：0匹</li>
</ul>
<p>一共剩余：4（前四名）+3+2+1 = <strong>10匹</strong>。</p>
<p>但是注意：</p>
<ul>
<li>第9轮的第1名（A1）已经确认冠军，不用再跑。</li>
<li>目标是找出前四，已确认第1名，实际上仅需再明确第2、3、4名。</li>
<li><strong>所以最后一次比赛只需在剩余的10 - 1 = 9匹中选择出最快的3匹即可。</strong></li>
</ul>
<blockquote>
<p>下面的分析就是最好情况下（其中 1 匹马超过 B 即可）的次数了：10 轮</p>
<p>如果最坏情况下，还是需要多跑一轮的。</p>
</blockquote>
<p>9匹马，一轮只能跑8匹，因此显然9匹不能一轮搞定。因此必须更优化分析！</p>
<p>但是上面分析中，我们实际少算了一个关键点：</p>
<ul>
<li>实际上，第9轮第4名的马（D1）不可能在第10轮中再被后面的马超越，因为它已证明了自己比所有除ABC之外的其他小组冠军都快，且已经赛过这些剩余的其他组选手。也就是说，第9轮第4名（D1）不会被任何之前的非冠军马超过，所以不需再参与下一轮比赛，实际上可以排除。</li>
</ul>
<p>因此，重新整理一次：</p>
<ul>
<li>已经确定第1名（A1）。</li>
<li>第9轮第4名（D1）已无法被超越，无需参与最后轮次。</li>
<li>因此实际需要再比的马匹减少为8匹，正好8赛道跑一轮即可搞定：<ul>
<li>第9轮的第2名（B1），第3名（C1），需要再确认名次。</li>
<li>A组的第2、3、4名（3匹）</li>
<li>B组的第2、3名（2匹）</li>
<li>C组的第2名（1匹）</li>
</ul>
</li>
</ul>
<p>加起来正好 <strong>8匹</strong>。</p>
<p>4️⃣ 第四步：最终决赛（最后1轮）</p>
<p>将上述8匹马跑最后一轮，直接决出前4名中剩余的第2、第3、第4名。</p>
<ul>
<li>到此累计轮数：8轮（初赛）+ 1轮（冠军组赛）+ 1轮（最终确认赛）= <strong>10轮</strong>。</li>
</ul>
<p>✅ <strong>答案</strong>：最少需要 <strong>10轮</strong> 比赛</p>
<blockquote>
<p>一般来说是 11 轮。</p>
</blockquote>
<h2 id="腾讯-PCG-QQ｜后台开发-1"><a href="#腾讯-PCG-QQ｜后台开发-1" class="headerlink" title="腾讯 PCG QQ｜后台开发"></a>腾讯 PCG QQ｜后台开发</h2><blockquote>
<p>业务主要是做：<strong>推荐算法</strong>，而非 golang 开发</p>
</blockquote>
<h3 id="一面（挂）-1"><a href="#一面（挂）-1" class="headerlink" title="一面（挂）"></a>一面（挂）</h3><p>业务</p>
<ul>
<li>功能开发（CRUD）：golang</li>
<li>搜索、推荐算法、AI 落地：对性能比较高，用 C++</li>
<li>QQ 内部很多历史代码都是 C++，更要求候选人懂 C++</li>
</ul>
<h4 id="1-实习与项目拷打"><a href="#1-实习与项目拷打" class="headerlink" title="1. 实习与项目拷打"></a>1. 实习与项目拷打</h4><p>…</p>
<h4 id="‼️2-什么情况下会用到右值引用？"><a href="#‼️2-什么情况下会用到右值引用？" class="headerlink" title="‼️2. 什么情况下会用到右值引用？"></a>‼️2. 什么情况下会用到右值引用？</h4><blockquote>
<p>等价于问题：<strong>右值引用的主要用途</strong></p>
</blockquote>
<p>右值引用（<code>T&amp;&amp;</code>）主要用于实现<strong>移动语义</strong>和<strong>完美转发</strong>：</p>
<ul>
<li><p><strong>移动语义</strong>： 当一个临时对象或不再使用的资源，需要被高效地“移动”而不是拷贝时，就用到右值引用：</p>
  <figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; v1 = {<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>};</span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; v2 = std::<span class="built_in">move</span>(v1); <span class="comment">// 此时v1内容转移给v2，避免深拷贝</span></span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p><strong>完美转发</strong>： 模板中利用万能引用（forwarding reference）配合<code>std::forward</code>实现任意类型参数的原始性质传递：</p>
  <figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">wrapper</span><span class="params">(T&amp;&amp; arg)</span> </span>{</span><br><span class="line">    <span class="built_in">func</span>(std::forward&lt;T&gt;(arg));  <span class="comment">// 原样传递arg（左值传左值，右值传右值）</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>总结一下右值引用的使用场景：</p>
<ul>
<li>避免不必要的内存拷贝（提升效率）</li>
<li>转移资源所有权（移动语义）</li>
<li>模板泛型函数完美转发（提高泛型代码通用性）</li>
</ul>
</li>
</ul>
<h4 id="‼️3-move-底层原理"><a href="#‼️3-move-底层原理" class="headerlink" title="‼️3. move() 底层原理"></a>‼️3. move() 底层原理</h4><p><code>std::move()</code> 的底层原理实际上非常简单，它本身<strong>并不真正执行移动</strong>，而是一个类型转换工具，用来将<strong>左值（lvalue）强制转换为右值引用（rvalue reference）</strong>，从而允许移动语义发生。</p>
<h5 id="一、源码分析（典型实现）"><a href="#一、源码分析（典型实现）" class="headerlink" title="一、源码分析（典型实现）"></a>一、源码分析（典型实现）</h5><p>在C++标准库中，<code>std::move()</code> 一般可实现为如下模板函数：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> std::<span class="type">remove_reference_t</span>&lt;T&gt;&amp;&amp; <span class="title">move</span><span class="params">(T&amp;&amp; arg)</span> <span class="keyword">noexcept</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;std::<span class="type">remove_reference_t</span>&lt;T&gt;&amp;&amp;&gt;(arg);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>上述代码可以解析为：</p>
<ul>
<li><code>T&amp;&amp; arg</code>：这是一个<strong>万能引用</strong>（forwarding reference），能够绑定到左值或右值。</li>
<li><code>remove_reference_t&lt;T&gt;</code>：移除模板参数 <code>T</code> 可能带有的引用限定符，保证返回的确实是一个右值引用类型。</li>
<li><code>static_cast&lt;remove_reference_t&lt;T&gt;&amp;&amp;&gt;</code>：进行强制类型转换，将传入参数从左值转换为右值引用。</li>
</ul>
<h5 id="二、原理分析"><a href="#二、原理分析" class="headerlink" title="二、原理分析"></a>二、原理分析</h5><p><code>std::move()</code> 本身没有发生移动动作，它只是一个<strong>类型转换工具</strong>：</p>
<ul>
<li><strong>转换前</strong>：变量（对象）本身是<strong>左值</strong>，只能调用拷贝构造函数或拷贝赋值。</li>
<li><strong>转换后</strong>：变量变为<strong>右值引用</strong>，具备调用移动构造函数或移动赋值的资格。</li>
</ul>
<p>本质是告诉编译器：“<strong>这里的对象我不再需要了，可以放心进行资源的移动操作。</strong>”</p>
<p>例如：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::string str1 = <span class="string">"Hello"</span>;</span><br><span class="line">std::string str2 = std::<span class="built_in">move</span>(str1);  </span><br><span class="line"><span class="comment">// str1 的内容被“窃取”，str2 可能直接接管内部缓冲区，而非复制</span></span><br></pre></td></tr></tbody></table></figure>

<h5 id="三、实际的“移动”如何发生？"><a href="#三、实际的“移动”如何发生？" class="headerlink" title="三、实际的“移动”如何发生？"></a>三、实际的“移动”如何发生？</h5><p>实际的移动（资源转移）是通过被调用对象的<strong>移动构造函数</strong>或<strong>移动赋值运算符</strong>实现的，而不是通过<code>std::move()</code>实现：</p>
<p>例如，<code>std::string</code> 的移动构造函数的伪代码：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 移动构造函数示意</span></span><br><span class="line"><span class="built_in">string</span>(string&amp;&amp; other) <span class="keyword">noexcept</span> {</span><br><span class="line">    data_ = other.data_;</span><br><span class="line">    size_ = other.size_;</span><br><span class="line">    other.data_ = <span class="literal">nullptr</span>;  <span class="comment">// 原对象失去所有权</span></span><br><span class="line">    other.size_ = <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><code>std::move()</code> 提供右值引用，而真正资源转移的逻辑，由类的移动构造或移动赋值完成。</p>
<h5 id="四、注意事项"><a href="#四、注意事项" class="headerlink" title="四、注意事项"></a>四、注意事项</h5><ul>
<li><strong><code>std::move()</code>不会清空对象</strong>：<ul>
<li>调用<code>std::move()</code>后的对象处于有效但<strong>未指定状态</strong>（valid but unspecified state），通常对象变为空或默认状态。</li>
<li>你可以继续赋值或析构，但不应该继续访问对象原先的资源。</li>
</ul>
</li>
<li><strong>移动语义要求类本身支持移动构造或移动赋值</strong>：<ul>
<li>若类本身未定义移动构造或移动赋值，调用<code>std::move()</code> 仍然可能降级成拷贝。</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>问题</th>
<th>结论</th>
</tr>
</thead>
<tbody><tr>
<td><code>std::move()</code>本质是什么？</td>
<td>类型转换函数，从左值转为右值引用</td>
</tr>
<tr>
<td>真正的移动操作在哪里发生？</td>
<td>类的移动构造函数或移动赋值运算符</td>
</tr>
<tr>
<td>调用后原对象的状态？</td>
<td>有效但未指定</td>
</tr>
</tbody></table>
<p><code>std::move()</code> 本身几乎没有开销，它只是一个编译期的类型转换工具，真正的开销和行为由类型本身的移动构造和赋值函数决定。</p>
<h4 id="4-智能指针，shared-ptr-怎么实现自动管理内存？"><a href="#4-智能指针，shared-ptr-怎么实现自动管理内存？" class="headerlink" title="4. 智能指针，shared_ptr 怎么实现自动管理内存？"></a>4. 智能指针，shared_ptr 怎么实现自动管理内存？</h4><p><code>shared_ptr</code>通过<strong>引用计数（reference counting）</strong> 实现对堆内存自动管理：</p>
<p>具体实现原理：</p>
<ul>
<li><code>shared_ptr</code>内维护两个指针：<ul>
<li><strong>资源指针</strong>：指向实际对象的指针。</li>
<li><strong>引用计数指针</strong>：指向一个额外分配的计数器对象（含引用计数和弱引用计数）。</li>
</ul>
</li>
<li><strong>构造时</strong>：资源分配一次，引用计数设置为1。</li>
<li><strong>复制构造</strong>（shared_ptr之间复制）：引用计数增加1。</li>
<li><strong>析构时</strong>：<ul>
<li>引用计数减1。</li>
<li>若引用计数变为0，则自动释放资源（调用delete或自定义deleter）</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">shared_ptr</span> {</span><br><span class="line">    T* ptr;</span><br><span class="line">    <span class="type">size_t</span>* ref_count;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">shared_ptr</span><span class="params">(T* p = <span class="literal">nullptr</span>)</span></span></span><br><span class="line"><span class="function">      : ptr(p), ref_count(new size_t(p ? <span class="number">1</span> : <span class="number">0</span>)) {</span>}</span><br><span class="line"></span><br><span class="line">    <span class="built_in">shared_ptr</span>(<span class="type">const</span> shared_ptr&amp; other)</span><br><span class="line">      : <span class="built_in">ptr</span>(other.ptr), <span class="built_in">ref_count</span>(other.ref_count) {</span><br><span class="line">        <span class="keyword">if</span> (ptr) (*ref_count)++;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">shared_ptr</span>() {</span><br><span class="line">        <span class="keyword">if</span> (ptr &amp;&amp; --(*ref_count) == <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">delete</span> ptr;</span><br><span class="line">            <span class="keyword">delete</span> ref_count;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<h4 id="5-shared-ptr-下的多线程问题"><a href="#5-shared-ptr-下的多线程问题" class="headerlink" title="5. shared_ptr 下的多线程问题"></a>5. shared_ptr 下的多线程问题</h4><p><code>shared_ptr</code>对<strong>引用计数本身是线程安全的</strong>（C++11起）：</p>
<ul>
<li>同一个<code>shared_ptr</code>的多个拷贝对象，在多个线程并发调用拷贝构造、赋值、析构时，不需要额外同步保护。</li>
</ul>
<p><strong>但对shared_ptr指向对象的访问本身并不保证线程安全</strong>：</p>
<ul>
<li>如果多个线程访问同一个对象资源时，需要额外的锁机制保护资源本身：</li>
</ul>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">std::shared_ptr&lt;MyObject&gt; sp = std::<span class="built_in">make_shared</span>&lt;MyObject&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// OK：引用计数线程安全</span></span><br><span class="line"><span class="keyword">auto</span> sp2 = sp; <span class="comment">// 并发安全，无需锁</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 需要额外保护：</span></span><br><span class="line">sp-&gt;<span class="built_in">modify</span>();  <span class="comment">// 若多个线程调用modify，必须额外加锁保护</span></span><br></pre></td></tr></tbody></table></figure>

<p>简单总结：</p>
<table>
<thead>
<tr>
<th>行为</th>
<th>是否线程安全？</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>引用计数自身</td>
<td>是</td>
<td>内部使用原子操作</td>
</tr>
<tr>
<td>对象访问</td>
<td>否</td>
<td>需自行实现同步</td>
</tr>
</tbody></table>
<h4 id="6-GCC-编译流程"><a href="#6-GCC-编译流程" class="headerlink" title="6. GCC 编译流程"></a>6. GCC 编译流程</h4><blockquote>
<p>预处理、编译、汇编、链接</p>
</blockquote>
<p>GCC的编译过程大致分四步：</p>
<ol>
<li><strong>预处理（Preprocessing）</strong>：<ul>
<li>处理宏定义、条件编译、头文件展开。</li>
<li>命令示例：<code>gcc -E main.c -o main.i</code></li>
</ul>
</li>
<li><strong>编译（Compilation）</strong>：<ul>
<li>将预处理后的代码（<code>.i</code>文件）编译成汇编语言（<code>.s</code>文件）。</li>
<li>命令示例：<code>gcc -S main.i -o main.s</code></li>
</ul>
</li>
<li><strong>汇编（Assembly）</strong>：<ul>
<li>汇编代码转成二进制目标文件（<code>.o</code>文件）。</li>
<li>命令示例：<code>gcc -c main.s -o main.o</code></li>
</ul>
</li>
<li><strong>链接（Linking）</strong>：<ul>
<li>将一个或多个目标文件（<code>.o</code>）链接，合并成最终的可执行程序（a.out或其他指定文件名）。</li>
<li>命令示例：<code>gcc main.o -o main</code></li>
</ul>
</li>
</ol>
<h4 id="7-可执行文件加载到内存里，其内存布局是怎样的？"><a href="#7-可执行文件加载到内存里，其内存布局是怎样的？" class="headerlink" title="7. 可执行文件加载到内存里，其内存布局是怎样的？"></a>7. 可执行文件加载到内存里，其内存布局是怎样的？</h4><p>当可执行文件（如Linux ELF格式）加载到内存中运行时，其典型内存布局为：</p>
<p>从低地址到高地址顺序：</p>
<table>
<thead>
<tr>
<th>内存段</th>
<th>功能说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>代码段（text segment）</strong></td>
<td>存放程序的机器指令（只读、可执行）</td>
</tr>
<tr>
<td><strong>数据段（data segment）</strong></td>
<td>已初始化的全局变量和静态变量</td>
</tr>
<tr>
<td><strong>BSS段（bss segment）</strong></td>
<td>未初始化或初值为零的全局变量和静态变量</td>
</tr>
<tr>
<td><strong>堆（Heap）</strong></td>
<td>动态分配的内存（由低地址向高地址增长）</td>
</tr>
<tr>
<td>↕️</td>
<td>（动态增长空间）</td>
</tr>
<tr>
<td><strong>栈（Stack）</strong></td>
<td>函数调用栈帧（由高地址向低地址增长）</td>
</tr>
</tbody></table>
<p>具体示意图：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">+-----------------------------+ 高地址</span><br><span class="line">|          栈 Stack            |</span><br><span class="line">|           ↓ 向下增长         |</span><br><span class="line">|                             |</span><br><span class="line">|                             |</span><br><span class="line">|           ↑ 向上增长         |</span><br><span class="line">|          堆 Heap             |</span><br><span class="line">+-----------------------------+</span><br><span class="line">|   未初始化数据 BSS (.bss)    |</span><br><span class="line">+-----------------------------+</span><br><span class="line">| 初始化数据 Data (.data)      |</span><br><span class="line">+-----------------------------+</span><br><span class="line">|    代码段 Text (.text)       |</span><br><span class="line">+-----------------------------+ 低地址</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li><strong>代码段</strong>：函数指令</li>
<li><strong>数据段</strong>：全局或静态变量（初值不为0）</li>
<li><strong>BSS段</strong>：全局或静态变量（初值为0或未初始化）</li>
<li><strong>堆段</strong>：动态内存（malloc/new）</li>
<li><strong>栈段</strong>：函数调用的局部变量、调用返回地址、临时变量等</li>
</ul>
<h4 id="算法题：手撕-LRU"><a href="#算法题：手撕-LRU" class="headerlink" title="算法题：手撕 LRU"></a>算法题：手撕 LRU</h4><p>LeetCode LRU 缓存：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/lru-cache/description/">https://leetcode.cn/problems/lru-cache/description/ <span style="white-space: nowrap;"><svg width=".7em" height=".7em" viewBox="0 0 21 21" xmlns="http://www.w3.org/2000/svg"><path d="m13 3l3.293 3.293l-7 7l1.414 1.414l7-7L21 11V3z" fill="currentColor"></path><path d="M19 19H5V5h7l-2-2H5c-1.103 0-2 .897-2 2v14c0 1.103.897 2 2 2h14c1.103 0 2-.897 2-2v-5l-2-2v7z" fill="currentColor"></path></svg></span></a></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> {</span><br><span class="line">    <span class="type">int</span> key;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    Node* prev;</span><br><span class="line">    Node* next;</span><br><span class="line">    <span class="built_in">Node</span>(<span class="type">int</span> k = <span class="number">0</span>, <span class="type">int</span> v = <span class="number">0</span>) : <span class="built_in">key</span>(k), <span class="built_in">value</span>(v) {}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LRUCache</span> {</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Node* dummy;</span><br><span class="line">    <span class="type">int</span> capacity;</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, Node*&gt; key_to_node;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(Node* node)</span> </span>{</span><br><span class="line">        node-&gt;prev-&gt;next = node-&gt;next;</span><br><span class="line">        node-&gt;next-&gt;prev = node-&gt;prev;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push_front</span><span class="params">(Node* node)</span> </span>{</span><br><span class="line">        node-&gt;prev = dummy;</span><br><span class="line">        node-&gt;next = dummy-&gt;next;</span><br><span class="line">        dummy-&gt;next-&gt;prev = node;</span><br><span class="line">        dummy-&gt;next = node;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function">Node* <span class="title">get_node</span><span class="params">(<span class="type">int</span> key)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (!key_to_node.<span class="built_in">count</span>(key)) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        }</span><br><span class="line">        Node* node = key_to_node[key];</span><br><span class="line">        <span class="built_in">remove</span>(node);</span><br><span class="line">        <span class="built_in">push_front</span>(node);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">LRUCache</span>(<span class="type">int</span> capacity) : <span class="built_in">capacity</span>(capacity) {</span><br><span class="line">        dummy = <span class="keyword">new</span> <span class="built_in">Node</span>();</span><br><span class="line">        dummy-&gt;next = dummy;</span><br><span class="line">        dummy-&gt;prev = dummy;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> key)</span> </span>{</span><br><span class="line">        Node* node = <span class="built_in">get_node</span>(key);</span><br><span class="line">        <span class="keyword">return</span> node ? node-&gt;value : <span class="number">-1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> </span>{</span><br><span class="line">        Node* node = <span class="built_in">get_node</span>(key);</span><br><span class="line">        <span class="keyword">if</span> (node) {</span><br><span class="line">            node-&gt;value = value;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        node = <span class="keyword">new</span> <span class="built_in">Node</span>(key, value);</span><br><span class="line">        <span class="keyword">if</span> (key_to_node.<span class="built_in">size</span>() == capacity) {</span><br><span class="line">            Node* last = dummy-&gt;prev;</span><br><span class="line">            key_to_node.<span class="built_in">erase</span>(last-&gt;key);</span><br><span class="line">            <span class="built_in">remove</span>(last);</span><br><span class="line">            <span class="keyword">delete</span> last;</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">push_front</span>(node);</span><br><span class="line">        key_to_node[key] = node;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your LRUCache object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * LRUCache* obj = new LRUCache(capacity);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;get(key);</span></span><br><span class="line"><span class="comment"> * obj-&gt;put(key,value);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></tbody></table></figure>

<h2 id="快手深广搜｜C-开发"><a href="#快手深广搜｜C-开发" class="headerlink" title="快手深广搜｜C++ 开发"></a>快手深广搜｜C++ 开发</h2><h3 id="一面（挂）-2"><a href="#一面（挂）-2" class="headerlink" title="一面（挂）"></a>一面（挂）</h3><h4 id="算法题：合并-K-个有序链表"><a href="#算法题：合并-K-个有序链表" class="headerlink" title="算法题：合并 K 个有序链表"></a>算法题：合并 K 个有序链表</h4><p>LeetCode: <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/merge-k-sorted-lists/description/">https://leetcode.cn/problems/merge-k-sorted-lists/description/ <span style="white-space: nowrap;"><svg width=".7em" height=".7em" viewBox="0 0 21 21" xmlns="http://www.w3.org/2000/svg"><path d="m13 3l3.293 3.293l-7 7l1.414 1.414l7-7L21 11V3z" fill="currentColor"></path><path d="M19 19H5V5h7l-2-2H5c-1.103 0-2 .897-2 2v14c0 1.103.897 2 2 2h14c1.103 0 2-.897 2-2v-5l-2-2v7z" fill="currentColor"></path></svg></span></a></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(vector&lt;ListNode*&gt;&amp; lists)</span> </span>{</span><br><span class="line">        <span class="keyword">auto</span> cmp = [](<span class="type">const</span> ListNode* a, <span class="type">const</span> ListNode* b) {</span><br><span class="line">            <span class="keyword">return</span> a-&gt;val &gt; b-&gt;val;</span><br><span class="line">        };</span><br><span class="line">        priority_queue&lt;ListNode*, vector&lt;ListNode*&gt;, <span class="keyword">decltype</span>(cmp)&gt; pq;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> head : lists) {</span><br><span class="line">            <span class="keyword">if</span> (head) {</span><br><span class="line">                pq.<span class="built_in">push</span>(head);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        ListNode dummy{};</span><br><span class="line">        ListNode* cur = &amp;dummy;</span><br><span class="line">        <span class="keyword">while</span> (!pq.<span class="built_in">empty</span>()) {</span><br><span class="line">            ListNode* nxt = pq.<span class="built_in">top</span>();</span><br><span class="line">            pq.<span class="built_in">pop</span>();</span><br><span class="line">            cur-&gt;next = nxt;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (nxt-&gt;next) {</span><br><span class="line">                pq.<span class="built_in">push</span>(nxt-&gt;next);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>时间复杂度</p>
</blockquote>
<p>在使用最小堆（或优先队列）合并 K 个升序链表时，时间复杂度主要由以下两个部分组成：</p>
<ol>
<li><strong>初始化最小堆</strong>：将 K 个链表的头节点插入最小堆中。由于每次插入操作的时间复杂度为 O(logK)，因此这一步的总时间复杂度为 O(K logK)。</li>
<li><strong>合并过程</strong>：在合并的过程中，需要进行 N 次插入和删除操作，其中 N 是所有链表节点的总数。每次插入和删除操作的时间复杂度均为 O(logK)，因此这部分的总时间复杂度为 O(N logK)。</li>
</ol>
<p>综上，使用最小堆合并 K 个升序链表的总体时间复杂度为 $O(N logK)$。这种方法的优势在于利用最小堆高效地获取当前最小的节点，从而在合并过程中保持链表的有序性。</p>
<blockquote>
<p>顺便复习下「堆排序」</p>
</blockquote>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 调整堆，使以 start 为根的子树满足最大堆性质</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">maxHeapify</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> start, <span class="type">int</span> end)</span> </span>{</span><br><span class="line">    <span class="type">int</span> dad = start;</span><br><span class="line">    <span class="type">int</span> son = dad * <span class="number">2</span> + <span class="number">1</span>; <span class="comment">// 左子节点索引</span></span><br><span class="line">    <span class="keyword">while</span> (son &lt;= end) {   <span class="comment">// 确保子节点在范围内</span></span><br><span class="line">        <span class="keyword">if</span> (son + <span class="number">1</span> &lt;= end &amp;&amp; arr[son] &lt; arr[son + <span class="number">1</span>]) <span class="comment">// 选择较大的子节点</span></span><br><span class="line">            son++;</span><br><span class="line">        <span class="keyword">if</span> (arr[dad] &gt; arr[son]) <span class="comment">// 如果父节点大于子节点，则调整完毕</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">else</span> { <span class="comment">// 交换父子节点</span></span><br><span class="line">            std::<span class="built_in">swap</span>(arr[dad], arr[son]);</span><br><span class="line">            dad = son;</span><br><span class="line">            son = dad * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 堆排序主函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heapSort</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt;&amp; arr)</span> </span>{</span><br><span class="line">    <span class="type">int</span> len = arr.<span class="built_in">size</span>();</span><br><span class="line">    <span class="comment">// 构建最大堆</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = len / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        <span class="built_in">maxHeapify</span>(arr, i, len - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 进行排序</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = len - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) {</span><br><span class="line">        std::<span class="built_in">swap</span>(arr[<span class="number">0</span>], arr[i]);      <span class="comment">// 将最大值交换到数组末尾</span></span><br><span class="line">        <span class="built_in">maxHeapify</span>(arr, <span class="number">0</span>, i - <span class="number">1</span>);      <span class="comment">// 重新调整堆</span></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; arr = {<span class="number">3</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">4</span>};</span><br><span class="line">    <span class="built_in">heapSort</span>(arr);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : arr)</span><br><span class="line">        std::cout &lt;&lt; num &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="项目问题"><a href="#项目问题" class="headerlink" title="项目问题"></a>项目问题</h4><ul>
<li>应用场景？</li>
<li>ART 索引的优势？</li>
<li>考虑 PM 成本？</li>
</ul>
<h2 id="Vivo-C-C-嵌入式开发"><a href="#Vivo-C-C-嵌入式开发" class="headerlink" title="Vivo C/C++ 嵌入式开发"></a>Vivo C/C++ 嵌入式开发</h2><h3 id="一面（挂）-3"><a href="#一面（挂）-3" class="headerlink" title="一面（挂）"></a>一面（挂）</h3><ol>
<li><p>介绍你的项目和实习</p>
<ol>
<li>就问 OPPO 项目几个问题而已</li>
</ol>
</li>
<li><p><strong>怎么优化系统性能</strong></p>
<ol>
<li>合理使用缓存机制，如内存缓存、Redis 等</li>
<li>利用多线程或多进程技术，让更多的处理器核心参与计算，提升吞吐量</li>
<li>选择高效的算法和数据结构可以显著提升系统性能</li>
<li>编写高质量的代码，避免冗余计算，减少函数调用和内存分配，合理使用同步和异步操作</li>
<li>采用集群等高可用架构，避免单点故障，确保系统在高负载下仍能稳定运行</li>
<li>负载均衡，通过将请求分配到多台服务器上，避免单一服务器的性能瓶颈</li>
<li>使用消息队列实现高并发下的异步处理，削峰填谷，缓解系统压力</li>
<li><code>perf</code> 工具查看系统性能瓶颈</li>
<li>开启编译优化 <code>-O2</code>、<code>-O3</code></li>
</ol>
</li>
<li><p>C++ 多态怎么实现：静态多态（重载，模板）、动态多态（继承与虚函数）</p>
</li>
<li><p>C++11 新特性有哪些？</p>
<ol>
<li>auto 变量自动类型推导、decltype 表达式自动类型推导</li>
<li>lambda</li>
<li>智能指针</li>
<li>move</li>
<li>右值引用</li>
<li>final、override</li>
<li>模板</li>
<li>nullptr 取代 NULL</li>
<li>constexpr</li>
<li>delete</li>
<li>范围 for 循环</li>
<li>列表初始化</li>
<li>…</li>
</ol>
</li>
<li><p><strong>C++ class 和 C struct 的区别</strong></p>
<ol>
<li>默认权限：C struct public、C++ class private；同时 C 语言中不支持继承和多态</li>
</ol>
</li>
<li><p>嵌入式系统的特点</p>
</li>
<li><p>工作中遇到复杂的问题，如何解决</p>
</li>
</ol>
<p>反问：校招生没有嵌入式经验，会排斥吗</p>
<h2 id="腾讯-CSIG-腾讯云｜后台开发"><a href="#腾讯-CSIG-腾讯云｜后台开发" class="headerlink" title="腾讯 CSIG 腾讯云｜后台开发"></a>腾讯 CSIG 腾讯云｜后台开发</h2><h3 id="一面（挂）-4"><a href="#一面（挂）-4" class="headerlink" title="一面（挂）"></a>一面（挂）</h3><h4 id="1-操作系统中对于物理内存是怎么做管理的？"><a href="#1-操作系统中对于物理内存是怎么做管理的？" class="headerlink" title="1. 操作系统中对于物理内存是怎么做管理的？"></a>1. 操作系统中对于物理内存是怎么做管理的？</h4><p>操作系统设计了虚拟内存，每个进程都有自己的独立的虚拟内存，我们所写的程序不会直接与物理内存打交道。</p>
<p>有了虚拟内存之后，它带来了这些好处：</p>
<ul>
<li>第一，虚拟内存可以使得进程对运行内存超过物理内存大小，因为程序运行符合局部性原理，CPU 访问内存会有很明显的重复访问的倾向性，对于那些没有被经常使用到的内存，我们可以把它换出到物理内存之外，比如硬盘上的 swap 区域。</li>
<li>第二，由于每个进程都有自己的页表，所以每个进程的虚拟内存空间就是相互独立的。进程也没有办法访问其他进程的页表，所以这些页表是私有的，这就解决了多进程之间地址冲突的问题。</li>
<li>第三，页表里的页表项中除了物理地址之外，还有一些标记属性的比特，比如控制一个页的读写权限，标记该页是否存在等。在内存访问方面，操作系统提供了更好的安全性。</li>
</ul>
<p>Linux 是通过对内存分页的方式来管理内存，分页是把整个虚拟和物理内存空间切成一段段固定尺寸的大小。这样一个连续并且尺寸固定的内存空间，我们叫页（Page）。在 Linux 下，每一页的大小为 4KB。</p>
<blockquote>
<p>最初的内存管理采用<strong>固定分区</strong>或<strong>可变分区</strong>（最先适应分配算法、最优适应分配算法、最坏适应分配算法…）</p>
<p>之后才出现了分页、分段，与分区方式互斥</p>
</blockquote>
<p>虚拟地址与物理地址之间通过页表来映射，如下图：</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/Wu-yikun/OSS/PicGo/202503282159068.png" alt="img"></p>
<p>页表是存储在内存里的，内存管理单元 （MMU）就做将虚拟内存地址转换成物理地址的工作。</p>
<p>而当进程访问的虚拟地址在页表中查不到时，系统会产生一个<strong>缺页异常</strong>，进入系统内核空间分配物理内存、更新进程页表，最后再返回用户空间，恢复进程的运行。缺页异常会触发</p>
<h4 id="2-C-程序有一个全局变量，同时起两个进程跑，该全局变量的地址会一样吗？"><a href="#2-C-程序有一个全局变量，同时起两个进程跑，该全局变量的地址会一样吗？" class="headerlink" title="2. C++ 程序有一个全局变量，同时起两个进程跑，该全局变量的地址会一样吗？"></a>2. C++ 程序有一个全局变量，同时起两个进程跑，该全局变量的地址会一样吗？</h4><blockquote>
<p>应该是考进程间的隔离性</p>
</blockquote>
<p><strong>不会一样</strong>：即虚拟地址可能一样（如果内存布局完全相同），但是物理地址一定不一样。</p>
<p>具体来说：</p>
<ul>
<li><p><strong>进程地址空间独立性</strong>： 每个进程都有自己独立的虚拟地址空间。同一个程序启动两次，实际上创建了两个不同的进程，每个进程都有各自的独立地址空间。因此，尽管程序本身是一样的，但两个进程里的全局变量地址是在它们各自的虚拟地址空间里分配的，地址可以看起来相同（因为虚拟地址的布局通常一样），但实际上对应不同的物理内存。</p>
</li>
<li><p><strong>物理地址不同</strong>： 虽然可能两个进程中相同的变量虚拟地址看起来是一样的（比如在 Linux 中经常全局变量起始地址会是相似的，例如 <code>0x601040</code>），但实际上操作系统的内存管理机制会通过页表将相同虚拟地址映射到完全不同的物理内存上。</p>
</li>
<li><p><strong>举例说明</strong>： 比如你定义了一个全局变量：</p>
  <figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> global_var = <span class="number">10</span>;</span><br></pre></td></tr></tbody></table></figure>

<p>  编译运行程序两次，会创建两个不同的进程，比如进程A、进程B。</p>
<ul>
<li>进程A里：<code>&amp;global_var</code> = <code>0x601040</code>（虚拟地址）</li>
<li>进程B里：<code>&amp;global_var</code> = <code>0x601040</code>（虚拟地址）</li>
</ul>
<p>  表面上看起来一样，但它们实际上分别映射到不同的物理页中，实际在内存中的位置并不相同，彼此不会产生冲突。</p>
</li>
</ul>
<h4 id="3-1G-物理内存，代码中申请-2G-内存块（malloc），同时起两个进程会发生什么？"><a href="#3-1G-物理内存，代码中申请-2G-内存块（malloc），同时起两个进程会发生什么？" class="headerlink" title="3. 1G 物理内存，代码中申请 2G 内存块（malloc），同时起两个进程会发生什么？"></a>3. 1G 物理内存，代码中申请 2G 内存块（malloc），同时起两个进程会发生什么？</h4><blockquote>
<p>这是一个经典的面试问题，背后涉及<strong>虚拟内存管理</strong>、<strong>内存映射机制</strong>和<strong>缺页异常</strong>的知识。</p>
<p>简而言之：如果【物理内存 + Swap 分区】小于申请的内存大小，那么就有可能发生 OOM（假设没法回收旧页面），因为虚拟内存 = 物理内存 + Swap 分区大小</p>
</blockquote>
<ul>
<li>物理内存（RAM）：1 GB</li>
<li>进程尝试申请：4 GB 内存</li>
<li>假设系统启用了 <strong>Swap</strong>，比如还有 2 GB 的 Swap 空间</li>
<li>问题是：<strong>还会发生 OOM 吗？</strong></li>
</ul>
<p><strong>Linux 默认允许 overcommit</strong>，也就是说，即使系统没有足够物理内存+Swap，也可能“允许”你申请 4GB。但是等到真正**使用那块内存（写入）**的时候，系统发现分配不出来，就会发生 <strong>OOM</strong>。</p>
<p>你有 1GB RAM + 2GB Swap = <strong>3GB 实际可用虚拟内存</strong>。你请求了 4GB -&gt; 系统<strong>可能</strong>允许你分配，但<strong>用到第 3GB 时，系统发现真没空间了</strong>。</p>
<p>📛 此时如果：</p>
<ul>
<li>没有更多 Swap；</li>
<li>没法换出其他内存页；</li>
<li>系统无法通过页面回收等手段分配新内存；</li>
</ul>
<p>→ 就会触发 <strong>OOM</strong>，并且 Linux 会启用 <strong>OOM Killer</strong> 杀掉你进程，避免系统崩溃。</p>
<p>你是“申请”还是“实际写入”？这个差别很关键！</p>
<ul>
<li><strong>malloc / new 只是申请</strong>，系统可能只是“画个圈”，并没有真的分配物理页（lazy allocation）；</li>
<li><strong>只有当你写入内存时</strong>（触发页缺失），系统才真正分配页框，如果那时分配失败，才会 OOM。</li>
</ul>
<p>总结：</p>
<ul>
<li>你真的“写满”了这 4GB 内存；</li>
<li>而系统的 RAM + Swap 不足以支撑；</li>
<li>并且系统不能释放或交换出其他内存页；</li>
</ul>
<p>那么最终还是会触发 OOM。</p>
<h4 id="4-对于这两个进程-malloc-出来的内存块首地址会不会一样？"><a href="#4-对于这两个进程-malloc-出来的内存块首地址会不会一样？" class="headerlink" title="4. 对于这两个进程 malloc 出来的内存块首地址会不会一样？"></a>4. 对于这两个进程 malloc 出来的内存块首地址会不会一样？</h4><p>可能一样，也可能不一样，具体取决于操作系统和内存分配策略，但在大多数现代操作系统（比如 Linux）中，这两个进程 <code>malloc</code> 得到的内存块首地址通常是一样的。</p>
<p>为什么通常会一样？</p>
<ul>
<li><p><strong>虚拟地址空间独立</strong>： 每个进程拥有独立的虚拟地址空间，因此两个进程可以有相同的虚拟地址，彼此之间不会冲突。这种机制叫<strong>虚拟地址空间隔离</strong>。</p>
</li>
<li><p><strong>操作系统的内存映射规则</strong>： 现代操作系统（特别是 Linux）常使用相似的内存布局策略：</p>
<ul>
<li><p>例如 Linux 下程序启动后的虚拟地址空间布局几乎一致：</p>
  <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">栈空间（高地址）</span><br><span class="line">↓</span><br><span class="line">堆空间（malloc/brk 向上增长）</span><br><span class="line">↓</span><br><span class="line">数据段/BSS段</span><br><span class="line">↓</span><br><span class="line">代码段</span><br><span class="line">↓</span><br><span class="line">操作系统内核（低地址）</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<p>  因此，两个进程几乎同时启动后，其虚拟地址布局极为类似，两者用 <code>malloc</code> 申请的内存，很可能分配到同样的虚拟地址上。</p>
</li>
</ul>
<p>虽然虚拟地址相同，但<strong>物理地址不同</strong>。每个进程的内存映射到不同的物理内存页，保证了进程间的内存隔离。</p>
<p>并不是100%一样，但一般来说非常常见：</p>
<ul>
<li>如果内存布局完全相同（相同的程序、相同的运行环境、几乎同时启动），虚拟地址往往相同。</li>
<li>如果出现地址随机化（如 ASLR 技术打开），地址可能稍微不同。</li>
</ul>
<h4 id="5-进程进行了一次-read-操作，请你说一下这个过程？"><a href="#5-进程进行了一次-read-操作，请你说一下这个过程？" class="headerlink" title="5. 进程进行了一次 read 操作，请你说一下这个过程？"></a>5. 进程进行了一次 read 操作，请你说一下这个过程？</h4><blockquote>
<p>🔥 追加问题：</p>
<ul>
<li>1️⃣ 用户态转换为内核态，细节一些，怎么转的？</li>
<li>2️⃣ 我就写了个 read，也没写其他东西，他是怎么调用内核代码的？</li>
<li>3️⃣ 你有办法在用户态写代码去读文件吗，不调用库函数的情况下？<ul>
<li>不用标准库，只用 syscall，你可以<strong>不调用 glibc 的 <code>read()</code></strong>，而是<strong>自己写 syscall 汇编代码</strong>来触发系统调用</li>
<li>用户态 I/O 提供了 UIO，</li>
</ul>
</li>
<li>4️⃣ 或者你认为底层在读写文件时实际上在操作什么东西？<ul>
<li>实际上，文件描述符只是用户态的一个索引，它指向内核中的 file 结构。而真正底层在操作的是文件系统定位出的磁盘块，通过驱动发起 DMA（DMA 控制器来搬运数据），把这些块从硬件搬到内存的页缓存中。所以底层操作的实际是设备上的数据块，而不是文件描述符本身。</li>
</ul>
</li>
<li>5️⃣ 最后怎么让你的硬件设备把文件弄到内存里？<ul>
<li>通过系统调用，触发内核层级联动，最终驱动告诉 DMA 控制器去读磁盘扇区，把数据搬到内存中。</li>
</ul>
</li>
</ul>
</blockquote>
<blockquote>
<p>程序的内存分布，其中包括内核空间（在内存中），联想一下即可理解。</p>
</blockquote>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/Wu-yikun/OSS/PicGo/202503290041746.png" alt="image-20240725233029022"></p>
<h5 id="read-操作全流程"><a href="#read-操作全流程" class="headerlink" title="read 操作全流程"></a>read 操作全流程</h5><p>一、进程发起 read 调用</p>
<p>用户态进程想要从文件、管道、网络套接字、或设备中读取数据时，通常会调用系统调用（<code>read()</code>）：</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">read</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *buf, <span class="type">size_t</span> count)</span>;</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>进程将准备好参数：<ul>
<li>文件描述符 <code>fd</code>（指明从哪里读）</li>
<li>缓冲区指针 <code>buf</code>（读入到哪里）</li>
<li>读取字节数 <code>count</code>（读入多少）</li>
</ul>
</li>
</ul>
<p>二、用户态到内核态的切换（陷入内核）</p>
<ul>
<li>调用<code>read</code>函数后，<strong>C库(glibc)</strong> 会触发一个CPU陷入内核（trap）操作：<ul>
<li>具体实现一般是通过<code>syscall</code>指令或中断机制（例如<code>int 0x80</code>或<code>sysenter/syscall</code>指令）。</li>
</ul>
</li>
<li>CPU权限级别从用户态（ring3）切换到内核态（ring0）。</li>
<li>内核从用户态堆栈取出系统调用号（表示<code>read</code>）和参数。</li>
</ul>
<p>此时进入内核态。</p>
<p>三、内核态的系统调用处理流程</p>
<p>进入内核后，系统调用处理例程开始运行：</p>
<ol>
<li><strong>保存上下文</strong>：内核会保存用户态的寄存器环境到内核堆栈，以便调用结束后能够恢复用户态现场。</li>
<li><strong>参数检查和解析</strong><ul>
<li>检查文件描述符（<code>fd</code>）是否有效。</li>
<li>检查缓冲区地址<code>buf</code>是否是合法用户空间地址。</li>
<li>检查读取的字节数是否合理（不能超过系统限制等）。</li>
</ul>
</li>
<li><strong>根据文件描述符找到内核文件结构</strong><ul>
<li>内核根据<code>fd</code>从进程的文件描述符表中找到对应的文件结构（file结构）。</li>
<li>根据文件结构再找到具体的设备或文件的操作方法集（file_operations结构）。</li>
</ul>
</li>
</ol>
<p>四、具体数据的读取操作</p>
<p>内核确定文件类型后，调用具体设备或文件系统的<code>read</code>函数。</p>
<ul>
<li><strong>如果是普通文件：</strong><ul>
<li>内核从进程对应的文件偏移位置（file position）开始，调用文件系统的<code>read</code>方法，从文件缓存（page cache）或磁盘读取数据。</li>
<li>如果数据不在内存（Page Cache 是 Linux 内核用来缓存磁盘文件内容的一块内存区域），就会触发页面缓存缺页：<ul>
<li>内核调用磁盘驱动程序，通过DMA方式把数据从磁盘读入内存缓存。</li>
<li>进程会进入阻塞状态，等待数据从磁盘读入内存完成。</li>
<li>DMA完成后产生磁盘I/O中断，唤醒进程继续执行。</li>
</ul>
</li>
<li>内核将数据从内核缓冲区（page cache）拷贝到用户空间提供的缓冲区<code>buf</code>中。</li>
</ul>
</li>
<li><strong>如果是网络socket或管道等：</strong><ul>
<li>内核检查管道或socket缓冲区是否已有数据。</li>
<li>如果没有数据，进程通常阻塞在<code>wait queue</code>（等待队列）上，等待数据到达。</li>
<li>数据到达后，内核再将数据从内核态缓冲区拷贝到用户态缓冲区。</li>
</ul>
</li>
</ul>
<p>五、内核态到用户态的返回（返回用户态）</p>
<ul>
<li>数据拷贝完成，系统调用返回时：<ul>
<li>内核将读取到的字节数返回给调用进程（作为<code>read</code>返回值）。</li>
<li>如果读取出错，则返回负数并设置对应的错误码（<code>errno</code>）。</li>
</ul>
</li>
<li>内核恢复之前保存的用户态寄存器上下文。</li>
<li>CPU从内核态返回用户态（通过<code>iret</code>、<code>sysret</code>等特殊指令），进程恢复执行。</li>
</ul>
<h5 id="如何在不调用库函数的情况下，对硬件设备进行读写？"><a href="#如何在不调用库函数的情况下，对硬件设备进行读写？" class="headerlink" title="如何在不调用库函数的情况下，对硬件设备进行读写？"></a>如何在不调用库函数的情况下，对硬件设备进行读写？</h5><p>👉 <strong>可以不调用标准库函数（如<code>read</code>、<code>fread</code>），但</strong>：</p>
<ul>
<li>你<strong>不能绕过系统调用本身</strong>。</li>
<li>因为 <strong>读文件必须依赖内核提供的能力（文件系统访问、设备 I/O）</strong>，这些都是<strong>用户态无法直接访问的</strong>。</li>
</ul>
<p>方法一：不用标准库，只用 syscall，你可以<strong>不调用 glibc 的 <code>read()</code></strong>，而是<strong>自己写 syscall 汇编代码</strong>来触发系统调用：</p>
<blockquote>
<p>示例（x86_64 Linux 下）</p>
</blockquote>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> {</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// open 文件</span></span><br><span class="line">    <span class="type">int</span> fd = syscall(SYS_open, <span class="string">"test.txt"</span>, O_RDONLY);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读文件</span></span><br><span class="line">    <span class="type">long</span> n = syscall(SYS_read, fd, buf, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写到 stdout</span></span><br><span class="line">    syscall(SYS_write, <span class="number">1</span>, buf, n);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭文件</span></span><br><span class="line">    syscall(SYS_close, fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>🔸这里你<strong>没用 <code>read()</code>、<code>open()</code> 等库函数，完全绕过了 glibc，只用 <code>syscall</code></strong>。</p>
</blockquote>
<p>底层其实还是通过 <code>syscall</code> 指令陷入内核，所以你仍然走的是： <strong>用户态 → 内核态 → 文件系统 → 块设备 → 驱动 → 硬件</strong> 这条链路。</p>
<p>方法二：手写汇编 <code>syscall</code>（进一步硬核）</p>
<p>你甚至可以直接写汇编触发 <code>syscall</code>：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mov rax, 0          ; SYS_read</span><br><span class="line">mov rdi, fd         ; 参数1: 文件描述符</span><br><span class="line">mov rsi, buf        ; 参数2: 缓冲区</span><br><span class="line">mov rdx, 100        ; 参数3: 字节数</span><br><span class="line">syscall             ; 执行系统调用</span><br></pre></td></tr></tbody></table></figure>

<p>可以嵌入到 C 中用 <code>asm</code> 关键字，或者纯汇编实现。<strong>但本质仍然是调内核提供的功能</strong>。</p>
<h5 id="完整的内核-I-O-链路"><a href="#完整的内核-I-O-链路" class="headerlink" title="完整的内核 I/O 链路"></a>完整的内核 I/O 链路</h5><p>内核中的 I/O 链路是一个比较复杂的流程，涉及到从系统调用层到驱动程序再到硬件控制器，最终完成数据交换。下面用详细且清晰的方式完整描述一下 Linux 内核中典型的 I/O 链路（以磁盘读写为例）：</p>
<p>用户进程发起 I/O 请求<br> ⬇️<br> 系统调用层（如<code>read()</code>/<code>write()</code>）<br> ⬇️<br> 虚拟文件系统层 (VFS)<br> ⬇️<br> 具体文件系统层（如 ext4、xfs）<br> ⬇️<br> 块设备层（Block Layer）<br> ⬇️<br> I/O 调度层（如 CFQ、Deadline、noop）<br> ⬇️<br> 通用块设备接口（Generic Block Layer）<br> ⬇️<br> 设备驱动层（如 SATA、NVMe 驱动）<br> ⬇️<br> 硬件接口层（设备控制器，如 AHCI 控制器）<br> ⬇️<br> 硬件设备（磁盘、SSD 等物理设备）<br> ⬇️<br> 设备执行完成，产生硬件中断通知 CPU<br> ⬇️<br> 内核中断处理程序完成后续动作（如唤醒进程）</p>
<p>🔥 下面是一个完整的、详细的 I/O 请求处理链路（以一次文件读取操作为例）：</p>
<p>（1）用户进程发起系统调用</p>
<ul>
<li>用户程序调用标准库函数：<code>read(fd, buf, count);</code></li>
<li>陷入内核态，内核获取调用参数。</li>
</ul>
<p>（2）系统调用层 (<code>sys_read</code>)</p>
<ul>
<li>内核调用 <code>sys_read</code>：<ul>
<li>检查文件描述符有效性；</li>
<li>获取内核的文件结构体（struct file）。</li>
</ul>
</li>
</ul>
<p>（3）虚拟文件系统层 (VFS)</p>
<ul>
<li>内核通过 VFS 层调用文件对应的操作函数，调用对应文件系统的 read 方法：<code>file-&gt;f_op-&gt;read_iter(...)</code></li>
</ul>
<p>（4）具体文件系统层（如 ext4）</p>
<ul>
<li>文件系统层通过文件的 inode 结构确定要读取的数据位于哪些<strong>逻辑块</strong>。</li>
<li>文件系统根据 inode 中的映射结构确定<strong>物理磁盘上的位置</strong>（磁盘扇区号）。</li>
</ul>
<p>（5）块设备层（Block Layer）</p>
<ul>
<li><p>文件系统调用块设备接口（bio 接口）发起数据请求。</p>
</li>
<li><p>此时内核创建一个 <strong>bio 结构体</strong> 表示一次 I/O 请求：<code>submit_bio()</code></p>
</li>
<li><p>块设备层对 bio 进行进一步封装，形成更底层的 <strong>request 结构</strong>。</p>
</li>
</ul>
<p>（6）I/O 调度层（IO Scheduler）</p>
<ul>
<li>request 进入 I/O 调度器队列，常见调度器如：<ul>
<li>CFQ（Completely Fair Queueing，完全公平队列）</li>
<li>Deadline</li>
<li>noop</li>
<li>BFQ（新版本）</li>
</ul>
</li>
<li>I/O 调度器决定请求的先后顺序，进行排序和合并优化，减少磁盘寻道延迟。</li>
</ul>
<p>（7）通用块设备接口（Generic Block Layer）</p>
<ul>
<li>I/O 调度器调度好的请求传入通用块设备层。</li>
<li>通用块设备层对请求做进一步通用处理，比如：<ul>
<li>合并相邻请求</li>
<li>分发到具体的设备驱动</li>
</ul>
</li>
</ul>
<p>（8）设备驱动层（Device Driver）</p>
<ul>
<li>通用块设备接口将 request 分发给具体驱动，比如：<ul>
<li>SATA 磁盘驱动 (<code>ahci.ko</code>)</li>
<li>NVMe 驱动 (<code>nvme.ko</code>)</li>
</ul>
</li>
<li>驱动程序将 request 翻译成硬件控制器能理解的指令集：<ul>
<li>对于磁盘：ATA/SCSI 命令</li>
<li>对于 NVMe：NVMe 命令</li>
</ul>
</li>
<li>驱动程序将命令写入设备控制器寄存器，触发 DMA（直接内存访问）数据传输。</li>
</ul>
<p>（9）硬件接口层（设备控制器）</p>
<ul>
<li>硬件控制器（如 AHCI 控制器）根据命令从物理磁盘读取数据：<ul>
<li>控制磁盘机械臂移动，进行磁道寻址；</li>
<li>寻道完成后，读取数据到控制器缓存；</li>
<li>通过 DMA 把数据传输到内存中的内核缓冲区（Page Cache）。</li>
</ul>
</li>
</ul>
<p>（10）硬件设备完成数据传输（DMA）</p>
<ul>
<li>DMA 数据传输完成后，硬件设备发起<strong>硬件中断</strong>通知 CPU，表示操作完成。</li>
</ul>
<p>（11）中断处理流程（Interrupt Handler）</p>
<ul>
<li>CPU 响应硬件中断，内核执行相应中断处理程序：<ul>
<li>确认硬件完成状态；</li>
<li>标记 request 已经完成；</li>
<li>唤醒阻塞在此请求上的进程或任务（如被阻塞的 read 调用）。</li>
</ul>
</li>
</ul>
<p>（12）返回数据到用户进程</p>
<ul>
<li>唤醒进程后，内核从内核缓冲区（Page Cache）将数据拷贝到用户空间缓冲区。</li>
<li>系统调用返回，用户进程继续执行。</li>
</ul>
<p>⚡ 三、几个关键的数据结构：</p>
<ul>
<li><strong>bio</strong>：表示一次块设备的 I/O 请求，描述了内存中的缓冲区、目标设备扇区等信息。</li>
<li><strong>request</strong>：更底层的结构，描述了请求的具体物理扇区位置和传输数据量。</li>
<li><strong>request_queue</strong>：存放 request 的队列，由 I/O 调度器管理。</li>
</ul>
<p>📌 四、再总结一次链路精简版：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">用户进程read</span><br><span class="line">    ↓</span><br><span class="line">内核sys_read()</span><br><span class="line">    ↓</span><br><span class="line">VFS虚拟文件系统</span><br><span class="line">    ↓</span><br><span class="line">文件系统(ext4等)</span><br><span class="line">    ↓</span><br><span class="line">块设备层 (bio)</span><br><span class="line">    ↓</span><br><span class="line">I/O调度层(request)</span><br><span class="line">    ↓</span><br><span class="line">通用块设备层</span><br><span class="line">    ↓</span><br><span class="line">设备驱动程序（SATA/NVMe）</span><br><span class="line">    ↓</span><br><span class="line">硬件接口控制器（AHCI）</span><br><span class="line">    ↓</span><br><span class="line">物理硬件磁盘（DMA）</span><br><span class="line">    ↓</span><br><span class="line">硬件中断（通知内核）</span><br><span class="line">    ↓</span><br><span class="line">内核中断处理程序</span><br><span class="line">    ↓</span><br><span class="line">唤醒进程，数据拷贝回用户空间</span><br></pre></td></tr></tbody></table></figure>

<h4 id="算法题-2"><a href="#算法题-2" class="headerlink" title="算法题"></a>算法题</h4><h5 id="146-LRU-缓存"><a href="#146-LRU-缓存" class="headerlink" title="146. LRU 缓存"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/lru-cache/">146. LRU 缓存 <span style="white-space: nowrap;"><svg width=".7em" height=".7em" viewBox="0 0 21 21" xmlns="http://www.w3.org/2000/svg"><path d="m13 3l3.293 3.293l-7 7l1.414 1.414l7-7L21 11V3z" fill="currentColor"></path><path d="M19 19H5V5h7l-2-2H5c-1.103 0-2 .897-2 2v14c0 1.103.897 2 2 2h14c1.103 0 2-.897 2-2v-5l-2-2v7z" fill="currentColor"></path></svg></span></a></h5><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> {</span><br><span class="line">    <span class="type">int</span> key;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    Node* prev;</span><br><span class="line">    Node* next;</span><br><span class="line">    <span class="built_in">Node</span>(<span class="type">int</span> k = <span class="number">0</span>, <span class="type">int</span> v = <span class="number">0</span>) : <span class="built_in">key</span>(k), <span class="built_in">value</span>(v) {}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LRUCache</span> {</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Node* dummy;</span><br><span class="line">    <span class="type">int</span> capacity;</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, Node*&gt; key_to_node;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(Node* node)</span> </span>{</span><br><span class="line">        node-&gt;prev-&gt;next = node-&gt;next;</span><br><span class="line">        node-&gt;next-&gt;prev = node-&gt;prev;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push_front</span><span class="params">(Node* node)</span> </span>{</span><br><span class="line">        node-&gt;prev = dummy;</span><br><span class="line">        node-&gt;next = dummy-&gt;next;</span><br><span class="line">        dummy-&gt;next-&gt;prev = node;</span><br><span class="line">        dummy-&gt;next = node;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function">Node* <span class="title">get_node</span><span class="params">(<span class="type">int</span> key)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (!key_to_node.<span class="built_in">count</span>(key)) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        }</span><br><span class="line">        Node* node = key_to_node[key];</span><br><span class="line">        <span class="built_in">remove</span>(node);</span><br><span class="line">        <span class="built_in">push_front</span>(node);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">LRUCache</span>(<span class="type">int</span> capacity) : <span class="built_in">capacity</span>(capacity) {</span><br><span class="line">        dummy = <span class="keyword">new</span> <span class="built_in">Node</span>();</span><br><span class="line">        dummy-&gt;next = dummy;</span><br><span class="line">        dummy-&gt;prev = dummy;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> key)</span> </span>{</span><br><span class="line">        Node* node = <span class="built_in">get_node</span>(key);</span><br><span class="line">        <span class="keyword">return</span> node ? node-&gt;value : <span class="number">-1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> </span>{</span><br><span class="line">        Node* node = <span class="built_in">get_node</span>(key);</span><br><span class="line">        <span class="keyword">if</span> (node) {</span><br><span class="line">            node-&gt;value = value;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        node = <span class="keyword">new</span> <span class="built_in">Node</span>(key, value);</span><br><span class="line">        <span class="keyword">if</span> (key_to_node.<span class="built_in">size</span>() == capacity) {</span><br><span class="line">            Node* last = dummy-&gt;prev;</span><br><span class="line">            key_to_node.<span class="built_in">erase</span>(last-&gt;key);</span><br><span class="line">            <span class="built_in">remove</span>(last);</span><br><span class="line">            <span class="keyword">delete</span> last;</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">push_front</span>(node);</span><br><span class="line">        key_to_node[key] = node;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your LRUCache object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * LRUCache* obj = new LRUCache(capacity);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;get(key);</span></span><br><span class="line"><span class="comment"> * obj-&gt;put(key,value);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></tbody></table></figure>

<h5 id="24-两两交换链表中的节点"><a href="#24-两两交换链表中的节点" class="headerlink" title="24. 两两交换链表中的节点"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/swap-nodes-in-pairs/">24. 两两交换链表中的节点 <span style="white-space: nowrap;"><svg width=".7em" height=".7em" viewBox="0 0 21 21" xmlns="http://www.w3.org/2000/svg"><path d="m13 3l3.293 3.293l-7 7l1.414 1.414l7-7L21 11V3z" fill="currentColor"></path><path d="M19 19H5V5h7l-2-2H5c-1.103 0-2 .897-2 2v14c0 1.103.897 2 2 2h14c1.103 0 2-.897 2-2v-5l-2-2v7z" fill="currentColor"></path></svg></span></a></h5><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (!head)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        <span class="function">ListNode <span class="title">dummy</span><span class="params">(<span class="number">0</span>, head)</span></span>;</span><br><span class="line">        ListNode* node0 = &amp;dummy;</span><br><span class="line">        ListNode* node1 = head;</span><br><span class="line">        <span class="keyword">while</span> (node1 &amp;&amp; node1-&gt;next) {</span><br><span class="line">            ListNode* node2 = node1-&gt;next;</span><br><span class="line">            ListNode* node3 = node2-&gt;next;</span><br><span class="line">            node2-&gt;next = node1;</span><br><span class="line">            node1-&gt;next = node3;</span><br><span class="line">            node0-&gt;next = node2;</span><br><span class="line">            node0 = node1;</span><br><span class="line">            node1 = node3;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<h2 id="腾讯-WXG-企业微信｜测试开发"><a href="#腾讯-WXG-企业微信｜测试开发" class="headerlink" title="腾讯 WXG 企业微信｜测试开发"></a>腾讯 WXG 企业微信｜测试开发</h2><h3 id="一面（挂）-5"><a href="#一面（挂）-5" class="headerlink" title="一面（挂）"></a>一面（挂）</h3><h4 id="0-业务介绍"><a href="#0-业务介绍" class="headerlink" title="0. 业务介绍"></a>0. 业务介绍</h4><p>base：广州</p>
<p>测试开发岗位（前后端都需要会）：用例管理平台、脑图承载、多端协同编辑、管理业务/研发/测试进度、增量测试、覆盖率、基于大模型自动化测试的工具、版本用户量大需要压测</p>
<h4 id="0-简历拷打-——-项目有什么难点吗？"><a href="#0-简历拷打-——-项目有什么难点吗？" class="headerlink" title="0. 简历拷打 —— 项目有什么难点吗？"></a>0. 简历拷打 —— 项目有什么难点吗？</h4><p>这点需要优化到后续的回答中…</p>
<h4 id="1-C-虚函数"><a href="#1-C-虚函数" class="headerlink" title="1. C++ 虚函数"></a>1. C++ 虚函数</h4><p>虚函数（virtual function）是为了实现 <strong>多态</strong> 而设计的。基类使用 <code>virtual</code> 关键字修饰成员函数，派生类可以重写该函数，在运行时根据对象的实际类型决定调用哪个函数。</p>
<p>特点：</p>
<ul>
<li>虚函数支持运行时动态绑定。</li>
<li>基类析构函数如果有派生类，<strong>必须定义为虚函数</strong>，否则析构时可能不会调用派生类析构函数，导致资源泄露。</li>
<li>虚函数表（vtable）和虚表指针（vptr）是实现机制。</li>
</ul>
<h4 id="2-new-和-malloc-的区别，二者类型安全吗？"><a href="#2-new-和-malloc-的区别，二者类型安全吗？" class="headerlink" title="2. new 和 malloc 的区别，二者类型安全吗？"></a>2. new 和 malloc 的区别，二者类型安全吗？</h4><table>
<thead>
<tr>
<th>特性</th>
<th>new</th>
<th>malloc</th>
</tr>
</thead>
<tbody><tr>
<td>语言</td>
<td>C++</td>
<td>C</td>
</tr>
<tr>
<td>返回类型</td>
<td>类型安全，返回实际类型指针</td>
<td><code>void*</code>，需强转</td>
</tr>
<tr>
<td>调用构造函数</td>
<td>✅</td>
<td>❌</td>
</tr>
<tr>
<td>内存分配失败</td>
<td>抛出异常 <code>bad_alloc</code></td>
<td>返回 <code>NULL</code></td>
</tr>
<tr>
<td>可重载</td>
<td>✅（可自定义 new/delete）</td>
<td>❌</td>
</tr>
<tr>
<td>对象生命周期</td>
<td>构造 + 析构</td>
<td>仅内存分配</td>
</tr>
</tbody></table>
<p>类型安全：</p>
<ul>
<li><code>new</code> 是类型安全的，返回类型是分配对象的实际类型指针。</li>
<li><code>malloc</code> 不是类型安全的，返回 <code>void*</code>。</li>
</ul>
<h4 id="3-C-多线程一般怎么去实现？"><a href="#3-C-多线程一般怎么去实现？" class="headerlink" title="3. C++ 多线程一般怎么去实现？"></a>3. C++ 多线程一般怎么去实现？</h4><p>使用 <code>&lt;thread&gt;</code> 头文件中的 <code>std::thread</code> 类可以很方便地创建并管理线程。</p>
<p>常用方式：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 执行任务</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">(func)</span></span>;</span><br><span class="line">    t.<span class="built_in">join</span>(); <span class="comment">// 等待线程结束</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="4-C-用什么创建线程"><a href="#4-C-用什么创建线程" class="headerlink" title="4. C++ 用什么创建线程?"></a>4. C++ 用什么创建线程?</h4><p>主要方式有：</p>
<ul>
<li><code>std::thread</code>（C++11 起）</li>
<li><code>std::async</code>（用于异步任务）</li>
<li>低级：pthread（POSIX 多线程，平台相关）</li>
<li>高级库：Boost.Thread，Intel TBB 等</li>
</ul>
<p>最推荐现代 C++ 使用 <code>std::thread</code>。</p>
<h4 id="5-同步机制怎么做的？"><a href="#5-同步机制怎么做的？" class="headerlink" title="5. 同步机制怎么做的？"></a>5. 同步机制怎么做的？</h4><p>主要有以下几种方式：</p>
<table>
<thead>
<tr>
<th>同步方式</th>
<th>用法</th>
</tr>
</thead>
<tbody><tr>
<td><code>std::mutex</code></td>
<td>互斥锁，用于保护共享资源</td>
</tr>
<tr>
<td><code>std::lock_guard</code></td>
<td>自动管理锁，RAII 风格，防止忘记 unlock</td>
</tr>
<tr>
<td><code>std::unique_lock</code></td>
<td>可灵活 unlock/lock，支持条件变量等待</td>
</tr>
<tr>
<td><code>std::condition_variable</code></td>
<td>线程等待与唤醒</td>
</tr>
<tr>
<td><code>std::atomic</code></td>
<td>原子变量，避免使用锁的轻量级同步</td>
</tr>
</tbody></table>
<h4 id="6-条件变量的使用场景有哪些？"><a href="#6-条件变量的使用场景有哪些？" class="headerlink" title="6. 条件变量的使用场景有哪些？"></a>6. 条件变量的使用场景有哪些？</h4><p>条件变量适用于：</p>
<ul>
<li><strong>生产者消费者模型</strong></li>
<li><strong>线程等待某个状态满足</strong>（如缓冲区非空）</li>
<li><strong>资源准备就绪通知</strong></li>
</ul>
<p>关键点：</p>
<ul>
<li>需要搭配 <code>std::unique_lock&lt;std::mutex&gt;</code> 使用。</li>
<li>使用 <code>wait()</code> 挂起线程，<code>notify_one()</code> 或 <code>notify_all()</code> 唤醒。</li>
</ul>
<h4 id="7-C-实现生产者消费者场景（多生产者多消费者）"><a href="#7-C-实现生产者消费者场景（多生产者多消费者）" class="headerlink" title="7. C++ 实现生产者消费者场景（多生产者多消费者）"></a>7. C++ 实现生产者消费者场景（多生产者多消费者）</h4><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::queue&lt;<span class="type">int</span>&gt; buffer;</span><br><span class="line"><span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> max_size = <span class="number">10</span>;</span><br><span class="line">std::mutex mtx;</span><br><span class="line">std::condition_variable cv;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">producer</span><span class="params">(<span class="type">int</span> id)</span> </span>{</span><br><span class="line">    <span class="type">int</span> val = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) {</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">        cv.<span class="built_in">wait</span>(lock, [] { <span class="keyword">return</span> buffer.<span class="built_in">size</span>() &lt; max_size; });</span><br><span class="line">        buffer.<span class="built_in">push</span>(val++);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"Producer "</span> &lt;&lt; id &lt;&lt; <span class="string">" produced: "</span> &lt;&lt; val &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">        lock.<span class="built_in">unlock</span>();</span><br><span class="line">        cv.<span class="built_in">notify_all</span>();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">consumer</span><span class="params">(<span class="type">int</span> id)</span> </span>{</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) {</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">        cv.<span class="built_in">wait</span>(lock, [] { <span class="keyword">return</span> !buffer.<span class="built_in">empty</span>(); });</span><br><span class="line">        <span class="type">int</span> val = buffer.<span class="built_in">front</span>(); buffer.<span class="built_in">pop</span>();</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"Consumer "</span> &lt;&lt; id &lt;&lt; <span class="string">" consumed: "</span> &lt;&lt; val &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">        lock.<span class="built_in">unlock</span>();</span><br><span class="line">        cv.<span class="built_in">notify_all</span>();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="8-代码中用什么来实现互斥资源量？"><a href="#8-代码中用什么来实现互斥资源量？" class="headerlink" title="8. 代码中用什么来实现互斥资源量？"></a>8. 代码中用什么来实现互斥资源量？</h4><h5 id="✅-1-封装成类（推荐）"><a href="#✅-1-封装成类（推荐）" class="headerlink" title="✅ 1. 封装成类（推荐）"></a>✅ 1. <strong>封装成类</strong>（推荐）</h5><p>把资源数量和互斥量封装到一个类里，避免污染全局命名空间，同时更清晰、更安全。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ResourcePool</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">ResourcePool</span><span class="params">(<span class="type">int</span> total)</span> : count(total) {</span>}</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">acquire</span><span class="params">(<span class="type">int</span> id)</span> </span>{</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (count &gt; <span class="number">0</span>) {</span><br><span class="line">            --count;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">"Thread "</span> &lt;&lt; id &lt;&lt; <span class="string">" acquired. Remaining: "</span> &lt;&lt; count &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        }</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"Thread "</span> &lt;&lt; id &lt;&lt; <span class="string">" failed to acquire.\n"</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">release</span><span class="params">(<span class="type">int</span> id)</span> </span>{</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">        ++count;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"Thread "</span> &lt;&lt; id &lt;&lt; <span class="string">" released. Remaining: "</span> &lt;&lt; count &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> count;</span><br><span class="line">    std::mutex mtx;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<p>然后在主线程或线程函数中创建并传入对象引用或智能指针：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">worker</span><span class="params">(ResourcePool&amp; pool, <span class="type">int</span> id)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (pool.<span class="built_in">acquire</span>(id)) {</span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">200</span>));</span><br><span class="line">        pool.<span class="built_in">release</span>(id);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这样你就可以灵活控制资源池了，而且没有全局变量。</p>
<h5 id="✅-2-使用-std-shared-ptr-或-std-unique-ptr-管理资源池实例"><a href="#✅-2-使用-std-shared-ptr-或-std-unique-ptr-管理资源池实例" class="headerlink" title="✅ 2. 使用 std::shared_ptr 或 std::unique_ptr 管理资源池实例"></a>✅ 2. <strong>使用 <code>std::shared_ptr</code> 或 <code>std::unique_ptr</code> 管理资源池实例</strong></h5><p>避免手动管理生命周期：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> pool = std::<span class="built_in">make_shared</span>&lt;ResourcePool&gt;(<span class="number">5</span>);</span><br><span class="line"><span class="function">std::thread <span class="title">t1</span><span class="params">(worker, std::ref(*pool), <span class="number">1</span>)</span></span>;</span><br></pre></td></tr></tbody></table></figure>

<h5 id="✅-3-用-std-counting-semaphore（C-20）代替资源变量-锁"><a href="#✅-3-用-std-counting-semaphore（C-20）代替资源变量-锁" class="headerlink" title="✅ 3. 用 std::counting_semaphore（C++20）代替资源变量+锁"></a>✅ 3. <strong>用 <code>std::counting_semaphore</code>（C++20）代替资源变量+锁</strong></h5><p>如果你只关心<strong>控制同时访问资源数量</strong>，C++20 的 <code>std::counting_semaphore</code> 更优雅：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">std::counting_semaphore&lt;5&gt; <span class="title">sem</span><span class="params">(<span class="number">5</span>)</span></span>; <span class="comment">// 初始5个资源</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">worker</span><span class="params">(<span class="type">int</span> id)</span> </span>{</span><br><span class="line">    sem.<span class="built_in">acquire</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">"Thread "</span> &lt;&lt; id &lt;&lt; <span class="string">" acquired resource\n"</span>;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">200</span>));</span><br><span class="line">    std::cout &lt;&lt; <span class="string">"Thread "</span> &lt;&lt; id &lt;&lt; <span class="string">" releasing resource\n"</span>;</span><br><span class="line">    sem.<span class="built_in">release</span>();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>不用手动管理 mutex，也不用资源计数变量，线程会自动阻塞在 <code>acquire()</code>，直到有资源可用。</p>
<h4 id="9-线程-thread-local-的作用是什么？"><a href="#9-线程-thread-local-的作用是什么？" class="headerlink" title="9. 线程 thread_local 的作用是什么？"></a>9. 线程 thread_local 的作用是什么？</h4><blockquote>
<p>它是线程单独拥有的资源，没办法作为共享资源</p>
</blockquote>
<p><code>thread_local</code> 是 C++11 引入的存储类型说明符，用于<strong>为每个线程创建独立的变量副本</strong>。</p>
<p>使用场景：</p>
<ul>
<li>每个线程都需要使用一个自己的变量（如缓存、计数器等），避免同步。</li>
<li>类似于线程的“全局变量”，但互不干扰。</li>
</ul>
<p>示例：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">thread_local</span> <span class="type">int</span> counter = <span class="number">0</span>;</span><br></pre></td></tr></tbody></table></figure>

<p>✅ <strong>示例场景</strong>：日志系统中用 <code>thread_local</code> 缓存上下文</p>
<p>在多线程程序中，很多系统会<strong>给每个线程维护一份独立的日志信息</strong>，比如线程 ID、调用栈、临时日志缓存等。如果所有线程都用一个共享变量，会导致锁竞争、效率低下。</p>
<p>这时候就可以用 <code>thread_local</code> 给每个线程<strong>一份独立副本</strong>！</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Logger</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">log</span><span class="params">(<span class="type">const</span> std::string&amp; message)</span> </span>{</span><br><span class="line">        log_context += message + <span class="string">"\n"</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">flush</span><span class="params">()</span> </span>{</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"[Thread "</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">"]\n"</span>;</span><br><span class="line">        std::cout &lt;&lt; log_context &lt;&lt; std::endl;</span><br><span class="line">        log_context.<span class="built_in">clear</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> <span class="keyword">thread_local</span> std::string log_context; <span class="comment">// 每个线程一份</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">thread_local</span> std::string Logger::log_context;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread_task</span><span class="params">(<span class="type">int</span> id)</span> </span>{</span><br><span class="line">    Logger::<span class="built_in">log</span>(<span class="string">"Start work in thread "</span> + std::<span class="built_in">to_string</span>(id));</span><br><span class="line">    Logger::<span class="built_in">log</span>(<span class="string">"Doing some work..."</span>);</span><br><span class="line">    Logger::<span class="built_in">log</span>(<span class="string">"Finish work in thread "</span> + std::<span class="built_in">to_string</span>(id));</span><br><span class="line">    Logger::<span class="built_in">flush</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(thread_task, <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(thread_task, <span class="number">2</span>)</span></span>;</span><br><span class="line">    t<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">    t<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="10-static-关键字作用？"><a href="#10-static-关键字作用？" class="headerlink" title="10. static 关键字作用？"></a>10. static 关键字作用？</h4><p>在 C++ 中，<code>static</code> 有不同作用：</p>
<ul>
<li><strong>函数内局部变量</strong>：静态存储，生命周期贯穿整个程序（只初始化一次）。</li>
<li><strong>类的成员变量</strong>：属于类，而非对象，所有对象共享。</li>
<li><strong>函数或变量（全局作用域）</strong>：限制作用域为当前文件（编译单元），实现内部链接。</li>
<li><strong>类外静态变量</strong>：通常用于全局资源池、计数器等。</li>
</ul>
<h4 id="11-死锁产生的条件是什么？"><a href="#11-死锁产生的条件是什么？" class="headerlink" title="11. 死锁产生的条件是什么？"></a>11. 死锁产生的条件是什么？</h4><p>经典的 <strong>死锁四条件（同时满足才可能死锁）</strong>：</p>
<ol>
<li><strong>互斥</strong>：资源不能共享。</li>
<li><strong>占有并等待</strong>：线程持有资源，同时等待其他资源。</li>
<li><strong>不剥夺</strong>：资源不能被强制释放。</li>
<li><strong>循环等待</strong>：多个线程形成资源请求的环路。</li>
</ol>
<p>解决思路：破坏其中任何一个条件即可。</p>
<h4 id="12-进程间通信的方式有哪些？你用过哪些？"><a href="#12-进程间通信的方式有哪些？你用过哪些？" class="headerlink" title="12. 进程间通信的方式有哪些？你用过哪些？"></a>12. 进程间通信的方式有哪些？你用过哪些？</h4><p>常见 IPC 方式：</p>
<table>
<thead>
<tr>
<th>方式</th>
<th>特点</th>
</tr>
</thead>
<tbody><tr>
<td>管道（pipe）/命名管道（FIFO）</td>
<td>简单、高效，适合父子进程</td>
</tr>
<tr>
<td>消息队列（msg queue）</td>
<td>类似任务队列，适合异步通信</td>
</tr>
<tr>
<td>共享内存（shm）</td>
<td>最快，直接访问同一内存区域，需加锁</td>
</tr>
<tr>
<td>信号量</td>
<td>控制资源访问（同步）</td>
</tr>
<tr>
<td>套接字（socket）</td>
<td>支持不同主机/网络通信</td>
</tr>
<tr>
<td>mmap</td>
<td>映射共享文件到多个进程内存空间</td>
</tr>
</tbody></table>
<p>你用过哪个取决于你开发的系统场景，比如服务端常用 socket，系统编程多用 pipe、shm、semaphore。</p>
<h4 id="13-多进程使用场景？"><a href="#13-多进程使用场景？" class="headerlink" title="13. 多进程使用场景？"></a>13. 多进程使用场景？</h4><p>Web服务器（如 nginx 的 worker）</p>
<p>数据库服务（PostgreSQL）</p>
<p>守护进程（如 init、cron）</p>
<p>高可靠性要求（一个崩了不影响其他）</p>
<p>分布式调度框架（如 Hadoop 的 Task）</p>
<h4 id="14-多线程使用场景？"><a href="#14-多线程使用场景？" class="headerlink" title="14. 多线程使用场景？"></a>14. 多线程使用场景？</h4><p>计算密集型并发（CPU 多核加速）</p>
<p>I/O 密集型任务并发（如网络请求处理）</p>
<p>GUI 线程 + 后台线程分工</p>
<p>游戏引擎（渲染、物理计算、AI 并发执行）</p>
<h4 id="15-进程与线程的区别？"><a href="#15-进程与线程的区别？" class="headerlink" title="15. 进程与线程的区别？"></a>15. 进程与线程的区别？</h4><table>
<thead>
<tr>
<th>比较项</th>
<th>进程</th>
<th>线程</th>
</tr>
</thead>
<tbody><tr>
<td>内存空间</td>
<td>独立</td>
<td>共享（如堆）</td>
</tr>
<tr>
<td>创建开销</td>
<td>大</td>
<td>小</td>
</tr>
<tr>
<td>通信方式</td>
<td>IPC</td>
<td>共享内存即可</td>
</tr>
<tr>
<td>崩溃影响</td>
<td>互不影响</td>
<td>一个线程崩溃可能导致整个进程崩溃</td>
</tr>
<tr>
<td>调度粒度</td>
<td>粗</td>
<td>细</td>
</tr>
</tbody></table>
<h4 id="16-进程上下文切换会发生什么？"><a href="#16-进程上下文切换会发生什么？" class="headerlink" title="16. 进程上下文切换会发生什么？"></a>16. 进程上下文切换会发生什么？</h4><p>发生切换时操作系统会：</p>
<ul>
<li>保存当前进程的寄存器、程序计数器、栈指针等 CPU 状态（上下文）</li>
<li>更新 PCB（进程控制块）</li>
<li>加载目标进程的上下文，恢复 CPU 状态</li>
<li>更新内存页表（虚拟地址）</li>
</ul>
<p>这是一个非常重的操作（相对线程切换）。</p>
<h4 id="17-查询发现-SQL-慢查询，怎么处理？"><a href="#17-查询发现-SQL-慢查询，怎么处理？" class="headerlink" title="17. 查询发现 SQL 慢查询，怎么处理？"></a>17. 查询发现 SQL 慢查询，怎么处理？</h4><blockquote>
<p>🔥 可以参考链接：”<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/Jnimeyjifl6QH3HLC7ptUg">慢SQL”治理的几点思考 <span style="white-space: nowrap;"><svg width=".7em" height=".7em" viewBox="0 0 21 21" xmlns="http://www.w3.org/2000/svg"><path d="m13 3l3.293 3.293l-7 7l1.414 1.414l7-7L21 11V3z" fill="currentColor"></path><path d="M19 19H5V5h7l-2-2H5c-1.103 0-2 .897-2 2v14c0 1.103.897 2 2 2h14c1.103 0 2-.897 2-2v-5l-2-2v7z" fill="currentColor"></path></svg></span></a></p>
</blockquote>
<p>给你张表，发现查询速度很慢，你有那些解决方案？</p>
<blockquote>
<p>子问题：怎么知道有没有建索引？</p>
<p>子问题：怎么判断索引是否被使用？</p>
</blockquote>
<ul>
<li>分析查询语句：使用 <code>EXPLAIN</code> 命令分析 SQL 执行计划，找出慢查询的原因，比如是否使用了全表扫描，是否存在索引未被利用的情况等，并根据相应情况对索引进行适当修改。</li>
<li>创建或优化索引：根据查询条件创建合适的索引，特别是经常用于 <code>WHERE</code> 子句的字段、<code>Orderby</code> 排序的字段、<code>Join</code> 连表查询的字典、<code>group by</code> 的字段，并且如果查询中经常涉及多个字段，考虑创建联合索引，使用联合索引要符合最左匹配原则，不然会索引失效</li>
<li><strong>避免索引失效</strong>：比如不要用左模糊匹配、函数计算、表达式计算等等。</li>
<li>查询优化：避免使用 <code>SELECT *</code>，只查询真正需要的列；使用覆盖索引，即索引包含所有查询的字段；联表查询最好要以小表驱动大表，并且被驱动表的字段要有索引，当然最好通过冗余字段的设计，避免联表查询。</li>
<li>**分页优化：**针对 <code>limit n,y</code> 深分页的查询优化，可以把Limit查询转换成某个位置的查询：select * from tb_sku where id&gt;20000 limit 10，该方案适用于主键自增的表，</li>
<li>优化数据库表：如果单表的数据超过了千万级别，考虑是否需要将大表拆分为小表，减轻单个表的查询压力。也可以将字段多的表分解成多个表，有些字段使用频率高，有些低，数据量大时，会由于使用频率低的存在而变慢，可以考虑分开。</li>
<li>使用缓存技术：引入缓存层，如Redis，存储热点数据和频繁查询的结果，但是要考虑缓存一致性的问题，对于读请求会选择旁路缓存策略，对于写请求会选择先更新 db，再删除缓存的策略。</li>
</ul>
<hr>
<p>GPT:</p>
<p>使用 <code>EXPLAIN</code> 分析执行计划</p>
<p>看是否走了索引？是否全表扫描？</p>
<p>添加合适的索引（前缀、联合索引）</p>
<p>拆分复杂 SQL（子查询、JOIN）</p>
<p>规范字段类型（不要 varchar vs int 比较）</p>
<p>分库分表、缓存热点数据</p>
<p>数据量大时考虑归档冷数据</p>
<h4 id="18-索引底层数据结构是什么？"><a href="#18-索引底层数据结构是什么？" class="headerlink" title="18. 索引底层数据结构是什么？"></a>18. 索引底层数据结构是什么？</h4><p>大多数数据库（如 MySQL InnoDB）使用的是 <strong>B+ 树</strong></p>
<h4 id="19-为什么用-B-树而不是哈希表？"><a href="#19-为什么用-B-树而不是哈希表？" class="headerlink" title="19. 为什么用 B+ 树而不是哈希表？"></a>19. 为什么用 B+ 树而不是哈希表？</h4><table>
<thead>
<tr>
<th>对比项</th>
<th>B+ 树</th>
<th>哈希表</th>
</tr>
</thead>
<tbody><tr>
<td>有序查询</td>
<td>✅</td>
<td>❌</td>
</tr>
<tr>
<td>范围查询</td>
<td>✅</td>
<td>❌</td>
</tr>
<tr>
<td>最小/最大值查询</td>
<td>✅</td>
<td>❌</td>
</tr>
<tr>
<td>磁盘友好</td>
<td>✅</td>
<td>❌（哈希冲突+链表）</td>
</tr>
<tr>
<td>空间利用率</td>
<td>✅</td>
<td>可能很低（冲突链表）</td>
</tr>
</tbody></table>
<p>哈希适合精准匹配，B+ 树适合数据库查询场景</p>
<h4 id="20-B-树怎么存这些数据？"><a href="#20-B-树怎么存这些数据？" class="headerlink" title="20. B+ 树怎么存这些数据？"></a>20. B+ 树怎么存这些数据？</h4><p>所有数据都存在<strong>叶子节点</strong>（不同于 B 树）</p>
<p>叶子节点通过指针相连，<strong>支持范围查询</strong></p>
<p>非叶子节点只存索引 key，不存数据（占内存小）</p>
<p>多路搜索树，分支因子高，<strong>减少磁盘 IO 次数</strong></p>
<h4 id="21-访问一个网页，中间会发生什么过程？"><a href="#21-访问一个网页，中间会发生什么过程？" class="headerlink" title="21. 访问一个网页，中间会发生什么过程？"></a>21. 访问一个网页，中间会发生什么过程？</h4><p>输入 URL</p>
<p>浏览器查找缓存，若无发起 DNS 查询</p>
<p>DNS 解析出 IP 地址</p>
<p>建立 TCP 连接（可能含 TLS 握手）</p>
<p>发送 HTTP/HTTPS 请求</p>
<p>服务器处理、返回响应</p>
<p>浏览器渲染页面，解析 HTML/CSS/JS</p>
<p>发起后续资源请求（图片、脚本等）</p>
<h4 id="22-如果响应很慢，可能在哪个环节出现问题？"><a href="#22-如果响应很慢，可能在哪个环节出现问题？" class="headerlink" title="22. 如果响应很慢，可能在哪个环节出现问题？"></a>22. 如果响应很慢，可能在哪个环节出现问题？</h4><table>
<thead>
<tr>
<th>阶段</th>
<th>问题可能</th>
</tr>
</thead>
<tbody><tr>
<td>DNS</td>
<td>解析慢、DNS 池老化</td>
</tr>
<tr>
<td>TCP 连接</td>
<td>三次握手慢</td>
</tr>
<tr>
<td>TLS 握手</td>
<td>证书链、密钥协商慢</td>
</tr>
<tr>
<td>服务器响应</td>
<td>数据库慢、CPU 高负载、缓存未命中</td>
</tr>
<tr>
<td>网络</td>
<td>丢包、拥堵</td>
</tr>
<tr>
<td>浏览器渲染</td>
<td>JS 执行慢、资源大、阻塞</td>
</tr>
</tbody></table>
<h4 id="23-I-O-多路复用（select、poll、epoll）"><a href="#23-I-O-多路复用（select、poll、epoll）" class="headerlink" title="23. I/O 多路复用（select、poll、epoll）"></a>23. I/O 多路复用（select、poll、epoll）</h4><p>I/O 多路复用是一种在单个线程中同时监听多个文件描述符（fd）的方法，在非阻塞 I/O 模型中广泛使用，例如网络服务器中同时监听多个 socket 的可读/可写事件。</p>
<blockquote>
<p>常见的三种 I/O 多路复用方式</p>
</blockquote>
<table>
<thead>
<tr>
<th>技术</th>
<th>特点</th>
<th>系统调用</th>
<th>文件描述符数量限制</th>
<th>通知机制</th>
</tr>
</thead>
<tbody><tr>
<td><code>select</code></td>
<td>最早的接口，简单</td>
<td><code>select()</code></td>
<td>有（FD_SETSIZE，默认1024）</td>
<td>遍历全部 fd</td>
</tr>
<tr>
<td><code>poll</code></td>
<td>改进了 fd 数量限制</td>
<td><code>poll()</code></td>
<td>无限制（理论上）</td>
<td>遍历全部 fd</td>
</tr>
<tr>
<td><code>epoll</code></td>
<td>高效，Linux 专属</td>
<td><code>epoll_create</code> / <code>epoll_wait</code></td>
<td>几乎无限制</td>
<td>事件驱动（回调机制）</td>
</tr>
</tbody></table>
<h5 id="🥇1-select-工作原理"><a href="#🥇1-select-工作原理" class="headerlink" title="🥇1. select 工作原理"></a>🥇1. <code>select</code> 工作原理</h5><ul>
<li>参数是一个<strong>fd 集合</strong>（数组），用 bitmap 表示。</li>
<li>每次调用 <code>select()</code> 都要重新传入 fd 集合。</li>
<li>内核遍历这个集合，<strong>检测哪些 fd 准备就绪</strong>。</li>
<li>成本：<strong>线性扫描 + 拷贝开销大</strong>。</li>
</ul>
<p><strong>代码示例</strong>：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fd_set read_fds;</span><br><span class="line"><span class="built_in">FD_ZERO</span>(&amp;read_fds);</span><br><span class="line"><span class="built_in">FD_SET</span>(sock_fd, &amp;read_fds);</span><br><span class="line"><span class="built_in">select</span>(maxfd + <span class="number">1</span>, &amp;read_fds, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br></pre></td></tr></tbody></table></figure>

<h5 id="🥈2-poll-工作原理"><a href="#🥈2-poll-工作原理" class="headerlink" title="🥈2. poll 工作原理"></a>🥈2. <code>poll</code> 工作原理</h5><ul>
<li>传入一个 <code>pollfd[]</code> 数组。</li>
<li>没有 fd 数量上限限制，但还是要<strong>遍历全部 fd</strong>。</li>
<li>每次都要传入整个数组，重复系统调用，<strong>效率不高</strong>。</li>
</ul>
<p><strong>代码示例</strong>：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">pollfd</span> fds[<span class="number">10</span>];</span><br><span class="line">fds[<span class="number">0</span>].fd = sock_fd;</span><br><span class="line">fds[<span class="number">0</span>].events = POLLIN;</span><br><span class="line"><span class="built_in">poll</span>(fds, nfds, timeout);</span><br></pre></td></tr></tbody></table></figure>

<h5 id="🥇🥇3-epoll-工作原理（Linux-专属，最常用）"><a href="#🥇🥇3-epoll-工作原理（Linux-专属，最常用）" class="headerlink" title="🥇🥇3. epoll 工作原理（Linux 专属，最常用）"></a>🥇🥇3. <code>epoll</code> 工作原理（Linux 专属，最常用）</h5><ul>
<li>提供三大函数：<ul>
<li><code>epoll_create()</code>：创建 epoll 实例</li>
<li><code>epoll_ctl()</code>：注册/修改/删除监听的 fd</li>
<li><code>epoll_wait()</code>：阻塞等待事件发生</li>
</ul>
</li>
<li>核心优势是：<strong>事件通知机制（event-driven）</strong>，不像前面两个要轮询。</li>
<li>内核维护一个就绪队列，只返回活跃 fd。</li>
</ul>
<p>epoll 的两种触发模式：</p>
<table>
<thead>
<tr>
<th>模式</th>
<th>特点</th>
<th>应用建议</th>
</tr>
</thead>
<tbody><tr>
<td><strong>LT（Level Trigger）</strong></td>
<td>默认，<strong>状态还在就继续通知</strong></td>
<td>简单，适合多数场景</td>
</tr>
<tr>
<td><strong>ET（Edge Trigger）</strong></td>
<td><strong>状态变化才通知一次</strong>，必须把数据一次读完</td>
<td>性能高，但使用复杂，需要非阻塞 IO</td>
</tr>
</tbody></table>
<p>epoll 示例代码：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> epfd = <span class="built_in">epoll_create</span>(<span class="number">1024</span>);</span><br><span class="line"><span class="built_in">epoll_ctl</span>(epfd, EPOLL_CTL_ADD, sock_fd, &amp;event);</span><br><span class="line"><span class="built_in">epoll_wait</span>(epfd, events, MAX_EVENTS, timeout);</span><br></pre></td></tr></tbody></table></figure>

<h5 id="📊-性能对比（大致）"><a href="#📊-性能对比（大致）" class="headerlink" title="📊 性能对比（大致）"></a>📊 性能对比（大致）</h5><table>
<thead>
<tr>
<th>接口</th>
<th>大量连接场景下性能</th>
<th>fd 扫描</th>
<th>内核空间到用户空间拷贝</th>
</tr>
</thead>
<tbody><tr>
<td><code>select</code></td>
<td>差</td>
<td>需要全量扫描</td>
<td>是</td>
</tr>
<tr>
<td><code>poll</code></td>
<td>一般</td>
<td>需要全量扫描</td>
<td>是</td>
</tr>
<tr>
<td><code>epoll</code></td>
<td>优</td>
<td>事件通知，无需扫描</td>
<td>否（一次事件返回多个 fd）</td>
</tr>
</tbody></table>
<h5 id="✅-epoll-使用建议"><a href="#✅-epoll-使用建议" class="headerlink" title="✅ epoll 使用建议"></a>✅ epoll 使用建议</h5><ul>
<li>所有 socket 设置为 <strong>非阻塞（O_NONBLOCK）</strong></li>
<li>ET 模式下必须 <strong>循环读取/写入直到返回 EAGAIN</strong></li>
<li>最常用于高并发网络服务（如 nginx、redis、netty）</li>
</ul>
<h5 id="🚀-小结对比"><a href="#🚀-小结对比" class="headerlink" title="🚀 小结对比"></a>🚀 小结对比</h5><table>
<thead>
<tr>
<th>特性</th>
<th>select</th>
<th>poll</th>
<th>epoll</th>
</tr>
</thead>
<tbody><tr>
<td>平台支持</td>
<td>跨平台</td>
<td>跨平台</td>
<td>Linux 专属</td>
</tr>
<tr>
<td>fd 限制</td>
<td>有</td>
<td>无</td>
<td>无</td>
</tr>
<tr>
<td>触发机制</td>
<td>水平触发</td>
<td>水平触发</td>
<td>支持边缘 / 水平</td>
</tr>
<tr>
<td>性能</td>
<td>差（fd 多时）</td>
<td>一般</td>
<td>高</td>
</tr>
<tr>
<td>使用复杂度</td>
<td>简单</td>
<td>简单</td>
<td>略高（注册 + wait）</td>
</tr>
</tbody></table>
<h5 id="🧠-真实应用场景"><a href="#🧠-真实应用场景" class="headerlink" title="🧠 真实应用场景"></a>🧠 真实应用场景</h5><ul>
<li><code>select</code>：老旧兼容系统、简单网络工具（不推荐新项目用）</li>
<li><code>poll</code>：稍大系统、兼容跨平台库（如 libevent）</li>
<li><code>epoll</code>：高并发服务端框架（nginx、redis、libuv、netty）</li>
</ul>
<h4 id="24-如果-HTTPS-握手失败，你怎么分析原因？"><a href="#24-如果-HTTPS-握手失败，你怎么分析原因？" class="headerlink" title="24. 如果 HTTPS 握手失败，你怎么分析原因？"></a>24. 如果 HTTPS 握手失败，你怎么分析原因？</h4><p>抓包分析（Wireshark）</p>
<p>检查证书链是否完整（浏览器或 <code>openssl s_client</code>）</p>
<p>检查时间是否同步</p>
<p>TLS 协议版本是否兼容（客户端/服务器）</p>
<p>CipherSuite 不兼容</p>
<p>服务器是否强制 SNI / HTTP/2 支持问题</p>
<h4 id="25-如果证书过期，会有什么表现？"><a href="#25-如果证书过期，会有什么表现？" class="headerlink" title="25. 如果证书过期，会有什么表现？"></a>25. 如果证书过期，会有什么表现？</h4><p>浏览器提示安全警告（NET::ERR_CERT_DATE_INVALID）</p>
<p><code>curl</code>、API 请求失败，显示证书验证失败</p>
<p>客户端拒绝建立 TLS 连接</p>
<p>HTTPS 请求直接失败或被降级为 HTTP（极少数）</p>
<h4 id="算法题-3"><a href="#算法题-3" class="headerlink" title="算法题"></a>算法题</h4><h5 id="415-字符串相加"><a href="#415-字符串相加" class="headerlink" title="415. 字符串相加"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/add-strings/">415. 字符串相加 <span style="white-space: nowrap;"><svg width=".7em" height=".7em" viewBox="0 0 21 21" xmlns="http://www.w3.org/2000/svg"><path d="m13 3l3.293 3.293l-7 7l1.414 1.414l7-7L21 11V3z" fill="currentColor"></path><path d="M19 19H5V5h7l-2-2H5c-1.103 0-2 .897-2 2v14c0 1.103.897 2 2 2h14c1.103 0 2-.897 2-2v-5l-2-2v7z" fill="currentColor"></path></svg></span></a></h5><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">addStrings</span><span class="params">(string num1, string num2)</span> </span>{</span><br><span class="line">        <span class="type">int</span> i = num<span class="number">1.l</span>ength() - <span class="number">1</span>, j = num<span class="number">2.l</span>ength() - <span class="number">1</span>, add = <span class="number">0</span>;</span><br><span class="line">        string ans = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span> || add) {</span><br><span class="line">            <span class="type">int</span> x = i &gt;= <span class="number">0</span> ? num1[i] - <span class="string">'0'</span> : <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> y = j &gt;= <span class="number">0</span> ? num2[j] - <span class="string">'0'</span> : <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> result = x + y + add;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(<span class="string">'0'</span> + result % <span class="number">10</span>);</span><br><span class="line">            add = result / <span class="number">10</span>;</span><br><span class="line">            i--;</span><br><span class="line">            j--;</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">reverse</span>(ans.<span class="built_in">begin</span>(), ans.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<h5 id="230-二叉搜索树中第-K-小的元素"><a href="#230-二叉搜索树中第-K-小的元素" class="headerlink" title="230. 二叉搜索树中第 K 小的元素"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/kth-smallest-element-in-a-bst/">230. 二叉搜索树中第 K 小的元素 <span style="white-space: nowrap;"><svg width=".7em" height=".7em" viewBox="0 0 21 21" xmlns="http://www.w3.org/2000/svg"><path d="m13 3l3.293 3.293l-7 7l1.414 1.414l7-7L21 11V3z" fill="currentColor"></path><path d="M19 19H5V5h7l-2-2H5c-1.103 0-2 .897-2 2v14c0 1.103.897 2 2 2h14c1.103 0 2-.897 2-2v-5l-2-2v7z" fill="currentColor"></path></svg></span></a></h5><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">preOrder</span><span class="params">(TreeNode* node)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">preOrder</span>(node-&gt;left);</span><br><span class="line">        ans.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">        <span class="built_in">preOrder</span>(node-&gt;right);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">kthSmallest</span><span class="params">(TreeNode* root, <span class="type">int</span> k)</span> </span>{</span><br><span class="line">        <span class="built_in">preOrder</span>(root);</span><br><span class="line">        <span class="keyword">return</span> ans[k - <span class="number">1</span>];</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<h5 id="354-俄罗斯套娃信封问题"><a href="#354-俄罗斯套娃信封问题" class="headerlink" title="354. 俄罗斯套娃信封问题"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/russian-doll-envelopes/">354. 俄罗斯套娃信封问题 <span style="white-space: nowrap;"><svg width=".7em" height=".7em" viewBox="0 0 21 21" xmlns="http://www.w3.org/2000/svg"><path d="m13 3l3.293 3.293l-7 7l1.414 1.414l7-7L21 11V3z" fill="currentColor"></path><path d="M19 19H5V5h7l-2-2H5c-1.103 0-2 .897-2 2v14c0 1.103.897 2 2 2h14c1.103 0 2-.897 2-2v-5l-2-2v7z" fill="currentColor"></path></svg></span></a></h5><p>贪心 + 二分查找：先排序，再按照 LIS 二分贪心模板求最长递增子序列。</p>
<p>因为二者都必须是递增的，<strong>所以第二维度需要逆序排序</strong>，使得第一维度相同的多个数，最后一个插入的一定是最小值，这样能嵌套的信封最多。</p>
<blockquote>
<p>DP 会超时</p>
</blockquote>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxEnvelopes</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; envelopes)</span> </span>{</span><br><span class="line">        <span class="built_in">sort</span>(envelopes.<span class="built_in">begin</span>(), envelopes.<span class="built_in">end</span>(), [](<span class="type">const</span> <span class="keyword">auto</span>&amp; a, <span class="type">const</span> <span class="keyword">auto</span>&amp; b) {</span><br><span class="line">            <span class="keyword">return</span> a[<span class="number">0</span>] &lt; b[<span class="number">0</span>] || (a[<span class="number">0</span>] == b[<span class="number">0</span>] &amp;&amp; a[<span class="number">1</span>] &gt; b[<span class="number">1</span>]);</span><br><span class="line">        });</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; g;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; e : envelopes) {</span><br><span class="line">            <span class="keyword">auto</span> it = <span class="built_in">lower_bound</span>(g.<span class="built_in">begin</span>(), g.<span class="built_in">end</span>(), e[<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">if</span> (it == g.<span class="built_in">end</span>()) {</span><br><span class="line">                g.<span class="built_in">push_back</span>(e[<span class="number">1</span>]);</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                *it = e[<span class="number">1</span>];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> g.<span class="built_in">size</span>();</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<h2 id="美图基础架构｜C-开发（基础架构）"><a href="#美图基础架构｜C-开发（基础架构）" class="headerlink" title="美图基础架构｜C++ 开发（基础架构）"></a>美图基础架构｜C++ 开发（基础架构）</h2><h3 id="一面（拒）"><a href="#一面（拒）" class="headerlink" title="一面（拒）"></a>一面（拒）</h3><p>主要问项目相关的内容，他自身也没提问八股文相关的知识，主要做「预研」，遂拒。</p>
<h2 id="卓驭智驾端到端｜C-C-嵌入式开发"><a href="#卓驭智驾端到端｜C-C-嵌入式开发" class="headerlink" title="卓驭智驾端到端｜C/C++ 嵌入式开发"></a>卓驭智驾端到端｜C/C++ 嵌入式开发</h2><h3 id="一面（OC）"><a href="#一面（OC）" class="headerlink" title="一面（OC）"></a>一面（OC）</h3><h4 id="1-项目拷打"><a href="#1-项目拷打" class="headerlink" title="1. 项目拷打"></a>1. 项目拷打</h4><p>这部分问得比较细致</p>
<ul>
<li>OPPO：<code>ioctl</code> 调用了哪些函数、你做了哪些工作</li>
<li>中科院软件所：<code>evenodd</code> 实现</li>
<li>PM 项目：为什么用 <code>art</code> 替代 <code>bucket</code>，有什么好处（之后记得去看下性能指标提升多少 —— 参考其他论文）</li>
</ul>
<h4 id="2-C-语言-static-关键字"><a href="#2-C-语言-static-关键字" class="headerlink" title="2. C 语言 static 关键字"></a>2. C 语言 static 关键字</h4><p>…</p>
<h4 id="3-C-语言如何实现结构体？"><a href="#3-C-语言如何实现结构体？" class="headerlink" title="3. C 语言如何实现结构体？"></a>3. C 语言如何实现结构体？</h4><p>…</p>
<h4 id="4-C-如何防止内存泄露？"><a href="#4-C-如何防止内存泄露？" class="headerlink" title="4. C++ 如何防止内存泄露？"></a>4. C++ 如何防止内存泄露？</h4><p>1️⃣ 代码规范，智能指针或 RAII 机制管理资源</p>
<p>2️⃣ 正确捕获处理异常/回滚式编程</p>
<p>3️⃣ 弱引用解决循环引用问题造成的内存泄露</p>
<h4 id="5-C-智能指针？"><a href="#5-C-智能指针？" class="headerlink" title="5. C++ 智能指针？"></a>5. C++ 智能指针？</h4><p>…</p>
<h4 id="6-C-有哪些构造函数？"><a href="#6-C-有哪些构造函数？" class="headerlink" title="6. C++ 有哪些构造函数？"></a>6. C++ 有哪些构造函数？</h4><p>…</p>
<h4 id="7-C-的构造函数可以是虚函数吗？"><a href="#7-C-的构造函数可以是虚函数吗？" class="headerlink" title="7. C++ 的构造函数可以是虚函数吗？"></a>7. C++ 的构造函数可以是虚函数吗？</h4><p>…</p>
<h4 id="8-a-和-a-的区别？"><a href="#8-a-和-a-的区别？" class="headerlink" title="8. ++a 和 a++ 的区别？"></a>8. ++a 和 a++ 的区别？</h4><p>…</p>
<h4 id="9-深拷贝和浅拷贝的区别？"><a href="#9-深拷贝和浅拷贝的区别？" class="headerlink" title="9. 深拷贝和浅拷贝的区别？"></a>9. 深拷贝和浅拷贝的区别？</h4><p>…</p>
<h4 id="10-C-11-的新特性"><a href="#10-C-11-的新特性" class="headerlink" title="10. C++ 11 的新特性"></a>10. C++ 11 的新特性</h4><p>…</p>
<h4 id="11-如何实现多线程？"><a href="#11-如何实现多线程？" class="headerlink" title="11. 如何实现多线程？"></a>11. 如何实现多线程？</h4><p>…</p>
<h4 id="12-进程与线程的区别？"><a href="#12-进程与线程的区别？" class="headerlink" title="12. 进程与线程的区别？"></a>12. 进程与线程的区别？</h4><p>…</p>
<h2 id="字节跳动｜推荐架构系统实习生"><a href="#字节跳动｜推荐架构系统实习生" class="headerlink" title="字节跳动｜推荐架构系统实习生"></a>字节跳动｜推荐架构系统实习生</h2><h3 id="一面-1"><a href="#一面-1" class="headerlink" title="一面"></a>一面</h3><h4 id="简历"><a href="#简历" class="headerlink" title="简历"></a>简历</h4><p>主要简单聊了聊重删的分块算法</p>
<h4 id="算法题-4"><a href="#算法题-4" class="headerlink" title="算法题"></a>算法题</h4><p><code>v1 = [2,2,2,2,2,3,3,3]</code>、<code>v2 = [4,4,4,5,5,5,6,6]</code></p>
<p>压缩表示：</p>
<p><code>v1 = {{2,5},{3,3}}</code>、<code>v2 = {{4,3},{5,3},{6,2}}</code></p>
<ol>
<li>向量如何压缩表示</li>
<li>乘积、如何优化（非逐步，取二者个数最小值）、不修改原数组怎么实现（双指针）</li>
<li>时间复杂度</li>
</ol>
<h4 id="反问环节-1"><a href="#反问环节-1" class="headerlink" title="反问环节"></a>反问环节</h4><ol>
<li>业务：抖音视频推荐、C++</li>
</ol>
<h3 id="二面（挂）-1"><a href="#二面（挂）-1" class="headerlink" title="二面（挂）"></a>二面（挂）</h3><ol>
<li>项目中遇到最难的问题</li>
<li>用代码描述整个流程</li>
</ol>
<h2 id="腾讯-CSIG-腾讯云｜后台开发-1"><a href="#腾讯-CSIG-腾讯云｜后台开发-1" class="headerlink" title="腾讯 CSIG 腾讯云｜后台开发"></a>腾讯 CSIG 腾讯云｜后台开发</h2><h3 id="一面（挂）-6"><a href="#一面（挂）-6" class="headerlink" title="一面（挂）"></a>一面（挂）</h3><p>在线笔试，见笔试复盘文档📄：腾讯 CSIG 一面·笔试题</p>
<h2 id="字节跳动-AML-应用机器学习（未投）"><a href="#字节跳动-AML-应用机器学习（未投）" class="headerlink" title="字节跳动 AML 应用机器学习（未投）"></a>字节跳动 AML 应用机器学习（未投）</h2><p>…</p>
<h2 id="华为计算产品线｜软件开发"><a href="#华为计算产品线｜软件开发" class="headerlink" title="华为计算产品线｜软件开发"></a>华为计算产品线｜软件开发</h2><h3 id="机试"><a href="#机试" class="headerlink" title="机试"></a>机试</h3><ol>
<li><a href="https://wu-yikun.github.io/post/%E9%9D%A2%E7%BB%8F/0521-huawei/#1-%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E7%B3%BB%E7%BB%9F">开发一个简单任务调度系统 <span style="white-space: nowrap;"><svg width=".7em" height=".7em" viewBox="0 0 21 21" xmlns="http://www.w3.org/2000/svg"><path d="m13 3l3.293 3.293l-7 7l1.414 1.414l7-7L21 11V3z" fill="currentColor"></path><path d="M19 19H5V5h7l-2-2H5c-1.103 0-2 .897-2 2v14c0 1.103.897 2 2 2h14c1.103 0 2-.897 2-2v-5l-2-2v7z" fill="currentColor"></path></svg></span></a></li>
<li><a href="https://wu-yikun.github.io/post/%E9%9D%A2%E7%BB%8F/0521-huawei/#2-%E5%9C%B0%E9%9C%87%E6%95%91%E7%81%BE%E8%B7%AF%E7%BA%BF">地震救灾路线 <span style="white-space: nowrap;"><svg width=".7em" height=".7em" viewBox="0 0 21 21" xmlns="http://www.w3.org/2000/svg"><path d="m13 3l3.293 3.293l-7 7l1.414 1.414l7-7L21 11V3z" fill="currentColor"></path><path d="M19 19H5V5h7l-2-2H5c-1.103 0-2 .897-2 2v14c0 1.103.897 2 2 2h14c1.103 0 2-.897 2-2v-5l-2-2v7z" fill="currentColor"></path></svg></span></a></li>
<li><a href="https://wu-yikun.github.io/post/%E9%9D%A2%E7%BB%8F/0521-huawei/#3-%E4%BA%91%E8%AE%A1%E7%AE%97%E6%9C%8D%E5%8A%A1%E5%99%A8-GPU-%E5%88%86%E9%85%8D">云计算服务器 GPU 分配 <span style="white-space: nowrap;"><svg width=".7em" height=".7em" viewBox="0 0 21 21" xmlns="http://www.w3.org/2000/svg"><path d="m13 3l3.293 3.293l-7 7l1.414 1.414l7-7L21 11V3z" fill="currentColor"></path><path d="M19 19H5V5h7l-2-2H5c-1.103 0-2 .897-2 2v14c0 1.103.897 2 2 2h14c1.103 0 2-.897 2-2v-5l-2-2v7z" fill="currentColor"></path></svg></span></a></li>
</ol>
<h3 id="技术面"><a href="#技术面" class="headerlink" title="技术面"></a>技术面</h3><p>绩点排名、竞赛得奖情况</p>
<p>四次奖学金是本科还是研究生</p>
<p>智能指针</p>
<p>排序算法（快排、堆排、归排</p>
<p>二叉树的前中后序遍历</p>
<p>…</p>
<p>LeetCode 中等题</p>
<h3 id="主管面"><a href="#主管面" class="headerlink" title="主管面"></a>主管面</h3><p>自我介绍（过于简洁）</p>
<p>项目拷打（OPPO + 之江实验室）：</p>
<ul>
<li>oppo 业界最新解决方案</li>
<li>之江实验室 和 中科院哪个实习人数较多</li>
<li>之江实验室做了什么工作</li>
</ul>
<p>项目中遇到最大的挑战，如何解决</p>
<p>团队协作遇到冲突怎么处理</p>
<p>论文阅读量有多少</p>
<p>遇到新知识如何快速上手</p>
<p>平时如何调节压力</p>
<p>对华为价值观的理解</p>
<p>你的性格是乐观还是悲观</p>
<p>反问：</p>
<ul>
<li>华为实习生培养制度</li>
<li>计算产品线的技术栈</li>
</ul>

<div class="article-footer fs14">
    <section id="license">
      <div class="header"><span>许可协议</span></div>
      <div class="body"><p>本文由 <a target="_blank" rel="noopener" href="https://github.com/Wu-yikun">Yikun Wu <span style="white-space: nowrap;"><svg width=".7em" height=".7em" viewBox="0 0 21 21" xmlns="http://www.w3.org/2000/svg"><path d="m13 3l3.293 3.293l-7 7l1.414 1.414l7-7L21 11V3z" fill="currentColor"></path><path d="M19 19H5V5h7l-2-2H5c-1.103 0-2 .897-2 2v14c0 1.103.897 2 2 2h14c1.103 0 2-.897 2-2v-5l-2-2v7z" fill="currentColor"></path></svg></span></a> 原创，采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0 <span style="white-space: nowrap;"><svg width=".7em" height=".7em" viewBox="0 0 21 21" xmlns="http://www.w3.org/2000/svg"><path d="m13 3l3.293 3.293l-7 7l1.414 1.414l7-7L21 11V3z" fill="currentColor"></path><path d="M19 19H5V5h7l-2-2H5c-1.103 0-2 .897-2 2v14c0 1.103.897 2 2 2h14c1.103 0 2-.897 2-2v-5l-2-2v7z" fill="currentColor"></path></svg></span></a> 许可协议，转载请注明出处。</p>
</div>
    </section>
    
    <section id="share">
      <div class="header"><span>分享文章</span></div>
      <div class="body">
        <div class="link"><input class="copy-area" readonly="true" id="copy-link" value="https://wu-yikun.github.io/post/%E9%9D%A2%E7%BB%8F/interview-review/"></div>
        <div class="social-wrap dis-select"><a class="social share-item wechat" onclick="util.toggle(&quot;qrcode-wechat&quot;)"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/social/b32ef3da1162a.svg"></a><a class="social share-item weibo" target="_blank" rel="external nofollow noopener noreferrer" href="https://service.weibo.com/share/share.php?url=https://wu-yikun.github.io/post/%E9%9D%A2%E7%BB%8F/interview-review/&amp;title=暑期实习面经 - Yikun Wu&amp;pics=https://cdn.jsdelivr.net/gh/Wu-yikun/OSS/PicGo/202504132348287.jpg&amp;summary=陆续一个月了，腾讯、阿里云、淘天、高德、拼多多、字节、美团… 能投的都投了。
建议：多刷面经，可以快速积累场景题、设计题、多线程题，而且能快速 get 到高频八股，比如 oom、cpu 使用率高、慢查询治理…
找暑期哪有不疯的，运气也..."><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/social/80c07e4dbb303.svg"></a><a class="social share-item email" href="mailto:?subject=暑期实习面经 - Yikun Wu&amp;body=https://wu-yikun.github.io/post/%E9%9D%A2%E7%BB%8F/interview-review/"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/social/a1b00e20f425d.svg"></a><a class="social share-item link" onclick="util.copy(&quot;copy-link&quot;, &quot;复制成功&quot;)"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/social/8411ed322ced6.svg"></a></div>
        
        <div class="qrcode" id="qrcode-wechat" style="opacity:0;height:0">
          <img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://api.qrserver.com/v1/create-qr-code/?size=256x256&amp;data=https://wu-yikun.github.io/post/%E9%9D%A2%E7%BB%8F/interview-review/">
        </div>
        
      </div>
    </section>
    </div>
</article>
<div class="related-wrap" id="read-next"><section class="body"><div class="item" id="prev"><div class="note">上一篇</div><a href="/post/%E9%9D%A2%E7%BB%8F/job-hunting-guide-for-technical-personnel/">技术人求职指南</a></div><div class="item" id="next"><div class="note">下一篇</div><a href="/post/%E9%9D%A2%E7%BB%8F/reverse-interview/">面试的反问环节都可以问些什么？</a></div></section></div>




  <div class="related-wrap md-text" id="comments">
    <section class="header cmt-title cap theme">
      <p>快来参与讨论吧~</p>

    </section>
    <section class="body cmt-body giscus">
      

<svg class="loading" style="vertical-align:middle;fill:currentColor;overflow:hidden;" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2709"><path d="M832 512c0-176-144-320-320-320V128c211.2 0 384 172.8 384 384h-64zM192 512c0 176 144 320 320 320v64C300.8 896 128 723.2 128 512h64z" p-id="2710"></path></svg>

<div id="giscus" src="https://giscus.app/client.js" data-repo="Wu-yikun/wu-yikun.github.io" data-repo-id="R_kgDONub1yw" data-category="Q&amp;A" data-category-id="DIC_kwDONub1y84CmRgy" data-mapping="pathname" data-strict="0" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="top" data-theme="preferred_color_scheme" data-lang="zh-CN" data-loading="lazy" crossorigin="anonymous"></div>

    </section>
  </div>



<footer class="page-footer footnote"><hr><div class="text"><span id="busuanzi_container_site_pv">本站总访问量 <span id="busuanzi_value_site_pv"></span> 次</span><div><span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span></div></div></footer>


<script async="" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<script>
  function createtime() {
    var now = new Date();
    var grt= new Date("01/25/2025 00:00:00");
    now.setTime(now.getTime() + 250);
    days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days);
    hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours);
    if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum);
    mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;}
    seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);
    snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;}
    document.getElementById("timeDate").innerHTML = "本站已运行 "+dnum+" 天 ";
    document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒";
  };
  setInterval("createtime()",250);
</script>
<div class="main-mask" onclick="sidebar.dismiss()"></div></div><aside class="l_right">
<div class="widgets">

<widget class="widget-wrapper toc" id="data-toc" collapse="false"><div class="widget-header dis-select"><span class="name">本文目录</span><a class="cap-action" onclick="sidebar.toggleTOC()"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 6h11m-11 6h11m-11 6h11M4 6h1v4m-1 0h2m0 8H4c0-1 2-2 2-3s-1-1.5-2-1"></path></svg></a></div><div class="widget-body"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%85%BE%E8%AE%AF-CDG-%E9%87%91%E8%9E%8D%E7%A7%91%E6%8A%80%EF%BD%9C%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91"><span class="toc-text">腾讯 CDG 金融科技｜后台开发</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E9%9D%A2"><span class="toc-text">一面</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E9%9D%A2%EF%BC%88%E6%8C%82%EF%BC%89"><span class="toc-text">二面（挂）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%85%BE%E8%AE%AF-PCG-QQ%EF%BD%9C%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91"><span class="toc-text">腾讯 PCG QQ｜后台开发</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E9%9D%A2%EF%BC%88%E6%8C%82%EF%BC%89"><span class="toc-text">一面（挂）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%85%BE%E8%AE%AF-PCG-QQ%EF%BD%9C%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91-1"><span class="toc-text">腾讯 PCG QQ｜后台开发</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E9%9D%A2%EF%BC%88%E6%8C%82%EF%BC%89-1"><span class="toc-text">一面（挂）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BF%AB%E6%89%8B%E6%B7%B1%E5%B9%BF%E6%90%9C%EF%BD%9CC-%E5%BC%80%E5%8F%91"><span class="toc-text">快手深广搜｜C++ 开发</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E9%9D%A2%EF%BC%88%E6%8C%82%EF%BC%89-2"><span class="toc-text">一面（挂）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vivo-C-C-%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91"><span class="toc-text">Vivo C/C++ 嵌入式开发</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E9%9D%A2%EF%BC%88%E6%8C%82%EF%BC%89-3"><span class="toc-text">一面（挂）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%85%BE%E8%AE%AF-CSIG-%E8%85%BE%E8%AE%AF%E4%BA%91%EF%BD%9C%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91"><span class="toc-text">腾讯 CSIG 腾讯云｜后台开发</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E9%9D%A2%EF%BC%88%E6%8C%82%EF%BC%89-4"><span class="toc-text">一面（挂）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%85%BE%E8%AE%AF-WXG-%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%EF%BD%9C%E6%B5%8B%E8%AF%95%E5%BC%80%E5%8F%91"><span class="toc-text">腾讯 WXG 企业微信｜测试开发</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E9%9D%A2%EF%BC%88%E6%8C%82%EF%BC%89-5"><span class="toc-text">一面（挂）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BE%8E%E5%9B%BE%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84%EF%BD%9CC-%E5%BC%80%E5%8F%91%EF%BC%88%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84%EF%BC%89"><span class="toc-text">美图基础架构｜C++ 开发（基础架构）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E9%9D%A2%EF%BC%88%E6%8B%92%EF%BC%89"><span class="toc-text">一面（拒）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%93%E9%A9%AD%E6%99%BA%E9%A9%BE%E7%AB%AF%E5%88%B0%E7%AB%AF%EF%BD%9CC-C-%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91"><span class="toc-text">卓驭智驾端到端｜C/C++ 嵌入式开发</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E9%9D%A2%EF%BC%88OC%EF%BC%89"><span class="toc-text">一面（OC）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8%EF%BD%9C%E6%8E%A8%E8%8D%90%E6%9E%B6%E6%9E%84%E7%B3%BB%E7%BB%9F%E5%AE%9E%E4%B9%A0%E7%94%9F"><span class="toc-text">字节跳动｜推荐架构系统实习生</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E9%9D%A2-1"><span class="toc-text">一面</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E9%9D%A2%EF%BC%88%E6%8C%82%EF%BC%89-1"><span class="toc-text">二面（挂）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%85%BE%E8%AE%AF-CSIG-%E8%85%BE%E8%AE%AF%E4%BA%91%EF%BD%9C%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91-1"><span class="toc-text">腾讯 CSIG 腾讯云｜后台开发</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E9%9D%A2%EF%BC%88%E6%8C%82%EF%BC%89-6"><span class="toc-text">一面（挂）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8-AML-%E5%BA%94%E7%94%A8%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%88%E6%9C%AA%E6%8A%95%EF%BC%89"><span class="toc-text">字节跳动 AML 应用机器学习（未投）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%8E%E4%B8%BA%E8%AE%A1%E7%AE%97%E4%BA%A7%E5%93%81%E7%BA%BF%EF%BD%9C%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91"><span class="toc-text">华为计算产品线｜软件开发</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%BA%E8%AF%95"><span class="toc-text">机试</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%80%E6%9C%AF%E9%9D%A2"><span class="toc-text">技术面</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E7%AE%A1%E9%9D%A2"><span class="toc-text">主管面</span></a></li></ol></li></ol></div><div class="widget-footer">

<a class="top" onclick="util.scrollTop()"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="1.5"><path d="M2 12c0-4.714 0-7.071 1.464-8.536C4.93 2 7.286 2 12 2c4.714 0 7.071 0 8.535 1.464C22 4.93 22 7.286 22 12c0 4.714 0 7.071-1.465 8.535C19.072 22 16.714 22 12 22s-7.071 0-8.536-1.465C2 19.072 2 16.714 2 12Z"></path><path stroke-linecap="round" stroke-linejoin="round" d="m9 15.5l3-3l3 3m-6-4l3-3l3 3"></path></g></svg><span>回到顶部</span></a><a class="buttom" onclick="util.scrollComment()"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" fill-rule="evenodd" d="M10.46 1.25h3.08c1.603 0 2.86 0 3.864.095c1.023.098 1.861.3 2.6.752a5.75 5.75 0 0 1 1.899 1.899c.452.738.654 1.577.752 2.6c.095 1.004.095 2.261.095 3.865v1.067c0 1.141 0 2.036-.05 2.759c-.05.735-.153 1.347-.388 1.913a5.75 5.75 0 0 1-3.112 3.112c-.805.334-1.721.408-2.977.43a10.81 10.81 0 0 0-.929.036c-.198.022-.275.054-.32.08c-.047.028-.112.078-.224.232c-.121.166-.258.396-.476.764l-.542.916c-.773 1.307-2.69 1.307-3.464 0l-.542-.916a10.605 10.605 0 0 0-.476-.764c-.112-.154-.177-.204-.224-.232c-.045-.026-.122-.058-.32-.08c-.212-.023-.49-.03-.93-.037c-1.255-.021-2.171-.095-2.976-.429A5.75 5.75 0 0 1 1.688 16.2c-.235-.566-.338-1.178-.389-1.913c-.049-.723-.049-1.618-.049-2.76v-1.066c0-1.604 0-2.86.095-3.865c.098-1.023.3-1.862.752-2.6a5.75 5.75 0 0 1 1.899-1.899c.738-.452 1.577-.654 2.6-.752C7.6 1.25 8.857 1.25 10.461 1.25M6.739 2.839c-.914.087-1.495.253-1.959.537A4.25 4.25 0 0 0 3.376 4.78c-.284.464-.45 1.045-.537 1.96c-.088.924-.089 2.11-.089 3.761v1c0 1.175 0 2.019.046 2.685c.045.659.131 1.089.278 1.441a4.25 4.25 0 0 0 2.3 2.3c.515.214 1.173.294 2.429.316h.031c.398.007.747.013 1.037.045c.311.035.616.104.909.274c.29.17.5.395.682.645c.169.232.342.525.538.856l.559.944a.52.52 0 0 0 .882 0l.559-.944c.196-.331.37-.624.538-.856c.182-.25.392-.476.682-.645c.293-.17.598-.24.909-.274c.29-.032.639-.038 1.037-.045h.032c1.255-.022 1.913-.102 2.428-.316a4.25 4.25 0 0 0 2.3-2.3c.147-.352.233-.782.278-1.441c.046-.666.046-1.51.046-2.685v-1c0-1.651 0-2.837-.089-3.762c-.087-.914-.253-1.495-.537-1.959a4.25 4.25 0 0 0-1.403-1.403c-.464-.284-1.045-.45-1.96-.537c-.924-.088-2.11-.089-3.761-.089h-3c-1.651 0-2.837 0-3.762.089" clip-rule="evenodd"></path><path fill="currentColor" d="M9 11a1 1 0 1 1-2 0a1 1 0 0 1 2 0m4 0a1 1 0 1 1-2 0a1 1 0 0 1 2 0m4 0a1 1 0 1 1-2 0a1 1 0 0 1 2 0"></path></svg><span>参与讨论</span></a></div></widget>
</div></aside><div class="float-panel blur">
  <button type="button" style="display:none" class="laptop-only rightbar-toggle mobile" onclick="sidebar.rightbar()">
    <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 6h11m-11 6h11m-11 6h11M4 6h1v4m-1 0h2m0 8H4c0-1 2-2 2-3s-1-1.5-2-1"></path></svg>
  </button>
  <button type="button" style="display:none" class="mobile-only leftbar-toggle mobile" onclick="sidebar.leftbar()">
    <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="1.5"><path d="M2 11c0-3.771 0-5.657 1.172-6.828C4.343 3 6.229 3 10 3h4c3.771 0 5.657 0 6.828 1.172C22 5.343 22 7.229 22 11v2c0 3.771 0 5.657-1.172 6.828C19.657 21 17.771 21 14 21h-4c-3.771 0-5.657 0-6.828-1.172C2 18.657 2 16.771 2 13z"></path><path id="sep" stroke-linecap="round" d="M5.5 10h6m-5 4h4m4.5 7V3"></path></g></svg>
  </button>
</div>
</div><div class="scripts">
<script type="text/javascript">
  const ctx = {
    date_suffix: {
      just: `刚刚`,
      min: `分钟前`,
      hour: `小时前`,
      day: `天前`,
    },
    root : `/`,
  };

  // required plugins (only load if needs)
  if (`local_search`) {
    ctx.search = {};
    ctx.search.service = `local_search`;
    if (ctx.search.service == 'local_search') {
      let service_obj = Object.assign({}, `{"field":"all","path":"/search.json","content":true,"sort":"-date"}`);
      ctx.search[ctx.search.service] = service_obj;
    }
  }
  const def = {
    avatar: `https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/avatar/round/3442075.svg`,
    cover: `https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/cover/76b86c0226ffd.svg`,
  };
  const deps = {
    jquery: `https://cdn.jsdelivr.net/npm/jquery@3.7.1/dist/jquery.min.js`,
    marked: `https://cdn.jsdelivr.net/npm/marked@13.0.1/lib/marked.umd.min.js`
  }
  

</script>

<script type="text/javascript">
  const utils = {
    // 懒加载 css https://github.com/filamentgroup/loadCSS
    css: (href, before, media, attributes) => {
      var doc = window.document;
      var ss = doc.createElement("link");
      var ref;
      if (before) {
        ref = before;
      } else {
        var refs = (doc.body || doc.getElementsByTagName("head")[0]).childNodes;
        ref = refs[refs.length - 1];
      }
      var sheets = doc.styleSheets;
      if (attributes) {
        for (var attributeName in attributes) {
          if (attributes.hasOwnProperty(attributeName)) {
            ss.setAttribute(attributeName, attributes[attributeName]);
          }
        }
      }
      ss.rel = "stylesheet";
      ss.href = href;
      ss.media = "only x";
      function ready(cb) {
        if (doc.body) {
          return cb();
        }
        setTimeout(function () {
          ready(cb);
        });
      }
      ready(function () {
        ref.parentNode.insertBefore(ss, before ? ref : ref.nextSibling);
      });
      var onloadcssdefined = function (cb) {
        var resolvedHref = ss.href;
        var i = sheets.length;
        while (i--) {
          if (sheets[i].href === resolvedHref) {
            return cb();
          }
        }
        setTimeout(function () {
          onloadcssdefined(cb);
        });
      };
      function loadCB() {
        if (ss.addEventListener) {
          ss.removeEventListener("load", loadCB);
        }
        ss.media = media || "all";
      }
      if (ss.addEventListener) {
        ss.addEventListener("load", loadCB);
      }
      ss.onloadcssdefined = onloadcssdefined;
      onloadcssdefined(loadCB);
      return ss;
    },

    js: (src, opt) => new Promise((resolve, reject) => {
      var script = document.createElement('script');
      if (src.startsWith('/')){
        src = ctx.root + src.substring(1);
      }
      script.src = src;
      if (opt) {
        for (let key of Object.keys(opt)) {
          script[key] = opt[key]
        }
      } else {
        // 默认异步，如果需要同步，第二个参数传入 {} 即可
        script.async = true
      }
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    }),

    jq: (fn) => {
      if (typeof jQuery === 'undefined') {
        utils.js(deps.jquery).then(fn)
      } else {
        fn()
      }
    },
    
    onLoading: (el) => {
      if (el) {
        $(el).append('<div class="loading-wrap"><svg xmlns="http://www.w3.org/2000/svg" width="2em" height="2em" preserveAspectRatio="xMidYMid meet" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-width="2"><path stroke-dasharray="60" stroke-dashoffset="60" stroke-opacity=".3" d="M12 3C16.9706 3 21 7.02944 21 12C21 16.9706 16.9706 21 12 21C7.02944 21 3 16.9706 3 12C3 7.02944 7.02944 3 12 3Z"><animate fill="freeze" attributeName="stroke-dashoffset" dur="1.3s" values="60;0"/></path><path stroke-dasharray="15" stroke-dashoffset="15" d="M12 3C16.9706 3 21 7.02944 21 12"><animate fill="freeze" attributeName="stroke-dashoffset" dur="0.3s" values="15;0"/><animateTransform attributeName="transform" dur="1.5s" repeatCount="indefinite" type="rotate" values="0 12 12;360 12 12"/></path></g></svg></div>');
      }
    },
    onLoadSuccess: (el) => {
      if (el) {
        $(el).find('.loading-wrap').remove();
      }
    },
    onLoadFailure: (el) => {
      if (el) {
        $(el).find('.loading-wrap svg').remove();
        $(el).find('.loading-wrap').append('<svg xmlns="http://www.w3.org/2000/svg" width="2em" height="2em" preserveAspectRatio="xMidYMid meet" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2"><path stroke-dasharray="60" stroke-dashoffset="60" d="M12 3L21 20H3L12 3Z"><animate fill="freeze" attributeName="stroke-dashoffset" dur="0.5s" values="60;0"/></path><path stroke-dasharray="6" stroke-dashoffset="6" d="M12 10V14"><animate fill="freeze" attributeName="stroke-dashoffset" begin="0.6s" dur="0.2s" values="6;0"/></path></g><circle cx="12" cy="17" r="1" fill="currentColor" fill-opacity="0"><animate fill="freeze" attributeName="fill-opacity" begin="0.8s" dur="0.4s" values="0;1"/></circle></svg>');
        $(el).find('.loading-wrap').addClass('error');
      }
    },
    request: (el, url, callback, onFailure) => {
      let retryTimes = 3;
      utils.onLoading(el);
      function req() {
        return new Promise((resolve, reject) => {
          let status = 0; // 0 等待 1 完成 2 超时
          let timer = setTimeout(() => {
            if (status === 0) {
              status = 2;
              timer = null;
              reject('请求超时');
              if (retryTimes == 0) {
                onFailure();
              }
            }
          }, 5000);
          fetch(url).then(function(response) {
            if (status !== 2) {
              clearTimeout(timer);
              resolve(response);
              timer = null;
              status = 1;
            }
            if (response.ok) {
              return response.json();
            }
            throw new Error('Network response was not ok.');
          }).then(function(data) {
            retryTimes = 0;
            utils.onLoadSuccess(el);
            callback(data);
          }).catch(function(error) {
            if (retryTimes > 0) {
              retryTimes -= 1;
              setTimeout(() => {
                req();
              }, 5000);
            } else {
              utils.onLoadFailure(el);
              onFailure();
            }
          });
        });
      }
      req();
    },
  };
</script>

<script>
  const sidebar = {
    leftbar: () => {
      if (l_body) {
        l_body.toggleAttribute('leftbar');
        l_body.removeAttribute('rightbar');
      }
    },
    rightbar: () => {
      if (l_body) {
        l_body.toggleAttribute('rightbar');
        l_body.removeAttribute('leftbar');
      }
    },
    dismiss: () => {
      if (l_body) {
        l_body.removeAttribute('leftbar');
        l_body.removeAttribute('rightbar');
      }
    },
    toggleTOC: () => {
      document.querySelector('#data-toc').classList.toggle('collapse');
    }
  }
</script>
<script type="text/javascript">
  (() => {
    const tagSwitchers = document.querySelectorAll('.tag-subtree.parent-tag > a > .tag-switcher-wrapper')
    for (const tagSwitcher of tagSwitchers) {
      tagSwitcher.addEventListener('click', (e) => {
        const parent = e.target.closest('.tag-subtree.parent-tag')
        parent.classList.toggle('expanded')
        e.preventDefault()
      })
    }

    // Get active tag from query string, then activate it.
    const urlParams = new URLSearchParams(window.location.search)
    const activeTag = urlParams.get('tag')
    if (activeTag) {
      let tag = document.querySelector(`.tag-subtree[data-tag="${activeTag}"]`)
      if (tag) {
        tag.querySelector('a').classList.add('active')
        
        while (tag) {
          tag.classList.add('expanded')
          tag = tag.parentElement.closest('.tag-subtree.parent-tag')
        }
      }
    }
  })()
</script>


<!-- required -->
<script src="/js/main.js?v=1.29.1" defer=""></script>

<script type="text/javascript">
  const applyTheme = (theme) => {
    if (theme === 'auto') {
      document.documentElement.removeAttribute('data-theme')
    } else {
      document.documentElement.setAttribute('data-theme', theme)
    }

    applyThemeToGiscus(theme)
  }

  const applyThemeToGiscus = (theme) => {
    theme = theme === 'auto' ? 'preferred_color_scheme' : theme

    const cmt = document.getElementById('giscus')
    if (cmt) {
      // This works before giscus load.
      cmt.setAttribute('data-theme', theme)
    }

    const iframe = document.querySelector('#comments > section.giscus > iframe')
    if (iframe) {
      // This works after giscus loaded.
      const src = iframe.src
      const newSrc = src.replace(/theme=[\w]+/, `theme=${theme}`)
      iframe.src = newSrc
    }
  }

  const switchTheme = () => {
    // light -> dark -> auto -> light -> ...
    const currentTheme = document.documentElement.getAttribute('data-theme')
    let newTheme;
    switch (currentTheme) {
      case 'light':
        newTheme = 'dark'
        break
      case 'dark':
        newTheme = 'auto'
        break
      default:
        newTheme = 'light'
    }
    applyTheme(newTheme)
    window.localStorage.setItem('Stellar.theme', newTheme)

    const messages = {
      light: `切换到浅色模式`,
      dark: `切换到深色模式`,
      auto: `切换到跟随系统配色`,
    }
    hud?.toast?.(messages[newTheme])
  }

  (() => {
    // Apply user's preferred theme, if any.
    const theme = window.localStorage.getItem('Stellar.theme')
    if (theme !== null) {
      applyTheme(theme)
    }
  })()
</script>


<!-- optional -->

  <script type="module">
  const el = document.querySelector('#comments #giscus');
  util.viewportLazyload(el, load_discus, false);

  function load_discus() {
    if (!el) return;
    try {
        el.innerHTML = '';
      } catch (error) {
        console.error(error);
      }
      const script = document.createElement('script');
      script.async = true;
      for (const key of Object.keys(el.attributes)) {
        const attr = el.attributes[key];
        if (['class', 'id'].includes(attr.name) === false) {
          script.setAttribute(attr.name, attr.value);
        }
      }
      el.appendChild(script);
  }
</script>




<script defer="">
  window.addEventListener('DOMContentLoaded', (event) => {
    ctx.services = Object.assign({}, JSON.parse(`{"mdrender":{"js":"/js/services/mdrender.js"},"siteinfo":{"js":"/js/services/siteinfo.js","api":null},"ghinfo":{"js":"/js/services/ghinfo.js"},"sites":{"js":"/js/services/sites.js"},"friends":{"js":"/js/services/friends.js"},"timeline":{"js":"/js/services/timeline.js"},"fcircle":{"js":"/js/services/fcircle.js"},"weibo":{"js":"/js/services/weibo.js"},"memos":{"js":"/js/services/memos.js"},"giscus":{"js":"/js/services/giscus_new.js"}}`));
    for (let id of Object.keys(ctx.services)) {
      const js = ctx.services[id].js;
      if (id == 'siteinfo') {
        ctx.cardlinks = document.querySelectorAll('a.link-card[cardlink]');
        if (ctx.cardlinks?.length > 0) {
          utils.js(js, { defer: true }).then(function () {
            setCardLink(ctx.cardlinks);
          });
        }
      } else {
        const els = document.getElementsByClassName(`ds-${id}`);
        if (els?.length > 0) {
          utils.jq(() => {
            if (id == 'timeline' || 'memos' || 'marked') {
              utils.js(deps.marked).then(function () {
                utils.js(js, { defer: true });
              });
            } else {
              utils.js(js, { defer: true });
            }
          });
        }
      }
    }
  });
</script>

<script>
  window.addEventListener('DOMContentLoaded', (event) => {
    ctx.search = {
      path: `/search.json`,
    }
    utils.js('/js/search/local-search.js', { defer: true });
  });
</script><script>
  window.FPConfig = {
    delay: 0,
    ignoreKeywords: [],
    maxRPS: 5,
    hoverDelay: 25
  };
</script>
<script defer="" src="https://cdn.jsdelivr.net/npm/flying-pages@2/flying-pages.min.js"></script><script defer="" src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@19.1.3/dist/lazyload.min.js"></script>
<script>
  // https://www.npmjs.com/package/vanilla-lazyload
  // Set the options globally
  // to make LazyLoad self-initialize
  window.lazyLoadOptions = {
    elements_selector: ".lazy",
  };
  // Listen to the initialization event
  // and get the instance of LazyLoad
  window.addEventListener(
    "LazyLoad::Initialized",
    function (event) {
      window.lazyLoadInstance = event.detail.instance;
    },
    false
  );
  document.addEventListener('DOMContentLoaded', function () {
    window.lazyLoadInstance?.update();
  });
</script><script>
  ctx.fancybox = {
    selector: `.timenode p>img`,
    css: `https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0/dist/fancybox/fancybox.css`,
    js: `https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0/dist/fancybox/fancybox.umd.js`
  };
  var selector = '[data-fancybox]:not(.error)';
  if (ctx.fancybox.selector) {
    selector += `, ${ctx.fancybox.selector}`
  }
  var needFancybox = document.querySelectorAll(selector).length !== 0;
  if (!needFancybox) {
    const els = document.getElementsByClassName('ds-memos');
    if (els != undefined && els.length > 0) {
      needFancybox = true;
    }
  }
  if (needFancybox) {
    utils.css(ctx.fancybox.css);
    utils.js(ctx.fancybox.js, { defer: true }).then(function () {
      Fancybox.bind(selector, {
        hideScrollbar: false,
        Thumbs: {
          autoStart: false,
        },
        caption: (fancybox, slide) => {
          return slide.triggerEl.alt || slide.triggerEl.dataset.caption || null
        }
      });
    })
  }
</script>
<script>
  window.addEventListener('DOMContentLoaded', (event) => {
    const swiper_api = document.getElementById('swiper-api');
    if (swiper_api != undefined) {
      utils.css(`https://unpkg.com/swiper@10.3.1/swiper-bundle.min.css`);
      utils.js(`https://unpkg.com/swiper@10.3.1/swiper-bundle.min.js`, { defer: true }).then(function () {
        const effect = swiper_api.getAttribute('effect') || '';
        var swiper = new Swiper('.swiper#swiper-api', {
          slidesPerView: 'auto',
          spaceBetween: 8,
          centeredSlides: true,
          effect: effect,
          rewind: true,
          pagination: {
            el: '.swiper-pagination',
            clickable: true,
          },
          navigation: {
            nextEl: '.swiper-button-next',
            prevEl: '.swiper-button-prev',
          },
        });
      })
    }
  });
</script>
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.6/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"] ],
    processEscapes: true
  }
});
MathJax.Hub.Config({
  tex2jax: {
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  }
});
MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for(i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script>
<script>
  document.addEventListener('DOMContentLoaded', function () {
    window.codeElements = document.querySelectorAll('.code');
    if (window.codeElements.length > 0) {
      ctx.copycode = {
        default_text: `Copy`,
        success_text: `Copied`,
        toast: `复制成功`,
      };
      utils.js('/js/plugins/copycode.js');
    }
  });
</script>


<!-- inject -->

</div>
</body></html><script>var posts=["post/AI infra/animated-pictures-to-easily-understand-self-attention/","post/AI infra/how-does-chatgpt-handle-text-input/","post/AI infra/recommendation-system-architecture/","post/AI infra/the-soul-of-chatgpt-attention-mechanism/","post/Golang/golang-wiki/","post/Python/python-wiki/","post/博客开发/building-a-personal-blog-from-scratch/","post/博客开发/hexo-stellar-development-guide/","post/C++/cpp-copy-constructor/","post/C++/cpp-wiki/","post/C++/effective-c++/","post/C++/cpp-stl/","post/C++/from-posix-pthread-to-c++11-thread/","post/C++/network-programming-and-io-multiplexing/","post/开发工具/docker-and-k8s/","post/开发工具/git-principle/","post/开发工具/git-undo/","post/开发工具/docker-intro/","post/开发工具/nat/","post/开发工具/markdown-mathjax-basic-tutorial-and-quick-reference/","post/小吳日寄/2025-06-11/","post/开发工具/tips-for-precise-search-on-github/","post/开发工具/understanding-.git-folder/","post/年终总结/「2022」life-is-a-field-not-a-track/","post/年终总结/「2021」passion/","post/年终总结/「2023」feel-the-journey/","post/摄影日志/camera/","post/年终总结/「2024」the-world-points-to-wherever-I-want-to-go/","post/摄影日志/chengdu_2024-07-14/","post/摄影日志/shot/","post/未来世界的幸存者/constantly-comparing-yourself-to-others-is-the-tragedy-of-life/","post/未来世界的幸存者/choose-one-sentence/","post/未来世界的幸存者/don't-limit-your-future-imagination-with-your-current-abilities/","post/未来世界的幸存者/deep-thoughts/","post/未来世界的幸存者/technical-writing-experience/","post/未来世界的幸存者/how-can-undergraduates-enter-bat/","post/数据结构与算法/advanced-algorithms/","post/数据结构与算法/binary-tree-matching/","post/数据结构与算法/constructing-binary-tree/","post/数据结构与算法/cpp-acm-input-output/","post/数据结构与算法/difference-array/","post/数据结构与算法/heapsort-quicksort-mergesort/","post/数据结构与算法/interview-add-two/","post/数据结构与算法/kuaishou-merge-k-ascending-linked-lists/","post/数据结构与算法/modulo/","post/数据结构与算法/interview-linked-list/","post/数据结构与算法/maximum-product-of-subarray-or-subsequence/","post/数据结构与算法/monotonic-stack/","post/数据结构与算法/qpow/","post/数据结构与算法/sieve-of-prime-number/","post/数据结构与算法/tackle-without-sort-library/","post/数据结构与算法/tecent-wxg-russian-doll-envelope/","post/数据结构与算法/union-search/","post/藏书阁/siddhartha/","post/计算机网络/does-restarting-mean-shutting-down-and-power-on/","post/计算机网络/network-ip/","post/计算机网络/reverse-proxy/","post/面经/0521-huawei/","post/面经/reverse-interview/","post/面经/interview-review/","post/系统与体系结构/a-study-of-linux-file-system-evolution/","post/面经/job-hunting-guide-for-technical-personnel/","post/系统与体系结构/analysis-of-trace-processing/","post/系统与体系结构/debugging-with-gdb/","post/系统与体系结构/distributed-systems-theoretical-foundations/","post/系统与体系结构/duckdb's-adaptive-radix-tree-source-code/","post/系统与体系结构/how-to-ensure-crash-consistency-in-distributed-systems/","post/系统与体系结构/distributed-systems-paxos.md/","post/系统与体系结构/linux-disk-automatic-mounting/","post/系统与体系结构/linux-kernel-io-path/","post/系统与体系结构/linux-partition/","post/系统与体系结构/distributed-systems-raft/","post/系统与体系结构/madam-for-all-flash-array/","post/系统与体系结构/mmap-vs-read-write/","post/系统与体系结构/nvm-top-lab/","post/系统与体系结构/persistent-memory-research-report/","post/系统与体系结构/pmdk-programming-guidelines/"];function toRandomPost(){ var randomPath = posts[Math.floor(Math.random()*posts.length)]; var encodedPath = encodeURIComponent(randomPath); window.open('/' + encodedPath, "_self"); };</script>